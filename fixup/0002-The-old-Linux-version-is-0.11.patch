From 4123273d2825209fa253faa2473bc2779e955b06 Mon Sep 17 00:00:00 2001
From: Aaron Chou <zhoubb.aaron@gmail.com>
Date: Mon, 28 Dec 2015 13:48:35 +0800
Subject: [PATCH 2/6] The old Linux version is 0.11

Signed-off-by: Aaron Chou <zhoubb.aaron@gmail.com>
---
 Makefile                           |  73 ++--
 boot/boot.s                        | 329 -----------------
 boot/bootsect.s                    | 260 ++++++++++++++
 boot/head.s                        | 107 ++++--
 boot/setup.s                       | 231 ++++++++++++
 fs/Makefile                        |  73 ++--
 fs/bitmap.c                        |  12 +-
 fs/block_dev.c                     |  63 ++--
 fs/buffer.c                        | 243 ++++++++++---
 fs/char_dev.c                      | 102 ++++--
 fs/exec.c                          | 329 +++++++++--------
 fs/fcntl.c                         |   6 +
 fs/file_dev.c                      |   6 +
 fs/file_table.c                    |   6 +
 fs/inode.c                         |  98 +++--
 fs/ioctl.c                         |   8 +-
 fs/namei.c                         | 158 ++++++--
 fs/open.c                          |  52 ++-
 fs/pipe.c                          |  77 ++--
 fs/read_write.c                    |  18 +-
 fs/stat.c                          |  19 +-
 fs/super.c                         | 247 +++++++++++--
 fs/truncate.c                      |   6 +
 include/asm/segment.h              |  39 ++
 include/ctype.h                    |   4 +-
 include/linux/config.h             |  77 ++--
 include/linux/fdreg.h              |  71 ++++
 include/linux/fs.h                 |  59 +--
 include/linux/hdreg.h              |  34 --
 include/linux/kernel.h             |  13 +
 include/linux/sched.h              |  17 +-
 include/linux/sys.h                |   8 +-
 include/linux/tty.h                |  11 +-
 include/signal.h                   |   3 +
 include/string.h                   |  18 +-
 include/unistd.h                   |  31 +-
 init/main.c                        | 112 ++++--
 kernel/Makefile                    |  55 ++-
 kernel/asm.s                       |  49 +--
 kernel/blk_drv/Makefile            |  58 +++
 kernel/blk_drv/blk.h               | 140 ++++++++
 kernel/blk_drv/floppy.c            | 462 ++++++++++++++++++++++++
 kernel/blk_drv/hd.c                | 350 ++++++++++++++++++
 kernel/blk_drv/ll_rw_blk.c         | 165 +++++++++
 kernel/blk_drv/ramdisk.c           | 125 +++++++
 kernel/chr_drv/Makefile            |  68 ++++
 kernel/chr_drv/console.c           | 712 +++++++++++++++++++++++++++++++++++++
 kernel/chr_drv/keyboard.S          | 588 ++++++++++++++++++++++++++++++
 kernel/chr_drv/rs_io.s             | 147 ++++++++
 kernel/{ => chr_drv}/serial.c      |  28 +-
 kernel/{ => chr_drv}/tty_io.c      | 145 +++++---
 {fs => kernel/chr_drv}/tty_ioctl.c |  48 ++-
 kernel/console.c                   | 550 ----------------------------
 kernel/exit.c                      | 146 +++++---
 kernel/fork.c                      |  17 +-
 kernel/hd.c                        | 413 ---------------------
 kernel/keyboard.s                  | 409 ---------------------
 kernel/math/Makefile               |  43 +++
 kernel/math/math_emulate.c         |  42 +++
 kernel/mktime.c                    |   6 +
 kernel/panic.c                     |  13 +
 kernel/printk.c                    |   8 +
 kernel/rs_io.s                     | 141 --------
 kernel/sched.c                     | 208 +++++++++--
 kernel/signal.c                    | 119 +++++++
 kernel/sys.c                       | 118 +++---
 kernel/system_call.s               | 102 +++++-
 kernel/traps.c                     |  30 +-
 kernel/vsprintf.c                  |  24 +-
 lib/Makefile                       |  31 +-
 lib/_exit.c                        |   6 +
 lib/close.c                        |   6 +
 lib/ctype.c                        |   6 +
 lib/dup.c                          |   6 +
 lib/errno.c                        |   6 +
 lib/execve.c                       |   6 +
 lib/malloc.c                       | 231 ++++++++++++
 lib/open.c                         |   8 +-
 lib/setsid.c                       |   6 +
 lib/string.c                       |   6 +
 lib/wait.c                         |   6 +
 lib/write.c                        |   6 +
 mm/Makefile                        |   4 +-
 mm/memory.c                        | 216 +++++++++--
 mm/page.s                          |   6 +
 tools/build.c                      | 122 ++++++-
 86 files changed, 6420 insertions(+), 2807 deletions(-)
 delete mode 100644 boot/boot.s
 create mode 100644 boot/bootsect.s
 create mode 100644 boot/setup.s
 create mode 100644 include/linux/fdreg.h
 create mode 100644 kernel/blk_drv/Makefile
 create mode 100644 kernel/blk_drv/blk.h
 create mode 100644 kernel/blk_drv/floppy.c
 create mode 100644 kernel/blk_drv/hd.c
 create mode 100644 kernel/blk_drv/ll_rw_blk.c
 create mode 100644 kernel/blk_drv/ramdisk.c
 create mode 100644 kernel/chr_drv/Makefile
 create mode 100644 kernel/chr_drv/console.c
 create mode 100644 kernel/chr_drv/keyboard.S
 create mode 100644 kernel/chr_drv/rs_io.s
 rename kernel/{ => chr_drv}/serial.c (61%)
 rename kernel/{ => chr_drv}/tty_io.c (62%)
 rename {fs => kernel/chr_drv}/tty_ioctl.c (81%)
 delete mode 100644 kernel/console.c
 delete mode 100644 kernel/hd.c
 delete mode 100644 kernel/keyboard.s
 create mode 100644 kernel/math/Makefile
 create mode 100644 kernel/math/math_emulate.c
 delete mode 100644 kernel/rs_io.s
 create mode 100644 kernel/signal.c
 create mode 100644 lib/malloc.c

diff --git a/Makefile b/Makefile
index d778626..9ed3657 100644
--- a/Makefile
+++ b/Makefile
@@ -1,21 +1,30 @@
 #
-# Makefile for linux.
-# If you don't have '-mstring-insns' in your gcc (and nobody but me has :-)
-# remove them from the CFLAGS defines.
+# if you want the ram-disk device, define this to be the
+# size in blocks.
 #
+RAMDISK = #-DRAMDISK=512
 
-AS86	=as -0 -a
-CC86	=cc -0
-LD86	=ld -0
+AS86	=as86 -0 -a
+LD86	=ld86 -0
 
 AS	=gas
 LD	=gld
 LDFLAGS	=-s -x -M
-CC	=gcc
-CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs
-CPP	=gcc -E -nostdinc -Iinclude
+CC	=gcc $(RAMDISK)
+CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer \
+-fcombine-regs -mstring-insns
+CPP	=cpp -nostdinc -Iinclude
+
+#
+# ROOT_DEV specifies the default root-device when making the image.
+# This can be either FLOPPY, /dev/xxxx or empty, in which case the
+# default of /dev/hd6 is used by 'build'.
+#
+ROOT_DEV=/dev/hd6
 
 ARCHIVES=kernel/kernel.o mm/mm.o fs/fs.o
+DRIVERS =kernel/blk_drv/blk_drv.a kernel/chr_drv/chr_drv.a
+MATH	=kernel/math/math.a
 LIBS	=lib/lib.a
 
 .c.s:
@@ -29,24 +38,37 @@ LIBS	=lib/lib.a
 
 all:	Image
 
-Image: boot/boot tools/system tools/build
-	tools/build boot/boot tools/system > Image
+Image: boot/bootsect boot/setup tools/system tools/build
+	tools/build boot/bootsect boot/setup tools/system $(ROOT_DEV) > Image
 	sync
 
+disk: Image
+	dd bs=8192 if=Image of=/dev/PS0
+
 tools/build: tools/build.c
 	$(CC) $(CFLAGS) \
 	-o tools/build tools/build.c
-	chmem +65000 tools/build
 
 boot/head.o: boot/head.s
 
 tools/system:	boot/head.o init/main.o \
-		$(ARCHIVES) $(LIBS)
+		$(ARCHIVES) $(DRIVERS) $(MATH) $(LIBS)
 	$(LD) $(LDFLAGS) boot/head.o init/main.o \
 	$(ARCHIVES) \
+	$(DRIVERS) \
+	$(MATH) \
 	$(LIBS) \
 	-o tools/system > System.map
 
+kernel/math/math.a:
+	(cd kernel/math; make)
+
+kernel/blk_drv/blk_drv.a:
+	(cd kernel/blk_drv; make)
+
+kernel/chr_drv/chr_drv.a:
+	(cd kernel/chr_drv; make)
+
 kernel/kernel.o:
 	(cd kernel; make)
 
@@ -59,24 +81,29 @@ fs/fs.o:
 lib/lib.a:
 	(cd lib; make)
 
-boot/boot:	boot/boot.s tools/system
+boot/setup: boot/setup.s
+	$(AS86) -o boot/setup.o boot/setup.s
+	$(LD86) -s -o boot/setup boot/setup.o
+
+boot/bootsect:	boot/bootsect.s
+	$(AS86) -o boot/bootsect.o boot/bootsect.s
+	$(LD86) -s -o boot/bootsect boot/bootsect.o
+
+tmp.s:	boot/bootsect.s tools/system
 	(echo -n "SYSSIZE = (";ls -l tools/system | grep system \
 		| cut -c25-31 | tr '\012' ' '; echo "+ 15 ) / 16") > tmp.s
-	cat boot/boot.s >> tmp.s
-	$(AS86) -o boot/boot.o tmp.s
-	rm -f tmp.s
-	$(LD86) -s -o boot/boot boot/boot.o
+	cat boot/bootsect.s >> tmp.s
 
 clean:
-	rm -f Image System.map tmp_make boot/boot core
-	rm -f init/*.o boot/*.o tools/system tools/build
+	rm -f Image System.map tmp_make core boot/bootsect boot/setup
+	rm -f init/*.o tools/system tools/build boot/*.o
 	(cd mm;make clean)
 	(cd fs;make clean)
 	(cd kernel;make clean)
 	(cd lib;make clean)
 
 backup: clean
-	(cd .. ; tar cf - linux | compress16 - > backup.Z)
+	(cd .. ; tar cf - linux | compress - > backup.Z)
 	sync
 
 dep:
@@ -92,5 +119,5 @@ init/main.o : init/main.c include/unistd.h include/sys/stat.h \
   include/sys/types.h include/sys/times.h include/sys/utsname.h \
   include/utime.h include/time.h include/linux/tty.h include/termios.h \
   include/linux/sched.h include/linux/head.h include/linux/fs.h \
-  include/linux/mm.h include/asm/system.h include/asm/io.h include/stddef.h \
-  include/stdarg.h include/fcntl.h
+  include/linux/mm.h include/signal.h include/asm/system.h include/asm/io.h \
+  include/stddef.h include/stdarg.h include/fcntl.h
diff --git a/boot/boot.s b/boot/boot.s
deleted file mode 100644
index 66eb191..0000000
--- a/boot/boot.s
+++ /dev/null
@@ -1,329 +0,0 @@
-|
-|       boot.s
-|
-| boot.s is loaded at 0x7c00 by the bios-startup routines, and moves itself
-| out of the way to address 0x90000, and jumps there.
-|
-| It then loads the system at 0x10000, using BIOS interrupts. Thereafter
-| it disables all interrupts, moves the system down to 0x0000, changes
-| to protected mode, and calls the start of system. System then must
-| RE-initialize the protected mode in it's own tables, and enable
-| interrupts as needed.
-|
-| NOTE! currently system is at most 8*65536 bytes long. This should be no
-| problem, even in the future. I want to keep it simple. This 512 kB
-| kernel size should be enough - in fact more would mean we'd have to move
-| not just these start-up routines, but also do something about the cache-
-| memory (block IO devices). The area left over in the lower 640 kB is meant
-| for these. No other memory is assumed to be "physical", ie all memory
-| over 1Mb is demand-paging. All addresses under 1Mb are guaranteed to match
-| their physical addresses.
-|
-| NOTE1 abouve is no longer valid in it's entirety. cache-memory is allocated
-| above the 1Mb mark as well as below. Otherwise it is mainly correct.
-|
-| NOTE 2! The boot disk type must be set at compile-time, by setting
-| the following equ. Having the boot-up procedure hunt for the right
-| disk type is severe brain-damage.
-| The loader has been made as simple as possible (had to, to get it
-| in 512 bytes with the code to move to protected mode), and continuos
-| read errors will result in a unbreakable loop. Reboot by hand. It
-| loads pretty fast by getting whole sectors at a time whenever possible.
-
-| 1.44Mb disks:
-sectors = 18
-| 1.2Mb disks:
-| sectors = 15
-| 720kB disks:
-| sectors = 9
-
-.globl begtext, begdata, begbss, endtext, enddata, endbss
-.text
-begtext:
-.data
-begdata:
-.bss
-begbss:
-.text
-
-BOOTSEG = 0x07c0
-INITSEG = 0x9000
-SYSSEG  = 0x1000                        | system loaded at 0x10000 (65536).
-ENDSEG  = SYSSEG + SYSSIZE
-
-entry start
-start:
-	mov	ax,#BOOTSEG
-	mov	ds,ax
-	mov	ax,#INITSEG
-	mov	es,ax
-	mov	cx,#256
-	sub	si,si
-	sub	di,di
-	rep
-	movw
-	jmpi	go,INITSEG
-go:	mov	ax,cs
-	mov	ds,ax
-	mov	es,ax
-	mov	ss,ax
-	mov	sp,#0x400               | arbitrary value >>512
-
-	mov	ah,#0x03        | read cursor pos
-	xor	bh,bh
-	int	0x10
-
-	mov	cx,#24
-	mov	bx,#0x0007      | page 0, attribute 7 (normal)
-	mov	bp,#msg1
-	mov	ax,#0x1301      | write string, move cursor
-	int	0x10
-
-| ok, we've written the message, now
-| we want to load the system (at 0x10000)
-
-	mov	ax,#SYSSEG
-	mov	es,ax           | segment of 0x010000
-	call	read_it
-	call	kill_motor
-
-| if the read went well we get current cursor position ans save it for
-| posterity.
-
-	mov	ah,#0x03        | read cursor pos
-	xor	bh,bh
-	int	0x10            | save it in known place, con_init fetches
-	mov	[510],dx        | it from 0x90510.
-
-| now we want to move to protected mode ...
-
-	cli                     | no interrupts allowed !
-
-| first we move the system to it's rightful place
-
-	mov	ax,#0x0000
-	cld                     | 'direction'=0, movs moves forward
-do_move:
-	mov	es,ax           | destination segment
-	add	ax,#0x1000
-	cmp	ax,#0x9000
-	jz	end_move
-	mov	ds,ax           | source segment
-	sub	di,di
-	sub	si,si
-	mov	cx,#0x8000
-	rep
-	movsw
-	j       do_move
-
-| then we load the segment descriptors
-
-end_move:
-
-	mov	ax,cs           | right, forgot this at first. didn't work :-)
-	mov	ds,ax
-	lidt	idt_48          | load idt with 0,0
-	lgdt	gdt_48          | load gdt with whatever appropriate
-
-| that was painless, now we enable A20
-
-	call	empty_8042
-	mov	al,#0xD1                | command write
-	out	#0x64,al
-	call	empty_8042
-	mov	al,#0xDF                | A20 on
-	out	#0x60,al
-	call	empty_8042
-
-| well, that went ok, I hope. Now we have to reprogram the interrupts :-(
-| we put them right after the intel-reserved hardware interrupts, at
-| int 0x20-0x2F. There they won't mess up anything. Sadly IBM really
-| messed this up with the original PC, and they haven't been able to
-| rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,
-| which is used for the internal hardware interrupts as well. We just
-| have to reprogram the 8259's, and it isn't fun.
-
-	mov	al,#0x11                | initialization sequence
-	out	#0x20,al                | send it to 8259A-1
-	.word	0x00eb,0x00eb           | jmp $+2, jmp $+2
-	out	#0xA0,al                | and to 8259A-2
-	.word	0x00eb,0x00eb
-	mov	al,#0x20                | start of hardware int's (0x20)
-	out	#0x21,al
-	.word	0x00eb,0x00eb
-	mov	al,#0x28                | start of hardware int's 2 (0x28)
-	out	#0xA1,al
-	.word	0x00eb,0x00eb
-	mov	al,#0x04                | 8259-1 is master
-	out	#0x21,al
-	.word	0x00eb,0x00eb
-	mov	al,#0x02                | 8259-2 is slave
-	out	#0xA1,al
-	.word	0x00eb,0x00eb
-	mov	al,#0x01                | 8086 mode for both
-	out	#0x21,al
-	.word	0x00eb,0x00eb
-	out	#0xA1,al
-	.word	0x00eb,0x00eb
-	mov	al,#0xFF                | mask off all interrupts for now
-	out	#0x21,al
-	.word	0x00eb,0x00eb
-	out	#0xA1,al
-
-| well, that certainly wasn't fun :-(. Hopefully it works, and we don't
-| need no steenking BIOS anyway (except for the initial loading :-).
-| The BIOS-routine wants lots of unnecessary data, and it's less
-| "interesting" anyway. This is how REAL programmers do it.
-|
-| Well, now's the time to actually move into protected mode. To make
-| things as simple as possible, we do no register set-up or anything,
-| we let the gnu-compiled 32-bit programs do that. We just jump to
-| absolute address 0x00000, in 32-bit protected mode.
-
-	mov	ax,#0x0001      | protected mode (PE) bit
-	lmsw	ax              | This is it!
-	jmpi	0,8             | jmp offset 0 of segment 8 (cs)
-
-| This routine checks that the keyboard command queue is empty
-| No timeout is used - if this hangs there is something wrong with
-| the machine, and we probably couldn't proceed anyway.
-empty_8042:
-	.word	0x00eb,0x00eb
-	in	al,#0x64        | 8042 status port
-	test	al,#2           | is input buffer full?
-	jnz	empty_8042      | yes - loop
-	ret
-
-| This routine loads the system at address 0x10000, making sure
-| no 64kB boundaries are crossed. We try to load it as fast as
-| possible, loading whole tracks whenever we can.
-|
-| in:   es - starting address segment (normally 0x1000)
-|
-| This routine has to be recompiled to fit another drive type,
-| just change the "sectors" variable at the start of the file
-| (originally 18, for a 1.44Mb drive)
-|
-sread:	.word 1                 | sectors read of current track
-head:	.word 0                 | current head
-track:	.word 0                 | current track
-read_it:
-	mov	ax,es
-	test	ax,#0x0fff
-die:	jne	die                 | es must be at 64kB boundary
-	xor	bx,bx               | bx is starting address within segment
-rp_read:
-	mov	ax,es
-	cmp	ax,#ENDSEG          | have we loaded all yet?
-	jb	ok1_read
-	ret
-ok1_read:
-	mov	ax,#sectors
-	sub	ax,sread
-	mov	cx,ax
-	shl	cx,#9
-	add	cx,bx
-	jnc	ok2_read
-	je	ok2_read
-	xor	ax,ax
-	sub	ax,bx
-	shr	ax,#9
-ok2_read:
-	call	read_track
-	mov	cx,ax
-	add	ax,sread
-	cmp	ax,#sectors
-	jne	ok3_read
-	mov	ax,#1
-	sub	ax,head
-	jne	ok4_read
-	inc	track
-ok4_read:
-	mov	head,ax
-	xor	ax,ax
-ok3_read:
-	mov	sread,ax
-	shl	cx,#9
-	add	bx,cx
-	jnc	rp_read
-	mov	ax,es
-	add	ax,#0x1000
-	mov	es,ax
-	xor	bx,bx
-	jmp	rp_read
-
-read_track:
-	push	ax
-	push	bx
-	push	cx
-	push	dx
-	mov	dx,track
-	mov	cx,sread
-	inc	cx
-	mov	ch,dl
-	mov	dx,head
-	mov	dh,dl
-	mov	dl,#0
-	and	dx,#0x0100
-	mov	ah,#2
-	int	0x13
-	jc	bad_rt
-	pop	dx
-	pop	cx
-	pop	bx
-	pop	ax
-	ret
-bad_rt: mov	ax,#0
-	mov	dx,#0
-	int	0x13
-	pop	dx
-	pop	cx
-	pop	bx
-	pop	ax
-	jmp	read_track
-
-/*
- * This procedure turns off the floppy drive motor, so
- * that we enter the kernel in a known state, and
- * don't have to worry about it later.
- */
-kill_motor:
-	push	dx
-	mov	dx,#0x3f2
-	mov	al,#0
-	outb
-	pop	dx
-	ret
-
-gdt:
-	.word	0,0,0,0         | dummy
-
-	.word	0x07FF          | 8Mb - limit=2047 (2048*4096=8Mb)
-	.word	0x0000          | base address=0
-	.word	0x9A00          | code read/exec
-	.word	0x00C0          | granularity=4096, 386
-
-	.word	0x07FF          | 8Mb - limit=2047 (2048*4096=8Mb)
-	.word	0x0000          | base address=0
-	.word	0x9200          | data read/write
-	.word	0x00C0          | granularity=4096, 386
-
-idt_48:
-	.word	0                       | idt limit=0
-	.word	0,0                     | idt base=0L
-
-gdt_48:
-	.word	0x800           | gdt limit=2048, 256 GDT entries
-	.word	gdt,0x9         | gdt base = 0X9xxxx
-
-msg1:
-	.byte	13,10
-	.ascii	"Loading system ..."
-	.byte	13,10,13,10
-
-.text
-endtext:
-.data
-enddata:
-.bss
-endbss:
diff --git a/boot/bootsect.s b/boot/bootsect.s
new file mode 100644
index 0000000..0d41981
--- /dev/null
+++ b/boot/bootsect.s
@@ -0,0 +1,260 @@
+!
+! SYS_SIZE is the number of clicks (16 bytes) to be loaded.
+! 0x3000 is 0x30000 bytes = 196kB, more than enough for current
+! versions of linux
+!
+SYSSIZE = 0x3000
+!
+!	bootsect.s		(C) 1991 Linus Torvalds
+!
+! bootsect.s is loaded at 0x7c00 by the bios-startup routines, and moves
+! iself out of the way to address 0x90000, and jumps there.
+!
+! It then loads 'setup' directly after itself (0x90200), and the system
+! at 0x10000, using BIOS interrupts.
+!
+! NOTE! currently system is at most 8*65536 bytes long. This should be no
+! problem, even in the future. I want to keep it simple. This 512 kB
+! kernel size should be enough, especially as this doesn't contain the
+! buffer cache as in minix
+!
+! The loader has been made as simple as possible, and continuos
+! read errors will result in a unbreakable loop. Reboot by hand. It
+! loads pretty fast by getting whole sectors at a time whenever possible.
+
+.globl begtext, begdata, begbss, endtext, enddata, endbss
+.text
+begtext:
+.data
+begdata:
+.bss
+begbss:
+.text
+
+SETUPLEN = 4				! nr of setup-sectors
+BOOTSEG  = 0x07c0			! original address of boot-sector
+INITSEG  = 0x9000			! we move boot here - out of the way
+SETUPSEG = 0x9020			! setup starts here
+SYSSEG   = 0x1000			! system loaded at 0x10000 (65536).
+ENDSEG   = SYSSEG + SYSSIZE		! where to stop loading
+
+! ROOT_DEV:	0x000 - same type of floppy as boot.
+!		0x301 - first partition on first drive etc
+ROOT_DEV = 0x306
+
+entry start
+start:
+	mov	ax,#BOOTSEG
+	mov	ds,ax
+	mov	ax,#INITSEG
+	mov	es,ax
+	mov	cx,#256
+	sub	si,si
+	sub	di,di
+	rep
+	movw
+	jmpi	go,INITSEG
+go:	mov	ax,cs
+	mov	ds,ax
+	mov	es,ax
+! put stack at 0x9ff00.
+	mov	ss,ax
+	mov	sp,#0xFF00		! arbitrary value >>512
+
+! load the setup-sectors directly after the bootblock.
+! Note that 'es' is already set up.
+
+load_setup:
+	mov	dx,#0x0000		! drive 0, head 0
+	mov	cx,#0x0002		! sector 2, track 0
+	mov	bx,#0x0200		! address = 512, in INITSEG
+	mov	ax,#0x0200+SETUPLEN	! service 2, nr of sectors
+	int	0x13			! read it
+	jnc	ok_load_setup		! ok - continue
+	mov	dx,#0x0000
+	mov	ax,#0x0000		! reset the diskette
+	int	0x13
+	j	load_setup
+
+ok_load_setup:
+
+! Get disk drive parameters, specifically nr of sectors/track
+
+	mov	dl,#0x00
+	mov	ax,#0x0800		! AH=8 is get drive parameters
+	int	0x13
+	mov	ch,#0x00
+	seg cs
+	mov	sectors,cx
+	mov	ax,#INITSEG
+	mov	es,ax
+
+! Print some inane message
+
+	mov	ah,#0x03		! read cursor pos
+	xor	bh,bh
+	int	0x10
+
+	mov	cx,#24
+	mov	bx,#0x0007		! page 0, attribute 7 (normal)
+	mov	bp,#msg1
+	mov	ax,#0x1301		! write string, move cursor
+	int	0x10
+
+! ok, we've written the message, now
+! we want to load the system (at 0x10000)
+
+	mov	ax,#SYSSEG
+	mov	es,ax		! segment of 0x010000
+	call	read_it
+	call	kill_motor
+
+! After that we check which root-device to use. If the device is
+! defined (!= 0), nothing is done and the given device is used.
+! Otherwise, either /dev/PS0 (2,28) or /dev/at0 (2,8), depending
+! on the number of sectors that the BIOS reports currently.
+
+	seg cs
+	mov	ax,root_dev
+	cmp	ax,#0
+	jne	root_defined
+	seg cs
+	mov	bx,sectors
+	mov	ax,#0x0208		! /dev/ps0 - 1.2Mb
+	cmp	bx,#15
+	je	root_defined
+	mov	ax,#0x021c		! /dev/PS0 - 1.44Mb
+	cmp	bx,#18
+	je	root_defined
+undef_root:
+	jmp	undef_root
+root_defined:
+	seg	cs
+	mov	root_dev,ax
+
+! after that (everyting loaded), we jump to
+! the setup-routine loaded directly after
+! the bootblock:
+
+	jmpi	0,SETUPSEG
+
+! This routine loads the system at address 0x10000, making sure
+! no 64kB boundaries are crossed. We try to load it as fast as
+! possible, loading whole tracks whenever we can.
+!
+! in:	es - starting address segment (normally 0x1000)
+!
+sread:	.word 1+SETUPLEN	! sectors read of current track
+head:	.word 0			! current head
+track:	.word 0			! current track
+
+read_it:
+	mov	ax,es
+	test	ax,#0x0fff
+die:	jne	die			! es must be at 64kB boundary
+	xor	bx,bx		! bx is starting address within segment
+rp_read:
+	mov	ax,es
+	cmp	ax,#ENDSEG		! have we loaded all yet?
+	jb	ok1_read
+	ret
+ok1_read:
+	seg	cs
+	mov	ax,sectors
+	sub	ax,sread
+	mov	cx,ax
+	shl	cx,#9
+	add	cx,bx
+	jnc	ok2_read
+	je	ok2_read
+	xor	ax,ax
+	sub	ax,bx
+	shr	ax,#9
+ok2_read:
+	call	read_track
+	mov	cx,ax
+	add	ax,sread
+	seg	cs
+	cmp	ax,sectors
+	jne	ok3_read
+	mov	ax,#1
+	sub	ax,head
+	jne	ok4_read
+	inc	track
+ok4_read:
+	mov	head,ax
+	xor	ax,ax
+ok3_read:
+	mov	sread,ax
+	shl	cx,#9
+	add	bx,cx
+	jnc	rp_read
+	mov	ax,es
+	add	ax,#0x1000
+	mov	es,ax
+	xor	bx,bx
+	jmp	rp_read
+
+read_track:
+	push	ax
+	push	bx
+	push	cx
+	push	dx
+	mov	dx,track
+	mov	cx,sread
+	inc	cx
+	mov	ch,dl
+	mov	dx,head
+	mov	dh,dl
+	mov	dl,#0
+	and	dx,#0x0100
+	mov	ah,#2
+	int	0x13
+	jc	bad_rt
+	pop	dx
+	pop	cx
+	pop	bx
+	pop	ax
+	ret
+bad_rt:	mov	ax,#0
+	mov	dx,#0
+	int	0x13
+	pop	dx
+	pop	cx
+	pop	bx
+	pop	ax
+	jmp	read_track
+
+/*
+ * This procedure turns off the floppy drive motor, so
+ * that we enter the kernel in a known state, and
+ * don't have to worry about it later.
+ */
+kill_motor:
+	push	dx
+	mov	dx,#0x3f2
+	mov	al,#0
+	outb
+	pop	dx
+	ret
+
+sectors:
+	.word 0
+
+msg1:
+	.byte 13,10
+	.ascii "Loading system ..."
+	.byte 13,10,13,10
+
+.org 508
+root_dev:
+	.word ROOT_DEV
+boot_flag:
+	.word 0xAA55
+
+.text
+endtext:
+.data
+enddata:
+.bss
+endbss:
diff --git a/boot/head.s b/boot/head.s
index f1debda..b8c078c 100644
--- a/boot/head.s
+++ b/boot/head.s
@@ -1,4 +1,10 @@
 /*
+ *  linux/boot/head.s
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  *  head.s contains the 32-bit startup code.
  *
  * NOTE!!! Startup happens at absolute address 0x00000000, which is also where
@@ -6,7 +12,7 @@
  * the page directory.
  */
 .text
-.globl _idt,_gdt,_pg_dir
+.globl _idt,_gdt,_pg_dir,_tmp_floppy_area
 _pg_dir:
 startup_32:
 	movl	$0x10,%eax
@@ -25,18 +31,40 @@ startup_32:
 	lss	_stack_start,%esp
 	xorl	%eax,%eax
 1:	incl	%eax		# check that A20 really IS enabled
-	movl	%eax,0x000000
+	movl	%eax,0x000000	# loop forever if it isn't
 	cmpl	%eax,0x100000
 	je	1b
+/*
+ * NOTE! 486 should set bit 16, to check for write-protect in supervisor
+ * mode. Then it would be unnecessary with the "verify_area()"-calls.
+ * 486 users probably want to set the NE (#5) bit also, so as to use
+ * int 16 for math errors.
+ */
 	movl	%cr0,%eax		# check math chip
-	andl	$0x80000011,%eax	# Save PG,ET,PE
-	testl	$0x10,%eax
-	jne	1f		# ET is set - 387 is present
-	orl	$4,%eax		# else set emulate bit
-1:	movl	%eax,%cr0
+	andl	$0x80000011,%eax	# Save PG,PE,ET
+/* "orl $0x10020,%eax" here for 486 might be good */
+	orl 	$2,%eax		# set MP
+	movl	%eax,%cr0
+	call	check_x87
 	jmp	after_page_tables
 
 /*
+ * We depend on ET to be correct. This checks for 287/387.
+ */
+check_x87:
+	fninit
+	fstsw	%ax
+	cmpb	$0,%al
+	je	1f		/* no coprocessor: have to set bits */
+	movl	%cr0,%eax
+	xorl	$6,%eax		/* reset MP, set EM */
+	movl	%eax,%cr0
+	ret
+.align 2
+1:	.byte 0xDB,0xE4		/* fsetpm for 287, ignored by 387 */
+	ret
+
+/*
  *  setup_idt
  *
  *  sets up a idt with 256 entries pointing to
@@ -78,6 +106,11 @@ setup_gdt:
 	lgdt	gdt_descr
 	ret
 
+/*
+ * I put the kernel page tables right after the page directory,
+ * using 4 of them to span 16 Mb of physical memory. People with
+ * more than 16MB will have to expand this.
+ */
 .org 0x1000
 pg0:
 
@@ -85,11 +118,20 @@ pg0:
 pg1:
 
 .org 0x3000
-pg2:		# This is not used yet, but if you
-		# want to expand past 8 Mb, you'll have
-		# to use it.
+pg2:
 
 .org 0x4000
+pg3:
+
+.org 0x5000
+/*
+ * tmp_floppy_area is used by the floppy-driver when DMA cannot
+ * reach to a buffer-block. It needs to be aligned, so that it isn't
+ * on a 64kB border.
+ */
+_tmp_floppy_area:
+	.fill 1024,1,0
+
 after_page_tables:
 	pushl	$0		# These are the parameters to main :-)
 	pushl	$0
@@ -102,11 +144,30 @@ L6:
 				# just in case, we know what happens.
 
 /* This is the default interrupt "handler" :-) */
+int_msg:
+	.asciz "Unknown interrupt\n\r"
 .align 2
 ignore_int:
-	incb	0xb8000+160		# put something on the screen
-	movb	$2,0xb8000+161		# so that we know something
-	iret				# happened
+	pushl	%eax
+	pushl	%ecx
+	pushl	%edx
+	push	%ds
+	push	%es
+	push	%fs
+	movl	$0x10,%eax
+	mov	%ax,%ds
+	mov	%ax,%es
+	mov	%ax,%fs
+	pushl	$int_msg
+	call	_printk
+	popl	%eax
+	pop	%fs
+	pop	%es
+	pop	%ds
+	popl	%edx
+	popl	%ecx
+	popl	%eax
+	iret
 
 
 /*
@@ -114,7 +175,7 @@ ignore_int:
  *
  * This routine sets up paging by setting the page bit
  * in cr0. The page tables are set up, identity-mapping
- * the first 8MB. The pager assumes that no illegal
+ * the first 16MB. The pager assumes that no illegal
  * addresses are produced (ie >4Mb on a 4Mb machine).
  *
  * NOTE! Although all physical memory should be identity
@@ -124,25 +185,27 @@ ignore_int:
  * will be mapped to some other place - mm keeps track of
  * that.
  *
- * For those with more memory than 8 Mb - tough luck. I've
+ * For those with more memory than 16 Mb - tough luck. I've
  * not got it, why should you :-) The source is here. Change
  * it. (Seriously - it shouldn't be too difficult. Mostly
- * change some constants etc. I left it at 8Mb, as my machine
+ * change some constants etc. I left it at 16Mb, as my machine
  * even cannot be extended past that (ok, but it was cheap :-)
  * I've tried to show which constants to change by having
- * some kind of marker at them (search for "8Mb"), but I
+ * some kind of marker at them (search for "16Mb"), but I
  * won't guarantee that's all :-( )
  */
 .align 2
 setup_paging:
-	movl	$1024*3,%ecx
+	movl	$1024*5,%ecx		/* 5 pages - pg_dir+4 page tables */
 	xorl	%eax,%eax
 	xorl	%edi,%edi		/* pg_dir is at 0x000 */
 	cld;rep;stosl
 	movl	$pg0+7,_pg_dir		/* set present bit/user r/w */
 	movl	$pg1+7,_pg_dir+4	/*  --------- " " --------- */
-	movl	$pg1+4092,%edi
-	movl	$0x7ff007,%eax		/*  8Mb - 4096 + 7 (r/w user,p) */
+	movl	$pg2+7,_pg_dir+8	/*  --------- " " --------- */
+	movl	$pg3+7,_pg_dir+12	/*  --------- " " --------- */
+	movl	$pg3+4092,%edi
+	movl	$0xfff007,%eax		/*  16Mb - 4096 + 7 (r/w user,p) */
 	std
 1:	stosl				/* fill pages backwards - more efficient :-) */
 	subl	$0x1000,%eax
@@ -169,7 +232,7 @@ gdt_descr:
 _idt:	.fill	256,8,0		# idt is uninitialized
 
 _gdt:	.quad	0x0000000000000000	/* NULL descriptor */
-	.quad	0x00c09a00000007ff	/* 8Mb */
-	.quad	0x00c09200000007ff	/* 8Mb */
+	.quad	0x00c09a0000000fff	/* 16Mb */
+	.quad	0x00c0920000000fff	/* 16Mb */
 	.quad	0x0000000000000000	/* TEMPORARY - don't use */
 	.fill	252,8,0			/* space for LDT's and TSS's etc */
diff --git a/boot/setup.s b/boot/setup.s
new file mode 100644
index 0000000..4b80791
--- /dev/null
+++ b/boot/setup.s
@@ -0,0 +1,231 @@
+!
+!	setup.s		(C) 1991 Linus Torvalds
+!
+! setup.s is responsible for getting the system data from the BIOS,
+! and putting them into the appropriate places in system memory.
+! both setup.s and system has been loaded by the bootblock.
+!
+! This code asks the bios for memory/disk/other parameters, and
+! puts them in a "safe" place: 0x90000-0x901FF, ie where the
+! boot-block used to be. It is then up to the protected mode
+! system to read them from there before the area is overwritten
+! for buffer-blocks.
+!
+
+! NOTE! These had better be the same as in bootsect.s!
+
+INITSEG  = 0x9000	! we move boot here - out of the way
+SYSSEG   = 0x1000	! system loaded at 0x10000 (65536).
+SETUPSEG = 0x9020	! this is the current segment
+
+.globl begtext, begdata, begbss, endtext, enddata, endbss
+.text
+begtext:
+.data
+begdata:
+.bss
+begbss:
+.text
+
+entry start
+start:
+
+! ok, the read went well so we get current cursor position and save it for
+! posterity.
+
+	mov	ax,#INITSEG	! this is done in bootsect already, but...
+	mov	ds,ax
+	mov	ah,#0x03	! read cursor pos
+	xor	bh,bh
+	int	0x10		! save it in known place, con_init fetches
+	mov	[0],dx		! it from 0x90000.
+
+! Get memory size (extended mem, kB)
+
+	mov	ah,#0x88
+	int	0x15
+	mov	[2],ax
+
+! Get video-card data:
+
+	mov	ah,#0x0f
+	int	0x10
+	mov	[4],bx		! bh = display page
+	mov	[6],ax		! al = video mode, ah = window width
+
+! check for EGA/VGA and some config parameters
+
+	mov	ah,#0x12
+	mov	bl,#0x10
+	int	0x10
+	mov	[8],ax
+	mov	[10],bx
+	mov	[12],cx
+
+! Get hd0 data
+
+	mov	ax,#0x0000
+	mov	ds,ax
+	lds	si,[4*0x41]
+	mov	ax,#INITSEG
+	mov	es,ax
+	mov	di,#0x0080
+	mov	cx,#0x10
+	rep
+	movsb
+
+! Get hd1 data
+
+	mov	ax,#0x0000
+	mov	ds,ax
+	lds	si,[4*0x46]
+	mov	ax,#INITSEG
+	mov	es,ax
+	mov	di,#0x0090
+	mov	cx,#0x10
+	rep
+	movsb
+
+! Check that there IS a hd1 :-)
+
+	mov	ax,#0x01500
+	mov	dl,#0x81
+	int	0x13
+	jc	no_disk1
+	cmp	ah,#3
+	je	is_disk1
+no_disk1:
+	mov	ax,#INITSEG
+	mov	es,ax
+	mov	di,#0x0090
+	mov	cx,#0x10
+	mov	ax,#0x00
+	rep
+	stosb
+is_disk1:
+
+! now we want to move to protected mode ...
+
+	cli			! no interrupts allowed !
+
+! first we move the system to it's rightful place
+
+	mov	ax,#0x0000
+	cld			! 'direction'=0, movs moves forward
+do_move:
+	mov	es,ax		! destination segment
+	add	ax,#0x1000
+	cmp	ax,#0x9000
+	jz	end_move
+	mov	ds,ax		! source segment
+	sub	di,di
+	sub	si,si
+	mov 	cx,#0x8000
+	rep
+	movsw
+	jmp	do_move
+
+! then we load the segment descriptors
+
+end_move:
+	mov	ax,#SETUPSEG	! right, forgot this at first. didn't work :-)
+	mov	ds,ax
+	lidt	idt_48		! load idt with 0,0
+	lgdt	gdt_48		! load gdt with whatever appropriate
+
+! that was painless, now we enable A20
+
+	call	empty_8042
+	mov	al,#0xD1		! command write
+	out	#0x64,al
+	call	empty_8042
+	mov	al,#0xDF		! A20 on
+	out	#0x60,al
+	call	empty_8042
+
+! well, that went ok, I hope. Now we have to reprogram the interrupts :-(
+! we put them right after the intel-reserved hardware interrupts, at
+! int 0x20-0x2F. There they won't mess up anything. Sadly IBM really
+! messed this up with the original PC, and they haven't been able to
+! rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,
+! which is used for the internal hardware interrupts as well. We just
+! have to reprogram the 8259's, and it isn't fun.
+
+	mov	al,#0x11		! initialization sequence
+	out	#0x20,al		! send it to 8259A-1
+	.word	0x00eb,0x00eb		! jmp $+2, jmp $+2
+	out	#0xA0,al		! and to 8259A-2
+	.word	0x00eb,0x00eb
+	mov	al,#0x20		! start of hardware int's (0x20)
+	out	#0x21,al
+	.word	0x00eb,0x00eb
+	mov	al,#0x28		! start of hardware int's 2 (0x28)
+	out	#0xA1,al
+	.word	0x00eb,0x00eb
+	mov	al,#0x04		! 8259-1 is master
+	out	#0x21,al
+	.word	0x00eb,0x00eb
+	mov	al,#0x02		! 8259-2 is slave
+	out	#0xA1,al
+	.word	0x00eb,0x00eb
+	mov	al,#0x01		! 8086 mode for both
+	out	#0x21,al
+	.word	0x00eb,0x00eb
+	out	#0xA1,al
+	.word	0x00eb,0x00eb
+	mov	al,#0xFF		! mask off all interrupts for now
+	out	#0x21,al
+	.word	0x00eb,0x00eb
+	out	#0xA1,al
+
+! well, that certainly wasn't fun :-(. Hopefully it works, and we don't
+! need no steenking BIOS anyway (except for the initial loading :-).
+! The BIOS-routine wants lots of unnecessary data, and it's less
+! "interesting" anyway. This is how REAL programmers do it.
+!
+! Well, now's the time to actually move into protected mode. To make
+! things as simple as possible, we do no register set-up or anything,
+! we let the gnu-compiled 32-bit programs do that. We just jump to
+! absolute address 0x00000, in 32-bit protected mode.
+
+	mov	ax,#0x0001	! protected mode (PE) bit
+	lmsw	ax		! This is it!
+	jmpi	0,8		! jmp offset 0 of segment 8 (cs)
+
+! This routine checks that the keyboard command queue is empty
+! No timeout is used - if this hangs there is something wrong with
+! the machine, and we probably couldn't proceed anyway.
+empty_8042:
+	.word	0x00eb,0x00eb
+	in	al,#0x64	! 8042 status port
+	test	al,#2		! is input buffer full?
+	jnz	empty_8042	! yes - loop
+	ret
+
+gdt:
+	.word	0,0,0,0		! dummy
+
+	.word	0x07FF		! 8Mb - limit=2047 (2048*4096=8Mb)
+	.word	0x0000		! base address=0
+	.word	0x9A00		! code read/exec
+	.word	0x00C0		! granularity=4096, 386
+
+	.word	0x07FF		! 8Mb - limit=2047 (2048*4096=8Mb)
+	.word	0x0000		! base address=0
+	.word	0x9200		! data read/write
+	.word	0x00C0		! granularity=4096, 386
+
+idt_48:
+	.word	0			! idt limit=0
+	.word	0,0			! idt base=0L
+
+gdt_48:
+	.word	0x800		! gdt limit=2048, 256 GDT entries
+	.word	512+gdt,0x9	! gdt base = 0X9xxxx
+
+.text
+endtext:
+.data
+enddata:
+.bss
+endbss:
diff --git a/fs/Makefile b/fs/Makefile
index 661fde5..5f20177 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -34,62 +34,67 @@ dep:
 ### Dependencies:
 bitmap.o : bitmap.c ../include/string.h ../include/linux/sched.h \
   ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/kernel.h
-block_dev.o : block_dev.c ../include/errno.h ../include/linux/fs.h \
-  ../include/sys/types.h ../include/linux/kernel.h ../include/asm/segment.h
-buffer.o : buffer.c ../include/linux/config.h ../include/linux/sched.h \
+  ../include/linux/mm.h ../include/signal.h ../include/linux/kernel.h
+block_dev.o : block_dev.c ../include/errno.h ../include/linux/sched.h \
   ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/kernel.h ../include/asm/system.h
-char_dev.o : char_dev.c ../include/errno.h ../include/linux/sched.h \
-  ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/kernel.h
-exec.o : exec.c ../include/errno.h ../include/sys/stat.h \
-  ../include/sys/types.h ../include/a.out.h ../include/linux/fs.h \
-  ../include/linux/sched.h ../include/linux/head.h ../include/linux/mm.h \
-  ../include/linux/kernel.h ../include/asm/segment.h
+  ../include/linux/mm.h ../include/signal.h ../include/linux/kernel.h \
+  ../include/asm/segment.h ../include/asm/system.h
+buffer.o : buffer.c ../include/stdarg.h ../include/linux/config.h \
+  ../include/linux/sched.h ../include/linux/head.h ../include/linux/fs.h \
+  ../include/sys/types.h ../include/linux/mm.h ../include/signal.h \
+  ../include/linux/kernel.h ../include/asm/system.h ../include/asm/io.h
+char_dev.o : char_dev.c ../include/errno.h ../include/sys/types.h \
+  ../include/linux/sched.h ../include/linux/head.h ../include/linux/fs.h \
+  ../include/linux/mm.h ../include/signal.h ../include/linux/kernel.h \
+  ../include/asm/segment.h ../include/asm/io.h
+exec.o : exec.c ../include/errno.h ../include/string.h \
+  ../include/sys/stat.h ../include/sys/types.h ../include/a.out.h \
+  ../include/linux/fs.h ../include/linux/sched.h ../include/linux/head.h \
+  ../include/linux/mm.h ../include/signal.h ../include/linux/kernel.h \
+  ../include/asm/segment.h
 fcntl.o : fcntl.c ../include/string.h ../include/errno.h \
   ../include/linux/sched.h ../include/linux/head.h ../include/linux/fs.h \
-  ../include/sys/types.h ../include/linux/mm.h ../include/linux/kernel.h \
-  ../include/asm/segment.h ../include/fcntl.h ../include/sys/stat.h
+  ../include/sys/types.h ../include/linux/mm.h ../include/signal.h \
+  ../include/linux/kernel.h ../include/asm/segment.h ../include/fcntl.h \
+  ../include/sys/stat.h
 file_dev.o : file_dev.c ../include/errno.h ../include/fcntl.h \
   ../include/sys/types.h ../include/linux/sched.h ../include/linux/head.h \
-  ../include/linux/fs.h ../include/linux/mm.h ../include/linux/kernel.h \
-  ../include/asm/segment.h
+  ../include/linux/fs.h ../include/linux/mm.h ../include/signal.h \
+  ../include/linux/kernel.h ../include/asm/segment.h
 file_table.o : file_table.c ../include/linux/fs.h ../include/sys/types.h
-inode.o : inode.c ../include/string.h ../include/linux/sched.h \
-  ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/kernel.h ../include/asm/system.h
+inode.o : inode.c ../include/string.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/linux/sched.h ../include/linux/head.h \
+  ../include/linux/fs.h ../include/linux/mm.h ../include/signal.h \
+  ../include/linux/kernel.h ../include/asm/system.h
 ioctl.o : ioctl.c ../include/string.h ../include/errno.h \
   ../include/sys/stat.h ../include/sys/types.h ../include/linux/sched.h \
-  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h
+  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \
+  ../include/signal.h
 namei.o : namei.c ../include/linux/sched.h ../include/linux/head.h \
   ../include/linux/fs.h ../include/sys/types.h ../include/linux/mm.h \
-  ../include/linux/kernel.h ../include/asm/segment.h ../include/string.h \
-  ../include/fcntl.h ../include/errno.h ../include/const.h \
-  ../include/sys/stat.h
+  ../include/signal.h ../include/linux/kernel.h ../include/asm/segment.h \
+  ../include/string.h ../include/fcntl.h ../include/errno.h \
+  ../include/const.h ../include/sys/stat.h
 open.o : open.c ../include/string.h ../include/errno.h ../include/fcntl.h \
   ../include/sys/types.h ../include/utime.h ../include/sys/stat.h \
   ../include/linux/sched.h ../include/linux/head.h ../include/linux/fs.h \
-  ../include/linux/mm.h ../include/linux/tty.h ../include/termios.h \
-  ../include/linux/kernel.h ../include/asm/segment.h
+  ../include/linux/mm.h ../include/signal.h ../include/linux/tty.h \
+  ../include/termios.h ../include/linux/kernel.h ../include/asm/segment.h
 pipe.o : pipe.c ../include/signal.h ../include/sys/types.h \
   ../include/linux/sched.h ../include/linux/head.h ../include/linux/fs.h \
   ../include/linux/mm.h ../include/asm/segment.h
 read_write.o : read_write.c ../include/sys/stat.h ../include/sys/types.h \
   ../include/errno.h ../include/linux/kernel.h ../include/linux/sched.h \
   ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \
-  ../include/asm/segment.h
+  ../include/signal.h ../include/asm/segment.h
 stat.o : stat.c ../include/errno.h ../include/sys/stat.h \
   ../include/sys/types.h ../include/linux/fs.h ../include/linux/sched.h \
-  ../include/linux/head.h ../include/linux/mm.h ../include/linux/kernel.h \
-  ../include/asm/segment.h
+  ../include/linux/head.h ../include/linux/mm.h ../include/signal.h \
+  ../include/linux/kernel.h ../include/asm/segment.h
 super.o : super.c ../include/linux/config.h ../include/linux/sched.h \
   ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/kernel.h
+  ../include/linux/mm.h ../include/signal.h ../include/linux/kernel.h \
+  ../include/asm/system.h ../include/errno.h ../include/sys/stat.h
 truncate.o : truncate.c ../include/linux/sched.h ../include/linux/head.h \
   ../include/linux/fs.h ../include/sys/types.h ../include/linux/mm.h \
-  ../include/sys/stat.h
-tty_ioctl.o : tty_ioctl.c ../include/errno.h ../include/termios.h \
-  ../include/linux/sched.h ../include/linux/head.h ../include/linux/fs.h \
-  ../include/sys/types.h ../include/linux/mm.h ../include/linux/kernel.h \
-  ../include/linux/tty.h ../include/asm/segment.h ../include/asm/system.h
+  ../include/signal.h ../include/sys/stat.h
diff --git a/fs/bitmap.c b/fs/bitmap.c
index b706abf..a3fc362 100644
--- a/fs/bitmap.c
+++ b/fs/bitmap.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/bitmap.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 /* bitmap.c contains the code that handles the inode and block bitmaps */
 #include <string.h>
 
@@ -12,12 +18,14 @@ __asm__("cld\n\t" \
 
 #define set_bit(nr,addr) ({\
 register int res __asm__("ax"); \
-__asm__("btsl %2,%3\n\tsetb %%al":"=a" (res):"" (0),"r" (nr),"m" (*(addr))); \
+__asm__ __volatile__("btsl %2,%3\n\tsetb %%al": \
+"=a" (res):"0" (0),"r" (nr),"m" (*(addr))); \
 res;})
 
 #define clear_bit(nr,addr) ({\
 register int res __asm__("ax"); \
-__asm__("btrl %2,%3\n\tsetnb %%al":"=a" (res):"" (0),"r" (nr),"m" (*(addr))); \
+__asm__ __volatile__("btrl %2,%3\n\tsetnb %%al": \
+"=a" (res):"0" (0),"r" (nr),"m" (*(addr))); \
 res;})
 
 #define find_first_zero(addr) ({ \
diff --git a/fs/block_dev.c b/fs/block_dev.c
index 7bbae6a..a50ae3f 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -1,28 +1,38 @@
+/*
+ *  linux/fs/block_dev.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <errno.h>
 
-#include <linux/fs.h>
+#include <linux/sched.h>
 #include <linux/kernel.h>
 #include <asm/segment.h>
-
-#define NR_BLK_DEV ((sizeof (rd_blk))/(sizeof (rd_blk[0])))
+#include <asm/system.h>
 
 int block_write(int dev, long * pos, char * buf, int count)
 {
-	int block = *pos / BLOCK_SIZE;
-	int offset = *pos % BLOCK_SIZE;
+	int block = *pos >> BLOCK_SIZE_BITS;
+	int offset = *pos & (BLOCK_SIZE-1);
 	int chars;
 	int written = 0;
 	struct buffer_head * bh;
 	register char * p;
 
 	while (count>0) {
-		bh = bread(dev,block);
+		chars = BLOCK_SIZE - offset;
+		if (chars > count)
+			chars=count;
+		if (chars == BLOCK_SIZE)
+			bh = getblk(dev,block);
+		else
+			bh = breada(dev,block,block+1,block+2,-1);
+		block++;
 		if (!bh)
 			return written?written:-EIO;
-		chars = (count<BLOCK_SIZE) ? count : BLOCK_SIZE;
 		p = offset + bh->b_data;
 		offset = 0;
-		block++;
 		*pos += chars;
 		written += chars;
 		count -= chars;
@@ -36,51 +46,28 @@ int block_write(int dev, long * pos, char * buf, int count)
 
 int block_read(int dev, unsigned long * pos, char * buf, int count)
 {
-	int block = *pos / BLOCK_SIZE;
-	int offset = *pos % BLOCK_SIZE;
+	int block = *pos >> BLOCK_SIZE_BITS;
+	int offset = *pos & (BLOCK_SIZE-1);
 	int chars;
 	int read = 0;
 	struct buffer_head * bh;
 	register char * p;
 
 	while (count>0) {
-		bh = bread(dev,block);
-		if (!bh)
+		chars = BLOCK_SIZE-offset;
+		if (chars > count)
+			chars = count;
+		if (!(bh = breada(dev,block,block+1,block+2,-1)))
 			return read?read:-EIO;
-		chars = (count<BLOCK_SIZE) ? count : BLOCK_SIZE;
+		block++;
 		p = offset + bh->b_data;
 		offset = 0;
-		block++;
 		*pos += chars;
 		read += chars;
 		count -= chars;
 		while (chars-->0)
 			put_fs_byte(*(p++),buf++);
-		bh->b_dirt = 1;
 		brelse(bh);
 	}
 	return read;
 }
-
-extern void rw_hd(int rw, struct buffer_head * bh);
-
-typedef void (*blk_fn)(int rw, struct buffer_head * bh);
-
-static blk_fn rd_blk[]={
-	NULL,		/* nodev */
-	NULL,		/* dev mem */
-	NULL,		/* dev fd */
-	rw_hd,		/* dev hd */
-	NULL,		/* dev ttyx */
-	NULL,		/* dev tty */
-	NULL};		/* dev lp */
-
-void ll_rw_block(int rw, struct buffer_head * bh)
-{
-	blk_fn blk_addr;
-	unsigned int major;
-
-	if ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV || !(blk_addr=rd_blk[major]))
-		panic("Trying to read nonexistent block-device");
-	blk_addr(rw, bh);
-}
diff --git a/fs/buffer.c b/fs/buffer.c
index 1f035fe..caf232e 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -1,4 +1,10 @@
 /*
+ *  linux/fs/buffer.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  *  'buffer.c' implements the buffer-cache functions. Race-conditions have
  * been avoided by NEVER letting a interrupt change a buffer (except for the
  * data, of course), but instead letting the caller do it. NOTE! As interrupts
@@ -6,18 +12,19 @@
  * sleep-on-calls. These should be extremely quick, though (I hope).
  */
 
+/*
+ * NOTE! There is one discordant note here: checking floppies for
+ * disk change. This is where it fits best, I think, as it should
+ * invalidate changed floppy-disk-caches.
+ */
+
+#include <stdarg.h>
+
 #include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
 #include <asm/system.h>
-
-#if (BUFFER_END & 0xfff)
-#error "Bad BUFFER_END value"
-#endif
-
-#if (BUFFER_END > 0xA0000 && BUFFER_END <= 0x100000)
-#error "Bad BUFFER_END value"
-#endif
+#include <asm/io.h>
 
 extern int end;
 struct buffer_head * start_buffer = (struct buffer_head *) &end;
@@ -49,7 +56,7 @@ int sys_sync(void)
 	return 0;
 }
 
-static int sync_dev(int dev)
+int sync_dev(int dev)
 {
 	int i;
 	struct buffer_head * bh;
@@ -59,12 +66,65 @@ static int sync_dev(int dev)
 		if (bh->b_dev != dev)
 			continue;
 		wait_on_buffer(bh);
-		if (bh->b_dirt)
+		if (bh->b_dev == dev && bh->b_dirt)
+			ll_rw_block(WRITE,bh);
+	}
+	sync_inodes();
+	bh = start_buffer;
+	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
+		if (bh->b_dev != dev)
+			continue;
+		wait_on_buffer(bh);
+		if (bh->b_dev == dev && bh->b_dirt)
 			ll_rw_block(WRITE,bh);
 	}
 	return 0;
 }
 
+void inline invalidate_buffers(int dev)
+{
+	int i;
+	struct buffer_head * bh;
+
+	bh = start_buffer;
+	for (i=0 ; i<NR_BUFFERS ; i++,bh++) {
+		if (bh->b_dev != dev)
+			continue;
+		wait_on_buffer(bh);
+		if (bh->b_dev == dev)
+			bh->b_uptodate = bh->b_dirt = 0;
+	}
+}
+
+/*
+ * This routine checks whether a floppy has been changed, and
+ * invalidates all buffer-cache-entries in that case. This
+ * is a relatively slow routine, so we have to try to minimize using
+ * it. Thus it is called only upon a 'mount' or 'open'. This
+ * is the best way of combining speed and utility, I think.
+ * People changing diskettes in the middle of an operation deserve
+ * to loose :-)
+ *
+ * NOTE! Although currently this is only for floppies, the idea is
+ * that any additional removable block-device will use this routine,
+ * and that mount/open needn't know that floppies/whatever are
+ * special.
+ */
+void check_disk_change(int dev)
+{
+	int i;
+
+	if (MAJOR(dev) != 2)
+		return;
+	if (!floppy_change(dev & 0x03))
+		return;
+	for (i=0 ; i<NR_SUPER ; i++)
+		if (super_block[i].s_dev == dev)
+			put_super(super_block[i].s_dev);
+	invalidate_inodes(dev);
+	invalidate_buffers(dev);
+}
+
 #define _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)
 #define hash(dev,block) hash_table[_hashfn(dev,block)]
 
@@ -124,73 +184,70 @@ struct buffer_head * get_hash_table(int dev, int block)
 {
 	struct buffer_head * bh;
 
-repeat:
-	if (!(bh=find_buffer(dev,block)))
-		return NULL;
-	bh->b_count++;
-	wait_on_buffer(bh);
-	if (bh->b_dev != dev || bh->b_blocknr != block) {
-		brelse(bh);
-		goto repeat;
+	for (;;) {
+		if (!(bh=find_buffer(dev,block)))
+			return NULL;
+		bh->b_count++;
+		wait_on_buffer(bh);
+		if (bh->b_dev == dev && bh->b_blocknr == block)
+			return bh;
+		bh->b_count--;
 	}
-	return bh;
 }
 
 /*
  * Ok, this is getblk, and it isn't very clear, again to hinder
  * race-conditions. Most of the code is seldom used, (ie repeating),
  * so it should be much more efficient than it looks.
+ *
+ * The algoritm is changed: hopefully better, and an elusive bug removed.
  */
+#define BADNESS(bh) (((bh)->b_dirt<<1)+(bh)->b_lock)
 struct buffer_head * getblk(int dev,int block)
 {
-	struct buffer_head * tmp;
+	struct buffer_head * tmp, * bh;
 
 repeat:
-	if (tmp=get_hash_table(dev,block))
-		return tmp;
+	if (bh = get_hash_table(dev,block))
+		return bh;
 	tmp = free_list;
 	do {
-		if (!tmp->b_count) {
-			wait_on_buffer(tmp);    /* we still have to wait */
-			if (!tmp->b_count)      /* on it, it might be dirty */
+		if (tmp->b_count)
+			continue;
+		if (!bh || BADNESS(tmp)<BADNESS(bh)) {
+			bh = tmp;
+			if (!BADNESS(tmp))
 				break;
 		}
-		tmp = tmp->b_next_free;
-	} while (tmp != free_list || (tmp=NULL));
-	/* Kids, don't try THIS at home ^^^^^. Magic */
-	if (!tmp) {
-		printk("Sleeping on free buffer ..");
+/* and repeat until we find something good */
+	} while ((tmp = tmp->b_next_free) != free_list);
+	if (!bh) {
 		sleep_on(&buffer_wait);
-		printk("ok\n");
 		goto repeat;
 	}
-	tmp->b_count++;
-	remove_from_queues(tmp);
-/*
-* Now, when we know nobody can get to this node (as it's removed from the
-* free list), we write it out. We can sleep here without fear of race-
-* conditions.
-*/
-	if (tmp->b_dirt)
-		sync_dev(tmp->b_dev);
-/* update buffer contents */
-	tmp->b_dev=dev;
-	tmp->b_blocknr=block;
-	tmp->b_dirt=0;
-	tmp->b_uptodate=0;
-/* NOTE!! While we possibly slept in sync_dev(), somebody else might have
-* added "this" block already, so check for that. Thank God for goto's.
-*/
-	if (find_buffer(dev,block)) {
-		tmp->b_dev=0;           /* ok, someone else has beaten us */
-		tmp->b_blocknr=0;       /* to it - free this block and */
-		tmp->b_count=0;         /* try again */
-		insert_into_queues(tmp);
+	wait_on_buffer(bh);
+	if (bh->b_count)
 		goto repeat;
+	while (bh->b_dirt) {
+		sync_dev(bh->b_dev);
+		wait_on_buffer(bh);
+		if (bh->b_count)
+			goto repeat;
 	}
-/* and then insert into correct position */
-	insert_into_queues(tmp);
-	return tmp;
+/* NOTE!! While we slept waiting for this block, somebody else might */
+/* already have added "this" block to the cache. check it */
+	if (find_buffer(dev,block))
+		goto repeat;
+/* OK, FINALLY we know that this buffer is the only one of it's kind, */
+/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
+	bh->b_count=1;
+	bh->b_dirt=0;
+	bh->b_uptodate=0;
+	remove_from_queues(bh);
+	bh->b_dev=dev;
+	bh->b_blocknr=block;
+	insert_into_queues(bh);
+	return bh;
 }
 
 void brelse(struct buffer_head * buf)
@@ -216,18 +273,88 @@ struct buffer_head * bread(int dev,int block)
 	if (bh->b_uptodate)
 		return bh;
 	ll_rw_block(READ,bh);
+	wait_on_buffer(bh);
+	if (bh->b_uptodate)
+		return bh;
+	brelse(bh);
+	return NULL;
+}
+
+#define COPYBLK(from,to) \
+__asm__("cld\n\t" \
+	"rep\n\t" \
+	"movsl\n\t" \
+	::"c" (BLOCK_SIZE/4),"S" (from),"D" (to) \
+	:"cx","di","si")
+
+/*
+ * bread_page reads four buffers into memory at the desired address. It's
+ * a function of its own, as there is some speed to be got by reading them
+ * all at the same time, not waiting for one to be read, and then another
+ * etc.
+ */
+void bread_page(unsigned long address,int dev,int b[4])
+{
+	struct buffer_head * bh[4];
+	int i;
+
+	for (i=0 ; i<4 ; i++)
+		if (b[i]) {
+			if (bh[i] = getblk(dev,b[i]))
+				if (!bh[i]->b_uptodate)
+					ll_rw_block(READ,bh[i]);
+		} else
+			bh[i] = NULL;
+	for (i=0 ; i<4 ; i++,address += BLOCK_SIZE)
+		if (bh[i]) {
+			wait_on_buffer(bh[i]);
+			if (bh[i]->b_uptodate)
+				COPYBLK((unsigned long) bh[i]->b_data,address);
+			brelse(bh[i]);
+		}
+}
+
+/*
+ * Ok, breada can be used as bread, but additionally to mark other
+ * blocks for reading as well. End the argument list with a negative
+ * number.
+ */
+struct buffer_head * breada(int dev,int first, ...)
+{
+	va_list args;
+	struct buffer_head * bh, *tmp;
+
+	va_start(args,first);
+	if (!(bh=getblk(dev,first)))
+		panic("bread: getblk returned NULL\n");
+	if (!bh->b_uptodate)
+		ll_rw_block(READ,bh);
+	while ((first=va_arg(args,int))>=0) {
+		tmp=getblk(dev,first);
+		if (tmp) {
+			if (!tmp->b_uptodate)
+				ll_rw_block(READA,bh);
+			tmp->b_count--;
+		}
+	}
+	va_end(args);
+	wait_on_buffer(bh);
 	if (bh->b_uptodate)
 		return bh;
 	brelse(bh);
 	return (NULL);
 }
 
-void buffer_init(void)
+void buffer_init(long buffer_end)
 {
 	struct buffer_head * h = start_buffer;
-	void * b = (void *) BUFFER_END;
+	void * b;
 	int i;
 
+	if (buffer_end == 1<<20)
+		b = (void *) (640*1024);
+	else
+		b = (void *) buffer_end;
 	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {
 		h->b_dev = 0;
 		h->b_dirt = 0;
diff --git a/fs/char_dev.c b/fs/char_dev.c
index e974242..7b07cc9 100644
--- a/fs/char_dev.c
+++ b/fs/char_dev.c
@@ -1,21 +1,90 @@
+/*
+ *  linux/fs/char_dev.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <errno.h>
+#include <sys/types.h>
 
 #include <linux/sched.h>
 #include <linux/kernel.h>
 
+#include <asm/segment.h>
+#include <asm/io.h>
+
 extern int tty_read(unsigned minor,char * buf,int count);
 extern int tty_write(unsigned minor,char * buf,int count);
 
-static int rw_ttyx(int rw,unsigned minor,char * buf,int count);
-static int rw_tty(int rw,unsigned minor,char * buf,int count);
+typedef (*crw_ptr)(int rw,unsigned minor,char * buf,int count,off_t * pos);
+
+static int rw_ttyx(int rw,unsigned minor,char * buf,int count,off_t * pos)
+{
+	return ((rw==READ)?tty_read(minor,buf,count):
+		tty_write(minor,buf,count));
+}
+
+static int rw_tty(int rw,unsigned minor,char * buf,int count, off_t * pos)
+{
+	if (current->tty<0)
+		return -EPERM;
+	return rw_ttyx(rw,current->tty,buf,count,pos);
+}
+
+static int rw_ram(int rw,char * buf, int count, off_t *pos)
+{
+	return -EIO;
+}
+
+static int rw_mem(int rw,char * buf, int count, off_t * pos)
+{
+	return -EIO;
+}
+
+static int rw_kmem(int rw,char * buf, int count, off_t * pos)
+{
+	return -EIO;
+}
+
+static int rw_port(int rw,char * buf, int count, off_t * pos)
+{
+	int i=*pos;
+
+	while (count-->0 && i<65536) {
+		if (rw==READ)
+			put_fs_byte(inb(i),buf++);
+		else
+			outb(get_fs_byte(buf++),i);
+		i++;
+	}
+	i -= *pos;
+	*pos += i;
+	return i;
+}
 
-typedef (*crw_ptr)(int rw,unsigned minor,char * buf,int count);
+static int rw_memory(int rw, unsigned minor, char * buf, int count, off_t * pos)
+{
+	switch(minor) {
+		case 0:
+			return rw_ram(rw,buf,count,pos);
+		case 1:
+			return rw_mem(rw,buf,count,pos);
+		case 2:
+			return rw_kmem(rw,buf,count,pos);
+		case 3:
+			return (rw==READ)?0:count;	/* rw_null */
+		case 4:
+			return rw_port(rw,buf,count,pos);
+		default:
+			return -EIO;
+	}
+}
 
 #define NRDEVS ((sizeof (crw_table))/(sizeof (crw_ptr)))
 
 static crw_ptr crw_table[]={
 	NULL,		/* nodev */
-	NULL,		/* /dev/mem */
+	rw_memory,	/* /dev/mem etc */
 	NULL,		/* /dev/fd */
 	NULL,		/* /dev/hd */
 	rw_ttyx,	/* /dev/ttyx */
@@ -23,28 +92,13 @@ static crw_ptr crw_table[]={
 	NULL,		/* /dev/lp */
 	NULL};		/* unnamed pipes */
 
-static int rw_ttyx(int rw,unsigned minor,char * buf,int count)
-{
-	return ((rw==READ)?tty_read(minor,buf,count):
-		tty_write(minor,buf,count));
-}
-
-static int rw_tty(int rw,unsigned minor,char * buf,int count)
-{
-	if (current->tty<0)
-		return -EPERM;
-	return rw_ttyx(rw,current->tty,buf,count);
-}
-
-int rw_char(int rw,int dev, char * buf, int count)
+int rw_char(int rw,int dev, char * buf, int count, off_t * pos)
 {
 	crw_ptr call_addr;
 
 	if (MAJOR(dev)>=NRDEVS)
-		panic("rw_char: dev>NRDEV");
-	if (!(call_addr=crw_table[MAJOR(dev)])) {
-		printk("dev: %04x\n",dev);
-		panic("Trying to r/w from/to nonexistent character device");
-	}
-	return call_addr(rw,MINOR(dev),buf,count);
+		return -ENODEV;
+	if (!(call_addr=crw_table[MAJOR(dev)]))
+		return -ENODEV;
+	return call_addr(rw,MINOR(dev),buf,count,pos);
 }
diff --git a/fs/exec.c b/fs/exec.c
index 86de464..6be0b63 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1,4 +1,24 @@
+/*
+ *  linux/fs/exec.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ * #!-checking implemented by tytso.
+ */
+
+/*
+ * Demand-loading implemented 01.12.91 - no need to read anything but
+ * the header into memory. The inode of the executable is put into
+ * "current->executable", and page faults do the actual loading. Clean.
+ *
+ * Once more I can proudly say that linux stood up to being changed: it
+ * was less than 2 hours work to get demand-loading completely implemented.
+ */
+
 #include <errno.h>
+#include <string.h>
 #include <sys/stat.h>
 #include <a.out.h>
 
@@ -18,96 +38,6 @@ extern int sys_close(int fd);
  */
 #define MAX_ARG_PAGES 32
 
-#define cp_block(from,to) \
-__asm__("pushl $0x10\n\t" \
-	"pushl $0x17\n\t" \
-	"pop %%es\n\t" \
-	"cld\n\t" \
-	"rep\n\t" \
-	"movsl\n\t" \
-	"pop %%es" \
-	::"c" (BLOCK_SIZE/4),"S" (from),"D" (to) \
-	:"cx","di","si")
-
-/*
- * read_head() reads blocks 1-6 (not 0). Block 0 has already been
- * read for header information.
- */
-int read_head(struct m_inode * inode,int blocks)
-{
-	struct buffer_head * bh;
-	int count;
-
-	if (blocks>6)
-		blocks=6;
-	for(count = 0 ; count<blocks ; count++) {
-		if (!inode->i_zone[count+1])
-			continue;
-		if (!(bh=bread(inode->i_dev,inode->i_zone[count+1])))
-			return -1;
-		cp_block(bh->b_data,count*BLOCK_SIZE);
-		brelse(bh);
-	}
-	return 0;
-}
-
-int read_ind(int dev,int ind,long size,unsigned long offset)
-{
-	struct buffer_head * ih, * bh;
-	unsigned short * table,block;
-
-	if (size<=0)
-		panic("size<=0 in read_ind");
-	if (size>512*BLOCK_SIZE)
-		size=512*BLOCK_SIZE;
-	if (!ind)
-		return 0;
-	if (!(ih=bread(dev,ind)))
-		return -1;
-	table = (unsigned short *) ih->b_data;
-	while (size>0) {
-		if (block=*(table++))
-			if (!(bh=bread(dev,block))) {
-				brelse(ih);
-				return -1;
-			} else {
-				cp_block(bh->b_data,offset);
-				brelse(bh);
-			}
-		size -= BLOCK_SIZE;
-		offset += BLOCK_SIZE;
-	}
-	brelse(ih);
-	return 0;
-}
-
-/*
- * read_area() reads an area into %fs:mem.
- */
-int read_area(struct m_inode * inode,long size)
-{
-	struct buffer_head * dind;
-	unsigned short * table;
-	int i,count;
-
-	if ((i=read_head(inode,(size+BLOCK_SIZE-1)/BLOCK_SIZE)) ||
-	    (size -= BLOCK_SIZE*6)<=0)
-		return i;
-	if ((i=read_ind(inode->i_dev,inode->i_zone[7],size,BLOCK_SIZE*6)) ||
-	    (size -= BLOCK_SIZE*512)<=0)
-		return i;
-	if (!(i=inode->i_zone[8]))
-		return 0;
-	if (!(dind = bread(inode->i_dev,i)))
-		return -1;
-	table = (unsigned short *) dind->b_data;
-	for(count=0 ; count<512 ; count++)
-		if ((i=read_ind(inode->i_dev,*(table++),size,
-		    BLOCK_SIZE*(518+count))) || (size -= BLOCK_SIZE*512)<=0)
-			return i;
-	panic("Impossibly long executable");
-}
-
 /*
  * create_tables() parses the env- and arg-strings in new user
  * memory and creates the pointer tables from them, and puts their
@@ -158,36 +88,66 @@ static int count(char ** argv)
  * 'copy_string()' copies argument/envelope strings from user
  * memory to free pages in kernel mem. These are in a format ready
  * to be put directly into the top of new user memory.
+ *
+ * Modified by TYT, 11/24/91 to add the from_kmem argument, which specifies
+ * whether the string and the string array are from user or kernel segments:
+ *
+ * from_kmem     argv *        argv **
+ *    0          user space    user space
+ *    1          kernel space  user space
+ *    2          kernel space  kernel space
+ *
+ * We do this by playing games with the fs segment register.  Since it
+ * it is expensive to load a segment register, we try to avoid calling
+ * set_fs() unless we absolutely have to.
  */
 static unsigned long copy_strings(int argc,char ** argv,unsigned long *page,
-                unsigned long p)
+		unsigned long p, int from_kmem)
 {
-	int len,i;
-	char *tmp;
+	char *tmp, *pag;
+	int len, offset = 0;
+	unsigned long old_fs, new_fs;
 
+	if (!p)
+		return 0;	/* bullet-proofing */
+	new_fs = get_ds();
+	old_fs = get_fs();
+	if (from_kmem==2)
+		set_fs(new_fs);
 	while (argc-- > 0) {
-		if (!(tmp = (char *)get_fs_long(((unsigned long *) argv)+argc)))
+		if (from_kmem == 1)
+			set_fs(new_fs);
+		if (!(tmp = (char *)get_fs_long(((unsigned long *)argv)+argc)))
 			panic("argc is wrong");
-		len=0;          /* remember zero-padding */
+		if (from_kmem == 1)
+			set_fs(old_fs);
+		len=0;		/* remember zero-padding */
 		do {
 			len++;
 		} while (get_fs_byte(tmp++));
-		if (p-len < 0)          /* this shouldn't happen - 128kB */
+		if (p-len < 0) {	/* this shouldn't happen - 128kB */
+			set_fs(old_fs);
 			return 0;
-		i = ((unsigned) (p-len)) >> 12;
-		while (i<MAX_ARG_PAGES && !page[i]) {
-			if (!(page[i]=get_free_page()))
-				return 0;
-			i++;
 		}
-		do {
-			--p;
-			if (!page[p/PAGE_SIZE])
-				panic("nonexistent page in exec.c");
-			((char *) page[p/PAGE_SIZE])[p%PAGE_SIZE] =
-				get_fs_byte(--tmp);
-		} while (--len);
+		while (len) {
+			--p; --tmp; --len;
+			if (--offset < 0) {
+				offset = p % PAGE_SIZE;
+				if (from_kmem==2)
+					set_fs(old_fs);
+				if (!(pag = (char *) page[p/PAGE_SIZE]) &&
+						!(pag = (char *) page[p/PAGE_SIZE] =
+						(unsigned long *) get_free_page()))
+					return 0;
+				if (from_kmem==2)
+					set_fs(new_fs);
+
+			}
+			*(pag + offset) = get_fs_byte(tmp);
+		}
 	}
+	if (from_kmem==2)
+		set_fs(old_fs);
 	return p;
 }
 
@@ -227,7 +187,10 @@ int do_execve(unsigned long * eip,long tmp,char * filename,
 	struct exec ex;
 	unsigned long page[MAX_ARG_PAGES];
 	int i,argc,envc;
-	unsigned long p;
+	int e_uid, e_gid;
+	int retval;
+	int sh_bang = 0;
+	unsigned long p=PAGE_SIZE*MAX_ARG_PAGES-4;
 
 	if ((0xffff & eip[1]) != 0x000f)
 		panic("execve called from supervisor mode");
@@ -235,49 +198,129 @@ int do_execve(unsigned long * eip,long tmp,char * filename,
 		page[i]=0;
 	if (!(inode=namei(filename)))		/* get executables inode */
 		return -ENOENT;
+	argc = count(argv);
+	envc = count(envp);
+
+restart_interp:
 	if (!S_ISREG(inode->i_mode)) {	/* must be regular file */
-		iput(inode);
-		return -EACCES;
+		retval = -EACCES;
+		goto exec_error2;
 	}
 	i = inode->i_mode;
-	if (current->uid && current->euid) {
-		if (current->euid == inode->i_uid)
-			i >>= 6;
-		else if (current->egid == inode->i_gid)
-			i >>= 3;
-	} else if (i & 0111)
-		i=1;
-	if (!(i & 1)) {
-		iput(inode);
-		return -ENOEXEC;
+	e_uid = (i & S_ISUID) ? inode->i_uid : current->euid;
+	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
+	if (current->euid == inode->i_uid)
+		i >>= 6;
+	else if (current->egid == inode->i_gid)
+		i >>= 3;
+	if (!(i & 1) &&
+	    !((inode->i_mode & 0111) && suser())) {
+		retval = -ENOEXEC;
+		goto exec_error2;
 	}
 	if (!(bh = bread(inode->i_dev,inode->i_zone[0]))) {
+		retval = -EACCES;
+		goto exec_error2;
+	}
+	ex = *((struct exec *) bh->b_data);	/* read exec-header */
+	if ((bh->b_data[0] == '#') && (bh->b_data[1] == '!') && (!sh_bang)) {
+		/*
+		 * This section does the #! interpretation.
+		 * Sorta complicated, but hopefully it will work.  -TYT
+		 */
+
+		char buf[1023], *cp, *interp, *i_name, *i_arg;
+		unsigned long old_fs;
+
+		strncpy(buf, bh->b_data+2, 1022);
+		brelse(bh);
 		iput(inode);
-		return -EACCES;
+		buf[1022] = '\0';
+		if (cp = strchr(buf, '\n')) {
+			*cp = '\0';
+			for (cp = buf; (*cp == ' ') || (*cp == '\t'); cp++);
+		}
+		if (!cp || *cp == '\0') {
+			retval = -ENOEXEC; /* No interpreter name found */
+			goto exec_error1;
+		}
+		interp = i_name = cp;
+		i_arg = 0;
+		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
+			if (*cp == '/')
+				i_name = cp+1;
+		}
+		if (*cp) {
+			*cp++ = '\0';
+			i_arg = cp;
+		}
+		/*
+		 * OK, we've parsed out the interpreter name and
+		 * (optional) argument.
+		 */
+		if (sh_bang++ == 0) {
+			p = copy_strings(envc, envp, page, p, 0);
+			p = copy_strings(--argc, argv+1, page, p, 0);
+		}
+		/*
+		 * Splice in (1) the interpreter's name for argv[0]
+		 *           (2) (optional) argument to interpreter
+		 *           (3) filename of shell script
+		 *
+		 * This is done in reverse order, because of how the
+		 * user environment and arguments are stored.
+		 */
+		p = copy_strings(1, &filename, page, p, 1);
+		argc++;
+		if (i_arg) {
+			p = copy_strings(1, &i_arg, page, p, 2);
+			argc++;
+		}
+		p = copy_strings(1, &i_name, page, p, 2);
+		argc++;
+		if (!p) {
+			retval = -ENOMEM;
+			goto exec_error1;
+		}
+		/*
+		 * OK, now restart the process with the interpreter's inode.
+		 */
+		old_fs = get_fs();
+		set_fs(get_ds());
+		if (!(inode=namei(interp))) { /* get executables inode */
+			set_fs(old_fs);
+			retval = -ENOENT;
+			goto exec_error1;
+		}
+		set_fs(old_fs);
+		goto restart_interp;
 	}
-	ex = *((struct exec *) bh->b_data);     /* read exec-header */
 	brelse(bh);
 	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
 	    ex.a_text+ex.a_data+ex.a_bss>0x3000000 ||
 	    inode->i_size < ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) {
-		iput(inode);
-		return -ENOEXEC;
+		retval = -ENOEXEC;
+		goto exec_error2;
 	}
-	if (N_TXTOFF(ex) != BLOCK_SIZE)
-		panic("N_TXTOFF != BLOCK_SIZE. See a.out.h.");
-	argc = count(argv);
-	envc = count(envp);
-	p = copy_strings(envc,envp,page,PAGE_SIZE*MAX_ARG_PAGES-4);
-	p = copy_strings(argc,argv,page,p);
-	if (!p) {
-		for (i=0 ; i<MAX_ARG_PAGES ; i++)
-			free_page(page[i]);
-		iput(inode);
-		return -1;
+	if (N_TXTOFF(ex) != BLOCK_SIZE) {
+		printk("%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.", filename);
+		retval = -ENOEXEC;
+		goto exec_error2;
+	}
+	if (!sh_bang) {
+		p = copy_strings(envc,envp,page,p,0);
+		p = copy_strings(argc,argv,page,p,0);
+		if (!p) {
+			retval = -ENOMEM;
+			goto exec_error2;
+		}
 	}
 /* OK, This is the point of no return */
+	if (current->executable)
+		iput(current->executable);
+	current->executable = inode;
 	for (i=0 ; i<32 ; i++)
-		current->sig_fn[i] = NULL;
+		current->sigaction[i].sa_handler = NULL;
 	for (i=0 ; i<NR_OPEN ; i++)
 		if ((current->close_on_exec>>i)&1)
 			sys_close(i);
@@ -293,14 +336,18 @@ int do_execve(unsigned long * eip,long tmp,char * filename,
 		(current->end_data = ex.a_data +
 		(current->end_code = ex.a_text));
 	current->start_stack = p & 0xfffff000;
-	i = read_area(inode,ex.a_text+ex.a_data);
-	iput(inode);
-	if (i<0)
-		sys_exit(-1);
+	current->euid = e_uid;
+	current->egid = e_gid;
 	i = ex.a_text+ex.a_data;
 	while (i&0xfff)
 		put_fs_byte(0,(char *) (i++));
 	eip[0] = ex.a_entry;		/* eip, magic happens :-) */
 	eip[3] = p;			/* stack pointer */
 	return 0;
+exec_error2:
+	iput(inode);
+exec_error1:
+	for (i=0 ; i<MAX_ARG_PAGES ; i++)
+		free_page(page[i]);
+	return(retval);
 }
diff --git a/fs/fcntl.c b/fs/fcntl.c
index 242f738..d0b9746 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/fcntl.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <string.h>
 #include <errno.h>
 #include <linux/sched.h>
diff --git a/fs/file_dev.c b/fs/file_dev.c
index da5d014..0c50eaa 100644
--- a/fs/file_dev.c
+++ b/fs/file_dev.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/file_dev.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <errno.h>
 #include <fcntl.h>
 
diff --git a/fs/file_table.c b/fs/file_table.c
index ab7cebf..e0589ac 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/file_table.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <linux/fs.h>
 
 struct file file_table[NR_FILE];
diff --git a/fs/inode.c b/fs/inode.c
index ad67741..80971b8 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -1,4 +1,11 @@
+/*
+ *  linux/fs/inode.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <string.h>
+#include <sys/stat.h>
 
 #include <linux/sched.h>
 #include <linux/kernel.h>
@@ -33,6 +40,22 @@ static inline void unlock_inode(struct m_inode * inode)
 	wake_up(&inode->i_wait);
 }
 
+void invalidate_inodes(int dev)
+{
+	int i;
+	struct m_inode * inode;
+
+	inode = 0+inode_table;
+	for(i=0 ; i<NR_INODE ; i++,inode++) {
+		wait_on_inode(inode);
+		if (inode->i_dev == dev) {
+			if (inode->i_count)
+				printk("inode in use on removed disk\n\r");
+			inode->i_dev = inode->i_dirt = 0;
+		}
+	}
+}
+
 void sync_inodes(void)
 {
 	int i;
@@ -141,18 +164,26 @@ void iput(struct m_inode * inode)
 		inode->i_pipe=0;
 		return;
 	}
-	if (!inode->i_dev || inode->i_count>1) {
+	if (!inode->i_dev) {
 		inode->i_count--;
 		return;
 	}
+	if (S_ISBLK(inode->i_mode)) {
+		sync_dev(inode->i_zone[0]);
+		wait_on_inode(inode);
+	}
 repeat:
+	if (inode->i_count>1) {
+		inode->i_count--;
+		return;
+	}
 	if (!inode->i_nlinks) {
 		truncate(inode);
 		free_inode(inode);
 		return;
 	}
 	if (inode->i_dirt) {
-		write_inode(inode);     /* we can sleep - so do again */
+		write_inode(inode);	/* we can sleep - so do again */
 		wait_on_inode(inode);
 		goto repeat;
 	}
@@ -160,40 +191,35 @@ repeat:
 	return;
 }
 
-static volatile int last_allocated_inode = 0;
-
 struct m_inode * get_empty_inode(void)
 {
 	struct m_inode * inode;
-	int inr;
+	static struct m_inode * last_inode = inode_table;
+	int i;
 
-	while (1) {
+	do {
 		inode = NULL;
-		inr = last_allocated_inode;
-		do {
-			if (!inode_table[inr].i_count) {
-				inode = inr + inode_table;
-				break;
+		for (i = NR_INODE; i ; i--) {
+			if (++last_inode >= inode_table + NR_INODE)
+				last_inode = inode_table;
+			if (!last_inode->i_count) {
+				inode = last_inode;
+				if (!inode->i_dirt && !inode->i_lock)
+					break;
 			}
-			inr++;
-			if (inr>=NR_INODE)
-				inr=0;
-		} while (inr != last_allocated_inode);
+		}
 		if (!inode) {
-			for (inr=0 ; inr<NR_INODE ; inr++)
-				printk("%04x: %6d\t",inode_table[inr].i_dev,
-					inode_table[inr].i_num);
+			for (i=0 ; i<NR_INODE ; i++)
+				printk("%04x: %6d\t",inode_table[i].i_dev,
+					inode_table[i].i_num);
 			panic("No free inodes in mem");
 		}
-		last_allocated_inode = inr;
 		wait_on_inode(inode);
 		while (inode->i_dirt) {
 			write_inode(inode);
 			wait_on_inode(inode);
 		}
-		if (!inode->i_count)
-			break;
-	}
+	} while (inode->i_count);
 	memset(inode,0,sizeof(*inode));
 	inode->i_count = 1;
 	return inode;
@@ -234,6 +260,24 @@ struct m_inode * iget(int dev,int nr)
 			continue;
 		}
 		inode->i_count++;
+		if (inode->i_mount) {
+			int i;
+
+			for (i = 0 ; i<NR_SUPER ; i++)
+				if (super_block[i].s_imount==inode)
+					break;
+			if (i >= NR_SUPER) {
+				printk("Mounted inode hasn't got sb\n");
+				if (empty)
+					iput(empty);
+				return inode;
+			}
+			iput(inode);
+			dev = super_block[i].s_dev;
+			nr = ROOT_INO;
+			inode = inode_table;
+			continue;
+		}
 		if (empty)
 			iput(empty);
 		return inode;
@@ -254,7 +298,8 @@ static void read_inode(struct m_inode * inode)
 	int block;
 
 	lock_inode(inode);
-	sb=get_super(inode->i_dev);
+	if (!(sb=get_super(inode->i_dev)))
+		panic("trying to read inode without dev");
 	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
 		(inode->i_num-1)/INODES_PER_BLOCK;
 	if (!(bh=bread(inode->i_dev,block)))
@@ -273,7 +318,12 @@ static void write_inode(struct m_inode * inode)
 	int block;
 
 	lock_inode(inode);
-	sb=get_super(inode->i_dev);
+	if (!inode->i_dirt || !inode->i_dev) {
+		unlock_inode(inode);
+		return;
+	}
+	if (!(sb=get_super(inode->i_dev)))
+		panic("trying to write inode without device");
 	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
 		(inode->i_num-1)/INODES_PER_BLOCK;
 	if (!(bh=bread(inode->i_dev,block)))
diff --git a/fs/ioctl.c b/fs/ioctl.c
index 387b85c..6c680ec 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/ioctl.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <string.h>
 #include <errno.h>
 #include <sys/stat.h>
@@ -32,7 +38,7 @@ int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
 		return -EINVAL;
 	dev = filp->f_inode->i_zone[0];
 	if (MAJOR(dev) >= NRDEVS)
-		panic("unknown device for ioctl");
+		return -ENODEV;
 	if (!ioctl_table[MAJOR(dev)])
 		return -ENOTTY;
 	return ioctl_table[MAJOR(dev)](dev,cmd,arg);
diff --git a/fs/namei.c b/fs/namei.c
index 550e902..ddf2379 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1,3 +1,13 @@
+/*
+ *  linux/fs/namei.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ * Some corrections by tytso.
+ */
+
 #include <linux/sched.h>
 #include <linux/kernel.h>
 #include <asm/segment.h>
@@ -34,13 +44,13 @@ static int permission(struct m_inode * inode,int mask)
 /* special case: not even root can read/write a deleted file */
 	if (inode->i_dev && !inode->i_nlinks)
 		return 0;
-	if (!(current->uid && current->euid))
-		mode=0777;
-	else if (current->uid==inode->i_uid || current->euid==inode->i_uid)
+	else if (current->euid==inode->i_uid)
 		mode >>= 6;
-	else if (current->gid==inode->i_gid || current->egid==inode->i_gid)
+	else if (current->egid==inode->i_gid)
 		mode >>= 3;
-	return mode & mask & 0007;
+	if (((mode & mask & 0007) == mask) || suser())
+		return 1;
+	return 0;
 }
 
 /*
@@ -62,7 +72,7 @@ static int match(int len,const char * name,struct dir_entry * de)
 		"fs ; repe ; cmpsb\n\t"
 		"setz %%al"
 		:"=a" (same)
-		:"" (0),"S" ((long) name),"D" ((long) de->name),"c" (len)
+		:"0" (0),"S" ((long) name),"D" ((long) de->name),"c" (len)
 		:"cx","di","si");
 	return same;
 }
@@ -74,14 +84,18 @@ static int match(int len,const char * name,struct dir_entry * de)
  * returns the cache buffer in which the entry was found, and the entry
  * itself (as a parameter - res_dir). It does NOT read the inode of the
  * entry - you'll have to do that yourself if you want to.
+ *
+ * This also takes care of the few special cases due to '..'-traversal
+ * over a pseudo-root and a mount point.
  */
-static struct buffer_head * find_entry(struct m_inode * dir,
+static struct buffer_head * find_entry(struct m_inode ** dir,
 	const char * name, int namelen, struct dir_entry ** res_dir)
 {
 	int entries;
 	int block,i;
 	struct buffer_head * bh;
 	struct dir_entry * de;
+	struct super_block * sb;
 
 #ifdef NO_TRUNCATE
 	if (namelen > NAME_LEN)
@@ -90,13 +104,29 @@ static struct buffer_head * find_entry(struct m_inode * dir,
 	if (namelen > NAME_LEN)
 		namelen = NAME_LEN;
 #endif
-	entries = dir->i_size / (sizeof (struct dir_entry));
+	entries = (*dir)->i_size / (sizeof (struct dir_entry));
 	*res_dir = NULL;
 	if (!namelen)
 		return NULL;
-	if (!(block = dir->i_zone[0]))
+/* check for '..', as we might have to do some "magic" for it */
+	if (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {
+/* '..' in a pseudo-root results in a faked '.' (just change namelen) */
+		if ((*dir) == current->root)
+			namelen=1;
+		else if ((*dir)->i_num == ROOT_INO) {
+/* '..' over a mount-point results in 'dir' being exchanged for the mounted
+   directory-inode. NOTE! We set mounted, so that we can iput the new dir */
+			sb=get_super((*dir)->i_dev);
+			if (sb->s_imount) {
+				iput(*dir);
+				(*dir)=sb->s_imount;
+				(*dir)->i_count++;
+			}
+		}
+	}
+	if (!(block = (*dir)->i_zone[0]))
 		return NULL;
-	if (!(bh = bread(dir->i_dev,block)))
+	if (!(bh = bread((*dir)->i_dev,block)))
 		return NULL;
 	i = 0;
 	de = (struct dir_entry *) bh->b_data;
@@ -104,8 +134,8 @@ static struct buffer_head * find_entry(struct m_inode * dir,
 		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
 			brelse(bh);
 			bh = NULL;
-			if (!(block = bmap(dir,i/DIR_ENTRIES_PER_BLOCK)) ||
-			    !(bh = bread(dir->i_dev,block))) {
+			if (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||
+			    !(bh = bread((*dir)->i_dev,block))) {
 				i += DIR_ENTRIES_PER_BLOCK;
 				continue;
 			}
@@ -226,7 +256,7 @@ static struct m_inode * get_dir(const char * pathname)
 			/* nothing */ ;
 		if (!c)
 			return inode;
-		if (!(bh = find_entry(inode,thisname,namelen,&de))) {
+		if (!(bh = find_entry(&inode,thisname,namelen,&de))) {
 			iput(inode);
 			return NULL;
 		}
@@ -282,7 +312,7 @@ struct m_inode * namei(const char * pathname)
 		return NULL;
 	if (!namelen)		/* special case: '/usr/' etc */
 		return dir;
-	bh = find_entry(dir,basename,namelen,&de);
+	bh = find_entry(&dir,basename,namelen,&de);
 	if (!bh) {
 		iput(dir);
 		return NULL;
@@ -327,7 +357,7 @@ int open_namei(const char * pathname, int flag, int mode,
 		iput(dir);
 		return -EISDIR;
 	}
-	bh = find_entry(dir,basename,namelen,&de);
+	bh = find_entry(&dir,basename,namelen,&de);
 	if (!bh) {
 		if (!(flag & O_CREAT)) {
 			iput(dir);
@@ -342,6 +372,7 @@ int open_namei(const char * pathname, int flag, int mode,
 			iput(dir);
 			return -ENOSPC;
 		}
+		inode->i_uid = current->euid;
 		inode->i_mode = mode;
 		inode->i_dirt = 1;
 		bh = add_entry(dir,basename,namelen,&de);
@@ -367,7 +398,7 @@ int open_namei(const char * pathname, int flag, int mode,
 	if (!(inode=iget(dev,inr)))
 		return -EACCES;
 	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
-	    permission(inode,ACC_MODE(flag))!=ACC_MODE(flag)) {
+	    !permission(inode,ACC_MODE(flag))) {
 		iput(inode);
 		return -EPERM;
 	}
@@ -378,6 +409,57 @@ int open_namei(const char * pathname, int flag, int mode,
 	return 0;
 }
 
+int sys_mknod(const char * filename, int mode, int dev)
+{
+	const char * basename;
+	int namelen;
+	struct m_inode * dir, * inode;
+	struct buffer_head * bh;
+	struct dir_entry * de;
+
+	if (!suser())
+		return -EPERM;
+	if (!(dir = dir_namei(filename,&namelen,&basename)))
+		return -ENOENT;
+	if (!namelen) {
+		iput(dir);
+		return -ENOENT;
+	}
+	if (!permission(dir,MAY_WRITE)) {
+		iput(dir);
+		return -EPERM;
+	}
+	bh = find_entry(&dir,basename,namelen,&de);
+	if (bh) {
+		brelse(bh);
+		iput(dir);
+		return -EEXIST;
+	}
+	inode = new_inode(dir->i_dev);
+	if (!inode) {
+		iput(dir);
+		return -ENOSPC;
+	}
+	inode->i_mode = mode;
+	if (S_ISBLK(mode) || S_ISCHR(mode))
+		inode->i_zone[0] = dev;
+	inode->i_mtime = inode->i_atime = CURRENT_TIME;
+	inode->i_dirt = 1;
+	bh = add_entry(dir,basename,namelen,&de);
+	if (!bh) {
+		iput(dir);
+		inode->i_nlinks=0;
+		iput(inode);
+		return -ENOSPC;
+	}
+	de->inode = inode->i_num;
+	bh->b_dirt = 1;
+	iput(dir);
+	iput(inode);
+	brelse(bh);
+	return 0;
+}
+
 int sys_mkdir(const char * pathname, int mode)
 {
 	const char * basename;
@@ -386,7 +468,7 @@ int sys_mkdir(const char * pathname, int mode)
 	struct buffer_head * bh, *dir_block;
 	struct dir_entry * de;
 
-	if (current->euid && current->uid)
+	if (!suser())
 		return -EPERM;
 	if (!(dir = dir_namei(pathname,&namelen,&basename)))
 		return -ENOENT;
@@ -398,7 +480,7 @@ int sys_mkdir(const char * pathname, int mode)
 		iput(dir);
 		return -EPERM;
 	}
-	bh = find_entry(dir,basename,namelen,&de);
+	bh = find_entry(&dir,basename,namelen,&de);
 	if (bh) {
 		brelse(bh);
 		iput(dir);
@@ -510,7 +592,7 @@ int sys_rmdir(const char * name)
 	struct buffer_head * bh;
 	struct dir_entry * de;
 
-	if (current->euid && current->uid)
+	if (!suser())
 		return -EPERM;
 	if (!(dir = dir_namei(name,&namelen,&basename)))
 		return -ENOENT;
@@ -518,18 +600,30 @@ int sys_rmdir(const char * name)
 		iput(dir);
 		return -ENOENT;
 	}
-	bh = find_entry(dir,basename,namelen,&de);
+	if (!permission(dir,MAY_WRITE)) {
+		iput(dir);
+		return -EPERM;
+	}
+	bh = find_entry(&dir,basename,namelen,&de);
 	if (!bh) {
 		iput(dir);
 		return -ENOENT;
 	}
-	if (!permission(dir,MAY_WRITE)) {
+	if (!(inode = iget(dir->i_dev, de->inode))) {
 		iput(dir);
 		brelse(bh);
 		return -EPERM;
 	}
-	if (!(inode = iget(dir->i_dev, de->inode))) {
+	if ((dir->i_mode & S_ISVTX) && current->euid &&
+	    inode->i_uid != current->euid) {
 		iput(dir);
+		iput(inode);
+		brelse(bh);
+		return -EPERM;
+	}
+	if (inode->i_dev != dir->i_dev || inode->i_count>1) {
+		iput(dir);
+		iput(inode);
 		brelse(bh);
 		return -EPERM;
 	}
@@ -584,19 +678,25 @@ int sys_unlink(const char * name)
 		iput(dir);
 		return -EPERM;
 	}
-	bh = find_entry(dir,basename,namelen,&de);
+	bh = find_entry(&dir,basename,namelen,&de);
 	if (!bh) {
 		iput(dir);
 		return -ENOENT;
 	}
-	inode = iget(dir->i_dev, de->inode);
-	if (!inode) {
-		printk("iget failed in delete (%04x:%d)",dir->i_dev,de->inode);
+	if (!(inode = iget(dir->i_dev, de->inode))) {
 		iput(dir);
 		brelse(bh);
 		return -ENOENT;
 	}
-	if (!S_ISREG(inode->i_mode)) {
+	if ((dir->i_mode & S_ISVTX) && !suser() &&
+	    current->euid != inode->i_uid &&
+	    current->euid != dir->i_uid) {
+		iput(dir);
+		iput(inode);
+		brelse(bh);
+		return -EPERM;
+	}
+	if (S_ISDIR(inode->i_mode)) {
 		iput(inode);
 		iput(dir);
 		brelse(bh);
@@ -629,7 +729,7 @@ int sys_link(const char * oldname, const char * newname)
 	oldinode=namei(oldname);
 	if (!oldinode)
 		return -ENOENT;
-	if (!S_ISREG(oldinode->i_mode)) {
+	if (S_ISDIR(oldinode->i_mode)) {
 		iput(oldinode);
 		return -EPERM;
 	}
@@ -653,7 +753,7 @@ int sys_link(const char * oldname, const char * newname)
 		iput(oldinode);
 		return -EACCES;
 	}
-	bh = find_entry(dir,basename,namelen,&de);
+	bh = find_entry(&dir,basename,namelen,&de);
 	if (bh) {
 		brelse(bh);
 		iput(dir);
diff --git a/fs/open.c b/fs/open.c
index 9ad36e1..814c984 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/open.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <string.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -10,6 +16,11 @@
 #include <linux/kernel.h>
 #include <asm/segment.h>
 
+int sys_ustat(int dev, struct ustat * ubuf)
+{
+	return -ENOSYS;
+}
+
 int sys_utime(char * filename, struct utimbuf * times)
 {
 	struct m_inode * inode;
@@ -29,27 +40,35 @@ int sys_utime(char * filename, struct utimbuf * times)
 	return 0;
 }
 
+/*
+ * XXX should we use the real or effective uid?  BSD uses the real uid,
+ * so as to make this call useful to setuid programs.
+ */
 int sys_access(const char * filename,int mode)
 {
 	struct m_inode * inode;
-	int res;
+	int res, i_mode;
 
 	mode &= 0007;
 	if (!(inode=namei(filename)))
 		return -EACCES;
-	res = inode->i_mode & 0777;
+	i_mode = res = inode->i_mode & 0777;
 	iput(inode);
-	if (!(current->euid && current->uid))
-		if (res & 0111)
-			res = 0777;
-		else
-			res = 0666;
-	if (current->euid == inode->i_uid)
+	if (current->uid == inode->i_uid)
 		res >>= 6;
-	else if (current->egid == inode->i_gid)
+	else if (current->gid == inode->i_gid)
 		res >>= 6;
 	if ((res & 0007 & mode) == mode)
 		return 0;
+	/*
+	 * XXX we are doing this test last because we really should be
+	 * swapping the effective with the real user id (temporarily),
+	 * and then calling suser() routine.  If we do call the
+	 * suser() routine, it needs to be called last.
+	 */
+	if ((!current->uid) &&
+	    (!(mode & 1) || (i_mode & 0111)))
+		return 0;
 	return -EACCES;
 }
 
@@ -89,12 +108,10 @@ int sys_chmod(const char * filename,int mode)
 
 	if (!(inode=namei(filename)))
 		return -ENOENT;
-	if (current->uid && current->euid)
-		if (current->uid!=inode->i_uid && current->euid!=inode->i_uid) {
-			iput(inode);
-			return -EACCES;
-		} else
-			mode = (mode & 0777) | (inode->i_mode & 07000);
+	if ((current->euid != inode->i_uid) && !suser()) {
+		iput(inode);
+		return -EACCES;
+	}
 	inode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);
 	inode->i_dirt = 1;
 	iput(inode);
@@ -107,7 +124,7 @@ int sys_chown(const char * filename,int uid,int gid)
 
 	if (!(inode=namei(filename)))
 		return -ENOENT;
-	if (current->uid && current->euid) {
+	if (!suser()) {
 		iput(inode);
 		return -EACCES;
 	}
@@ -156,6 +173,9 @@ int sys_open(const char * filename,int flag,int mode)
 				f->f_count=0;
 				return -EPERM;
 			}
+/* Likewise with block-devices: check for floppy_change */
+	if (S_ISBLK(inode->i_mode))
+		check_disk_change(inode->i_zone[0]);
 	f->f_mode = inode->i_mode;
 	f->f_flags = flag;
 	f->f_count = 1;
diff --git a/fs/pipe.c b/fs/pipe.c
index 4392a86..bae4c5f 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/pipe.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <signal.h>
 
 #include <linux/sched.h>
@@ -6,47 +12,60 @@
 
 int read_pipe(struct m_inode * inode, char * buf, int count)
 {
-	char * b=buf;
+	int chars, size, read = 0;
 
-	while (PIPE_EMPTY(*inode)) {
-		wake_up(&inode->i_wait);
-		if (inode->i_count != 2) /* are there any writers left? */
-			return 0;
-		sleep_on(&inode->i_wait);
-	}
-	while (count>0 && !(PIPE_EMPTY(*inode))) {
-		count --;
-		put_fs_byte(((char *)inode->i_size)[PIPE_TAIL(*inode)],b++);
-		INC_PIPE( PIPE_TAIL(*inode) );
+	while (count>0) {
+		while (!(size=PIPE_SIZE(*inode))) {
+			wake_up(&inode->i_wait);
+			if (inode->i_count != 2) /* are there any writers? */
+				return read;
+			sleep_on(&inode->i_wait);
+		}
+		chars = PAGE_SIZE-PIPE_TAIL(*inode);
+		if (chars > count)
+			chars = count;
+		if (chars > size)
+			chars = size;
+		count -= chars;
+		read += chars;
+		size = PIPE_TAIL(*inode);
+		PIPE_TAIL(*inode) += chars;
+		PIPE_TAIL(*inode) &= (PAGE_SIZE-1);
+		while (chars-->0)
+			put_fs_byte(((char *)inode->i_size)[size++],buf++);
 	}
 	wake_up(&inode->i_wait);
-	return b-buf;
-	}
+	return read;
+}
 
-	int write_pipe(struct m_inode * inode, char * buf, int count)
-	{
-	char * b=buf;
+int write_pipe(struct m_inode * inode, char * buf, int count)
+{
+	int chars, size, written = 0;
 
-	wake_up(&inode->i_wait);
-	if (inode->i_count != 2) { /* no readers */
-		current->signal |= (1<<(SIGPIPE-1));
-		return -1;
-	}
-	while (count-->0) {
-		while (PIPE_FULL(*inode)) {
+	while (count>0) {
+		while (!(size=(PAGE_SIZE-1)-PIPE_SIZE(*inode))) {
 			wake_up(&inode->i_wait);
-			if (inode->i_count != 2) {
+			if (inode->i_count != 2) { /* no readers */
 				current->signal |= (1<<(SIGPIPE-1));
-				return b-buf;
+				return written?written:-1;
 			}
 			sleep_on(&inode->i_wait);
 		}
-		((char *)inode->i_size)[PIPE_HEAD(*inode)] = get_fs_byte(b++);
-		INC_PIPE( PIPE_HEAD(*inode) );
-		wake_up(&inode->i_wait);
+		chars = PAGE_SIZE-PIPE_HEAD(*inode);
+		if (chars > count)
+			chars = count;
+		if (chars > size)
+			chars = size;
+		count -= chars;
+		written += chars;
+		size = PIPE_HEAD(*inode);
+		PIPE_HEAD(*inode) += chars;
+		PIPE_HEAD(*inode) &= (PAGE_SIZE-1);
+		while (chars-->0)
+			((char *)inode->i_size)[size++]=get_fs_byte(buf++);
 	}
 	wake_up(&inode->i_wait);
-	return b-buf;
+	return written;
 }
 
 int sys_pipe(unsigned long * fildes)
diff --git a/fs/read_write.c b/fs/read_write.c
index 955db46..9750d22 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/read_write.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <sys/stat.h>
 #include <errno.h>
 #include <sys/types.h>
@@ -6,7 +12,7 @@
 #include <linux/sched.h>
 #include <asm/segment.h>
 
-extern int rw_char(int rw,int dev, char * buf, int count);
+extern int rw_char(int rw,int dev, char * buf, int count, off_t * pos);
 extern int read_pipe(struct m_inode * inode, char * buf, int count);
 extern int write_pipe(struct m_inode * inode, char * buf, int count);
 extern int block_read(int dev, off_t * pos, char * buf, int count);
@@ -22,7 +28,7 @@ int sys_lseek(unsigned int fd,off_t offset, int origin)
 	int tmp;
 
 	if (fd >= NR_OPEN || !(file=current->filp[fd]) || !(file->f_inode)
-	   || !IS_BLOCKDEV(MAJOR(file->f_inode->i_dev)))
+	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))
 		return -EBADF;
 	if (file->f_inode->i_pipe)
 		return -ESPIPE;
@@ -58,9 +64,9 @@ int sys_read(unsigned int fd,char * buf,int count)
 	verify_area(buf,count);
 	inode = file->f_inode;
 	if (inode->i_pipe)
-		return (file->f_mode&1)?read_pipe(inode,buf,count):-1;
+		return (file->f_mode&1)?read_pipe(inode,buf,count):-EIO;
 	if (S_ISCHR(inode->i_mode))
-		return rw_char(READ,inode->i_zone[0],buf,count);
+		return rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);
 	if (S_ISBLK(inode->i_mode))
 		return block_read(inode->i_zone[0],&file->f_pos,buf,count);
 	if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {
@@ -85,9 +91,9 @@ int sys_write(unsigned int fd,char * buf,int count)
 		return 0;
 	inode=file->f_inode;
 	if (inode->i_pipe)
-		return (file->f_mode&2)?write_pipe(inode,buf,count):-1;
+		return (file->f_mode&2)?write_pipe(inode,buf,count):-EIO;
 	if (S_ISCHR(inode->i_mode))
-		return rw_char(WRITE,inode->i_zone[0],buf,count);
+		return rw_char(WRITE,inode->i_zone[0],buf,count,&file->f_pos);
 	if (S_ISBLK(inode->i_mode))
 		return block_write(inode->i_zone[0],&file->f_pos,buf,count);
 	if (S_ISREG(inode->i_mode))
diff --git a/fs/stat.c b/fs/stat.c
index 4bec71d..61a4ceb 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/stat.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <errno.h>
 #include <sys/stat.h>
 
@@ -6,7 +12,7 @@
 #include <linux/kernel.h>
 #include <asm/segment.h>
 
-static int cp_stat(struct m_inode * inode, struct stat * statbuf)
+static void cp_stat(struct m_inode * inode, struct stat * statbuf)
 {
 	struct stat tmp;
 	int i;
@@ -25,19 +31,17 @@ static int cp_stat(struct m_inode * inode, struct stat * statbuf)
 	tmp.st_ctime = inode->i_ctime;
 	for (i=0 ; i<sizeof (tmp) ; i++)
 		put_fs_byte(((char *) &tmp)[i],&((char *) statbuf)[i]);
-	return (0);
 }
 
 int sys_stat(char * filename, struct stat * statbuf)
 {
-	int i;
 	struct m_inode * inode;
 
 	if (!(inode=namei(filename)))
 		return -ENOENT;
-	i=cp_stat(inode,statbuf);
+	cp_stat(inode,statbuf);
 	iput(inode);
-	return i;
+	return 0;
 }
 
 int sys_fstat(unsigned int fd, struct stat * statbuf)
@@ -46,6 +50,7 @@ int sys_fstat(unsigned int fd, struct stat * statbuf)
 	struct m_inode * inode;
 
 	if (fd >= NR_OPEN || !(f=current->filp[fd]) || !(inode=f->f_inode))
-		return -ENOENT;
-	return cp_stat(inode,statbuf);
+		return -EBADF;
+	cp_stat(inode,statbuf);
+	return 0;
 }
diff --git a/fs/super.c b/fs/super.c
index 89fe977..b73fdca 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -1,9 +1,22 @@
 /*
+ *  linux/fs/super.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  * super.c contains code to handle the super-block tables.
  */
 #include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
+#include <asm/system.h>
+
+#include <errno.h>
+#include <sys/stat.h>
+
+int sync_dev(int dev);
+void wait_for_keypress(void);
 
 /* set_bit uses setb, as gas doesn't recognize setc */
 #define set_bit(bitnr,addr) ({ \
@@ -12,59 +25,218 @@ __asm__("bt %2,%3;setb %%al":"=a" (__res):"a" (0),"r" (bitnr),"m" (*(addr))); \
 __res; })
 
 struct super_block super_block[NR_SUPER];
+/* this is initialized in init/main.c */
+int ROOT_DEV = 0;
 
-struct super_block * do_mount(int dev)
+static void lock_super(struct super_block * sb)
 {
-	struct super_block * p;
+	cli();
+	while (sb->s_lock)
+		sleep_on(&(sb->s_wait));
+	sb->s_lock = 1;
+	sti();
+}
+
+static void free_super(struct super_block * sb)
+{
+	cli();
+	sb->s_lock = 0;
+	wake_up(&(sb->s_wait));
+	sti();
+}
+
+static void wait_on_super(struct super_block * sb)
+{
+	cli();
+	while (sb->s_lock)
+		sleep_on(&(sb->s_wait));
+	sti();
+}
+
+struct super_block * get_super(int dev)
+{
+	struct super_block * s;
+
+	if (!dev)
+		return NULL;
+	s = 0+super_block;
+	while (s < NR_SUPER+super_block)
+		if (s->s_dev == dev) {
+			wait_on_super(s);
+			if (s->s_dev == dev)
+				return s;
+			s = 0+super_block;
+		} else
+			s++;
+	return NULL;
+}
+
+void put_super(int dev)
+{
+	struct super_block * sb;
+	struct m_inode * inode;
+	int i;
+
+	if (dev == ROOT_DEV) {
+		printk("root diskette changed: prepare for armageddon\n\r");
+		return;
+	}
+	if (!(sb = get_super(dev)))
+		return;
+	if (sb->s_imount) {
+		printk("Mounted disk changed - tssk, tssk\n\r");
+		return;
+	}
+	lock_super(sb);
+	sb->s_dev = 0;
+	for(i=0;i<I_MAP_SLOTS;i++)
+		brelse(sb->s_imap[i]);
+	for(i=0;i<Z_MAP_SLOTS;i++)
+		brelse(sb->s_zmap[i]);
+	free_super(sb);
+	return;
+}
+
+static struct super_block * read_super(int dev)
+{
+	struct super_block * s;
 	struct buffer_head * bh;
 	int i,block;
 
-	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++ )
-		if (!(p->s_dev))
-			break;
-	p->s_dev = -1;          /* mark it in use */
-	if (p >= &super_block[NR_SUPER])
+	if (!dev)
 		return NULL;
-	if (!(bh = bread(dev,1)))
+	check_disk_change(dev);
+	if (s = get_super(dev))
+		return s;
+	for (s = 0+super_block ;; s++) {
+		if (s >= NR_SUPER+super_block)
+			return NULL;
+		if (!s->s_dev)
+			break;
+	}
+	s->s_dev = dev;
+	s->s_isup = NULL;
+	s->s_imount = NULL;
+	s->s_time = 0;
+	s->s_rd_only = 0;
+	s->s_dirt = 0;
+	lock_super(s);
+	if (!(bh = bread(dev,1))) {
+		s->s_dev=0;
+		free_super(s);
 		return NULL;
-	*p = *((struct super_block *) bh->b_data);
+	}
+	*((struct d_super_block *) s) =
+		*((struct d_super_block *) bh->b_data);
 	brelse(bh);
-	if (p->s_magic != SUPER_MAGIC) {
-		p->s_dev = 0;
+	if (s->s_magic != SUPER_MAGIC) {
+		s->s_dev = 0;
+		free_super(s);
 		return NULL;
 	}
 	for (i=0;i<I_MAP_SLOTS;i++)
-		p->s_imap[i] = NULL;
+		s->s_imap[i] = NULL;
 	for (i=0;i<Z_MAP_SLOTS;i++)
-		p->s_zmap[i] = NULL;
+		s->s_zmap[i] = NULL;
 	block=2;
-	for (i=0 ; i < p->s_imap_blocks ; i++)
-		if (p->s_imap[i]=bread(dev,block))
+	for (i=0 ; i < s->s_imap_blocks ; i++)
+		if (s->s_imap[i]=bread(dev,block))
 			block++;
 		else
 			break;
-	for (i=0 ; i < p->s_zmap_blocks ; i++)
-		if (p->s_zmap[i]=bread(dev,block))
+	for (i=0 ; i < s->s_zmap_blocks ; i++)
+		if (s->s_zmap[i]=bread(dev,block))
 			block++;
 		else
 			break;
-	if (block != 2+p->s_imap_blocks+p->s_zmap_blocks) {
+	if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {
 		for(i=0;i<I_MAP_SLOTS;i++)
-			brelse(p->s_imap[i]);
+			brelse(s->s_imap[i]);
 		for(i=0;i<Z_MAP_SLOTS;i++)
-			brelse(p->s_zmap[i]);
-		p->s_dev=0;
+			brelse(s->s_zmap[i]);
+		s->s_dev=0;
+		free_super(s);
 		return NULL;
 	}
-	p->s_imap[0]->b_data[0] |= 1;
-	p->s_zmap[0]->b_data[0] |= 1;
-	p->s_dev = dev;
-	p->s_isup = NULL;
-	p->s_imount = NULL;
-	p->s_time = 0;
-	p->s_rd_only = 0;
-	p->s_dirt = 0;
-	return p;
+	s->s_imap[0]->b_data[0] |= 1;
+	s->s_zmap[0]->b_data[0] |= 1;
+	free_super(s);
+	return s;
+}
+
+int sys_umount(char * dev_name)
+{
+	struct m_inode * inode;
+	struct super_block * sb;
+	int dev;
+
+	if (!(inode=namei(dev_name)))
+		return -ENOENT;
+	dev = inode->i_zone[0];
+	if (!S_ISBLK(inode->i_mode)) {
+		iput(inode);
+		return -ENOTBLK;
+	}
+	iput(inode);
+	if (dev==ROOT_DEV)
+		return -EBUSY;
+	if (!(sb=get_super(dev)) || !(sb->s_imount))
+		return -ENOENT;
+	if (!sb->s_imount->i_mount)
+		printk("Mounted inode has i_mount=0\n");
+	for (inode=inode_table+0 ; inode<inode_table+NR_INODE ; inode++)
+		if (inode->i_dev==dev && inode->i_count)
+				return -EBUSY;
+	sb->s_imount->i_mount=0;
+	iput(sb->s_imount);
+	sb->s_imount = NULL;
+	iput(sb->s_isup);
+	sb->s_isup = NULL;
+	put_super(dev);
+	sync_dev(dev);
+	return 0;
+}
+
+int sys_mount(char * dev_name, char * dir_name, int rw_flag)
+{
+	struct m_inode * dev_i, * dir_i;
+	struct super_block * sb;
+	int dev;
+
+	if (!(dev_i=namei(dev_name)))
+		return -ENOENT;
+	dev = dev_i->i_zone[0];
+	if (!S_ISBLK(dev_i->i_mode)) {
+		iput(dev_i);
+		return -EPERM;
+	}
+	iput(dev_i);
+	if (!(dir_i=namei(dir_name)))
+		return -ENOENT;
+	if (dir_i->i_count != 1 || dir_i->i_num == ROOT_INO) {
+		iput(dir_i);
+		return -EBUSY;
+	}
+	if (!S_ISDIR(dir_i->i_mode)) {
+		iput(dir_i);
+		return -EPERM;
+	}
+	if (!(sb=read_super(dev))) {
+		iput(dir_i);
+		return -EBUSY;
+	}
+	if (sb->s_imount) {
+		iput(dir_i);
+		return -EBUSY;
+	}
+	if (dir_i->i_mount) {
+		iput(dir_i);
+		return -EPERM;
+	}
+	sb->s_imount=dir_i;
+	dir_i->i_mount=1;
+	dir_i->i_dirt=1;		/* NOTE! we don't iput(dir_i) */
+	return 0;			/* we do that in umount */
 }
 
 void mount_root(void)
@@ -77,13 +249,20 @@ void mount_root(void)
 		panic("bad i-node size");
 	for(i=0;i<NR_FILE;i++)
 		file_table[i].f_count=0;
-	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++)
+	if (MAJOR(ROOT_DEV) == 2) {
+		printk("Insert root floppy and press ENTER");
+		wait_for_keypress();
+	}
+	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
 		p->s_dev = 0;
-	if (!(p=do_mount(ROOT_DEV)))
+		p->s_lock = 0;
+		p->s_wait = NULL;
+	}
+	if (!(p=read_super(ROOT_DEV)))
 		panic("Unable to mount root");
-	if (!(mi=iget(ROOT_DEV,1)))
+	if (!(mi=iget(ROOT_DEV,ROOT_INO)))
 		panic("Unable to read root i-node");
-	mi->i_count += 3 ;      /* NOTE! it is logically used 4 times, not 1 */
+	mi->i_count += 3 ;	/* NOTE! it is logically used 4 times, not 1 */
 	p->s_isup = p->s_imount = mi;
 	current->pwd = mi;
 	current->root = mi;
diff --git a/fs/truncate.c b/fs/truncate.c
index 8d0f98f..f751652 100644
--- a/fs/truncate.c
+++ b/fs/truncate.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/fs/truncate.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <linux/sched.h>
 
 #include <sys/stat.h>
diff --git a/include/asm/segment.h b/include/asm/segment.h
index de0d3ba..d5084b5 100644
--- a/include/asm/segment.h
+++ b/include/asm/segment.h
@@ -63,3 +63,42 @@ extern inline void put_fs_long(unsigned long val,unsigned long * addr)
 		:
 		:"r" (val),"m" (*addr));
 }
+
+/*
+ * Someone who knows GNU asm better than I should double check the followig.
+ * It seems to work, but I don't know if I'm doing something subtly wrong.
+ * --- TYT, 11/24/91
+ * [ nothing wrong here, Linus ]
+ */
+
+extern inline unsigned long get_fs()
+{
+	unsigned short _v;
+
+	__asm__(
+		"mov %%fs,%%ax"
+		:"=a" (_v)
+		:);
+
+	return _v;
+}
+
+extern inline unsigned long get_ds()
+{
+	unsigned short _v;
+
+	__asm__(
+		"mov %%ds,%%ax"
+		:"=a" (_v)
+		:);
+
+	return _v;
+}
+
+extern inline void set_fs(unsigned long val)
+{
+	__asm__(
+		"mov %0,%%fs"
+		:
+		:"a" ((unsigned short) val));
+}
diff --git a/include/ctype.h b/include/ctype.h
index 4043d6e..7acf55d 100644
--- a/include/ctype.h
+++ b/include/ctype.h
@@ -28,7 +28,7 @@ extern char _ctmp;
 #define isascii(c) (((unsigned) c)<=0x7f)
 #define toascii(c) (((unsigned) c)&0x7f)
 
-#define tolower(c) (_ctmp=c,isupper(_ctmp)?_ctmp+('a'+'A'):_ctmp)
-#define toupper(c) (_ctmp=c,islower(_ctmp)?_ctmp+('A'-'a'):_ctmp)
+#define tolower(c) (_ctmp=c,isupper(_ctmp)?_ctmp-('A'-'a'):_ctmp)
+#define toupper(c) (_ctmp=c,islower(_ctmp)?_ctmp-('a'-'A'):_ctmp)
 
 #endif
diff --git a/include/linux/config.h b/include/linux/config.h
index 74748c2..b706122 100644
--- a/include/linux/config.h
+++ b/include/linux/config.h
@@ -1,53 +1,48 @@
 #ifndef _CONFIG_H
 #define _CONFIG_H
 
-/* #define LASU_HD */
-#define LINUS_HD
-
 /*
- * Amount of ram memory (in bytes, 640k-1M not discounted). Currently 8Mb.
- * Don't make this bigger without making sure that there are enough page
- * directory entries (boot/head.s)
+ * The root-device is no longer hard-coded. You can change the default
+ * root-device by changing the line ROOT_DEV = XXX in boot/bootsect.s
  */
-#if     defined(LINUS_HD)
-#define HIGH_MEMORY (0x800000)
-#elif   defined(LASU_HD)
-#define HIGH_MEMORY (0x400000)
-#else
-#error "must define hd"
-#endif
-
-/* End of buffer memory. Must be 0xA0000, or > 0x100000, 4096-byte aligned */
-#if (HIGH_MEMORY>=0x600000)
-#define BUFFER_END 0x200000
-#else
-#define BUFFER_END 0xA0000
-#endif
 
-/* Root device at bootup. */
-#if     defined(LINUS_HD)
-#define ROOT_DEV 0x306
-#elif   defined(LASU_HD)
-#define ROOT_DEV 0x302
-#else
-#error "must define HD"
-#endif
+/*
+ * define your keyboard here -
+ * KBD_FINNISH for Finnish keyboards
+ * KBD_US for US-type
+ * KBD_GR for German keyboards
+ * KBD_FR for Frech keyboard
+ */
+/*#define KBD_US */
+/*#define KBD_GR */
+/*#define KBD_FR */
+#define KBD_FINNISH
 
 /*
- * HD type. If 2, put 2 structures with a comma. If just 1, put
- * only 1 struct. The structs are { HEAD, SECTOR, TRACKS, WPCOM, LZONE, CTL }
+ * Normally, Linux can get the drive parameters from the BIOS at
+ * startup, but if this for some unfathomable reason fails, you'd
+ * be left stranded. For this case, you can define HD_TYPE, which
+ * contains all necessary info on your harddisk.
+ *
+ * The HD_TYPE macro should look like this:
  *
- * NOTE. CTL is supposed to be 0 for drives with less than 8 heads, and
- * 8 if heads >= 8. Don't know why, and I haven't tested it on a drive with
- * more than 8 heads, but that is what the bios-listings seem to imply. I
- * just love not having a manual.
+ * #define HD_TYPE { head, sect, cyl, wpcom, lzone, ctl}
+ *
+ * In case of two harddisks, the info should be sepatated by
+ * commas:
+ *
+ * #define HD_TYPE { h,s,c,wpcom,lz,ctl },{ h,s,c,wpcom,lz,ctl }
  */
-#if     defined(LASU_HD)
-#define HD_TYPE { 7,35,915,65536,920,0 }
-#elif   defined(LINUS_HD)
-#define HD_TYPE { 5,17,980,300,980,0 },{ 5,17,980,300,980,0 }
-#else
-#error "must define a hard-disk type"
-#endif
+/*
+ This is an example, two drives, first is type 2, second is type 3:
+
+#define HD_TYPE { 4,17,615,300,615,8 }, { 6,17,615,300,615,0 }
+
+ NOTE: ctl is 0 for all drives with heads<=8, and ctl=8 for drives
+ with more than 8 heads.
+
+ If you want the BIOS to tell what kind of drive you have, just
+ leave HD_TYPE undefined. This is the normal thing to do.
+*/
 
 #endif
diff --git a/include/linux/fdreg.h b/include/linux/fdreg.h
new file mode 100644
index 0000000..01355af
--- /dev/null
+++ b/include/linux/fdreg.h
@@ -0,0 +1,71 @@
+/*
+ * This file contains some defines for the floppy disk controller.
+ * Various sources. Mostly "IBM Microcomputers: A Programmers
+ * Handbook", Sanches and Canton.
+ */
+#ifndef _FDREG_H
+#define _FDREG_H
+
+extern int ticks_to_floppy_on(unsigned int nr);
+extern void floppy_on(unsigned int nr);
+extern void floppy_off(unsigned int nr);
+extern void floppy_select(unsigned int nr);
+extern void floppy_deselect(unsigned int nr);
+
+/* Fd controller regs. S&C, about page 340 */
+#define FD_STATUS	0x3f4
+#define FD_DATA		0x3f5
+#define FD_DOR		0x3f2		/* Digital Output Register */
+#define FD_DIR		0x3f7		/* Digital Input Register (read) */
+#define FD_DCR		0x3f7		/* Diskette Control Register (write)*/
+
+/* Bits of main status register */
+#define STATUS_BUSYMASK	0x0F		/* drive busy mask */
+#define STATUS_BUSY	0x10		/* FDC busy */
+#define STATUS_DMA	0x20		/* 0- DMA mode */
+#define STATUS_DIR	0x40		/* 0- cpu->fdc */
+#define STATUS_READY	0x80		/* Data reg ready */
+
+/* Bits of FD_ST0 */
+#define ST0_DS		0x03		/* drive select mask */
+#define ST0_HA		0x04		/* Head (Address) */
+#define ST0_NR		0x08		/* Not Ready */
+#define ST0_ECE		0x10		/* Equipment chech error */
+#define ST0_SE		0x20		/* Seek end */
+#define ST0_INTR	0xC0		/* Interrupt code mask */
+
+/* Bits of FD_ST1 */
+#define ST1_MAM		0x01		/* Missing Address Mark */
+#define ST1_WP		0x02		/* Write Protect */
+#define ST1_ND		0x04		/* No Data - unreadable */
+#define ST1_OR		0x10		/* OverRun */
+#define ST1_CRC		0x20		/* CRC error in data or addr */
+#define ST1_EOC		0x80		/* End Of Cylinder */
+
+/* Bits of FD_ST2 */
+#define ST2_MAM		0x01		/* Missing Addess Mark (again) */
+#define ST2_BC		0x02		/* Bad Cylinder */
+#define ST2_SNS		0x04		/* Scan Not Satisfied */
+#define ST2_SEH		0x08		/* Scan Equal Hit */
+#define ST2_WC		0x10		/* Wrong Cylinder */
+#define ST2_CRC		0x20		/* CRC error in data field */
+#define ST2_CM		0x40		/* Control Mark = deleted */
+
+/* Bits of FD_ST3 */
+#define ST3_HA		0x04		/* Head (Address) */
+#define ST3_TZ		0x10		/* Track Zero signal (1=track 0) */
+#define ST3_WP		0x40		/* Write Protect */
+
+/* Values for FD_COMMAND */
+#define FD_RECALIBRATE	0x07		/* move to track 0 */
+#define FD_SEEK		0x0F		/* seek track */
+#define FD_READ		0xE6		/* read with MT, MFM, SKip deleted */
+#define FD_WRITE	0xC5		/* write with MT, MFM */
+#define FD_SENSEI	0x08		/* Sense Interrupt Status */
+#define FD_SPECIFY	0x03		/* specify HUT etc */
+
+/* DMA commands */
+#define DMA_READ	0x46
+#define DMA_WRITE	0x4A
+
+#endif
diff --git a/include/linux/fs.h b/include/linux/fs.h
index c400504..3b3b640 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -21,17 +21,20 @@
  * 7 - unnamed pipes
  */
 
-#define IS_BLOCKDEV(x)	((x)==2 || (x)==3)
+#define IS_SEEKABLE(x)	((x)>=1 && (x)<=3)
 
 #define READ		0
 #define WRITE		1
+#define READA		2	/* read-ahead - don't pause */
+#define WRITEA		3	/* "write-ahead" - silly, but somewhat useful */
 
-void buffer_init(void);
+void buffer_init(long buffer_end);
 
 #define MAJOR(a)	(((unsigned)(a))>>8)
 #define MINOR(a)	((a)&0xff)
 
 #define NAME_LEN	14
+#define ROOT_INO	1
 
 #define I_MAP_SLOTS	8
 #define Z_MAP_SLOTS	8
@@ -44,6 +47,7 @@ void buffer_init(void);
 #define NR_HASH		307
 #define NR_BUFFERS	nr_buffers
 #define BLOCK_SIZE	1024
+#define BLOCK_SIZE_BITS	10
 #ifndef NULL
 #define NULL		((void *) 0)
 #endif
@@ -51,12 +55,20 @@ void buffer_init(void);
 #define INODES_PER_BLOCK	((BLOCK_SIZE)/(sizeof (struct d_inode)))
 #define DIR_ENTRIES_PER_BLOCK	((BLOCK_SIZE)/(sizeof (struct dir_entry)))
 
+#define PIPE_HEAD(inode)	((inode).i_zone[0])
+#define PIPE_TAIL(inode)	((inode).i_zone[1])
+#define PIPE_SIZE(inode)	((PIPE_HEAD(inode)-PIPE_TAIL(inode))&(PAGE_SIZE-1))
+#define PIPE_EMPTY(inode)	(PIPE_HEAD(inode)==PIPE_TAIL(inode))
+#define PIPE_FULL(inode)	(PIPE_SIZE(inode)==(PAGE_SIZE-1))
+#define INC_PIPE(head) \
+	__asm__("incl %0\n\tandl $4095,%0"::"m" (head))
+
 typedef char buffer_block[BLOCK_SIZE];
 
 struct buffer_head {
 	char *			b_data;		/* pointer to data block (1024 bytes) */
+	unsigned long		b_blocknr;	/* block number */
 	unsigned short		b_dev;		/* device (0 = free) */
-	unsigned short		b_blocknr;	/* block number */
 	unsigned char		b_uptodate;
 	unsigned char		b_dirt;		/* 0-clean,1-dirty */
 	unsigned char		b_count;	/* users using this block */
@@ -101,14 +113,6 @@ struct m_inode {
 	unsigned char		i_update;
 };
 
-#define PIPE_HEAD(inode)	(((long *)((inode).i_zone))[0])
-#define PIPE_TAIL(inode)	(((long *)((inode).i_zone))[1])
-#define PIPE_SIZE(inode)	((PIPE_HEAD(inode)-PIPE_TAIL(inode))&(PAGE_SIZE-1))
-#define PIPE_EMPTY(inode)	(PIPE_HEAD(inode)==PIPE_TAIL(inode))
-#define PIPE_FULL(inode)	(PIPE_SIZE(inode)==(PAGE_SIZE-1))
-#define INC_PIPE(head) \
-	__asm__("incl %0\n\tandl $4095,%0"::"m" (head))
-
 struct file {
 	unsigned short		f_mode;
 	unsigned short		f_flags;
@@ -133,10 +137,23 @@ struct super_block {
 	struct m_inode *	s_isup;
 	struct m_inode *	s_imount;
 	unsigned long		s_time;
+	struct task_struct *	s_wait;
+	unsigned char		s_lock;
 	unsigned char		s_rd_only;
 	unsigned char		s_dirt;
 };
 
+struct d_super_block {
+	unsigned short	s_ninodes;
+	unsigned short	s_nzones;
+	unsigned short	s_imap_blocks;
+	unsigned short	s_zmap_blocks;
+	unsigned short	s_firstdatazone;
+	unsigned short	s_log_zone_size;
+	unsigned long	s_max_size;
+	unsigned short	s_magic;
+};
+
 struct dir_entry {
 	unsigned short	inode;
 	char		name[NAME_LEN];
@@ -148,6 +165,11 @@ extern struct super_block super_block[NR_SUPER];
 extern struct buffer_head * start_buffer;
 extern int nr_buffers;
 
+extern void check_disk_change(int dev);
+extern int floppy_change(unsigned int nr);
+extern int ticks_to_floppy_on(unsigned int dev);
+extern void floppy_on(unsigned int dev);
+extern void floppy_off(unsigned int dev);
 extern void truncate(struct m_inode * inode);
 extern void sync_inodes(void);
 extern void wait_on(struct m_inode * inode);
@@ -165,21 +187,16 @@ extern struct buffer_head * getblk(int dev, int block);
 extern void ll_rw_block(int rw, struct buffer_head * bh);
 extern void brelse(struct buffer_head * buf);
 extern struct buffer_head * bread(int dev,int block);
+extern void bread_page(unsigned long addr,int dev,int b[4]);
+extern struct buffer_head * breada(int dev,int block,...);
 extern int new_block(int dev);
 extern void free_block(int dev, int block);
 extern struct m_inode * new_inode(int dev);
 extern void free_inode(struct m_inode * inode);
+extern int sync_dev(int dev);
+extern struct super_block * get_super(int dev);
+extern int ROOT_DEV;
 
 extern void mount_root(void);
 
-extern inline struct super_block * get_super(int dev)
-{
-	struct super_block * s;
-
-	for(s = 0+super_block;s < NR_SUPER+super_block; s++)
-		if (s->s_dev == dev)
-			return s;
-	return NULL;
-}
-
 #endif
diff --git a/include/linux/hdreg.h b/include/linux/hdreg.h
index 4019657..8abb4a0 100644
--- a/include/linux/hdreg.h
+++ b/include/linux/hdreg.h
@@ -6,40 +6,6 @@
 #ifndef _HDREG_H
 #define _HDREG_H
 
-/* currently supports only 1 hd, put type here */
-#define HARD_DISK_TYPE 17
-
-/*
- * Ok, hard-disk-type is currently hardcoded. Not beatiful,
- * but easier. We don't use BIOS for anything else, why should
- * we get HD-type from it? Get these values from Reference Guide.
- */
-
-#if HARD_DISK_TYPE == 17
-#define _CYL    977
-#define _HEAD   5
-#define __WPCOM 300
-#define _LZONE  977
-#define _SECT   17
-#define _CTL    0
-#elif HARD_DISK_TYPE == 18
-#define _CYL    977
-#define _HEAD   7
-#define __WPCOM (-1)
-#define _LZONE  977
-#define _SECT   17
-#define _CTL    0
-#else
-#error Define HARD_DISK_TYPE and parameters, add your own entries as well
-#endif
-
-/* Controller wants just wp-com/4 */
-#if __WPCOM >= 0
-#define _WPCOM ((__WPCOM)>>2)
-#else
-#define _WPCOM __WPCOM
-#endif
-
 /* Hd controller regs. Ref: IBM AT Bios-listing */
 #define HD_DATA		0x1f0		/* _CTL when writing */
 #define HD_ERROR	0x1f1		/* see err-bits */
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 9e533a7..551ed0b 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -6,3 +6,16 @@ volatile void panic(const char * str);
 int printf(const char * fmt, ...);
 int printk(const char * fmt, ...);
 int tty_write(unsigned ch,char * buf,int count);
+void * malloc(unsigned int size);
+void free_s(void * obj, int size);
+
+#define free(x) free_s((x), 0)
+
+/*
+ * This is defined as a macro, but at some point this might become a
+ * real subroutine that sets a flag if it returns true (to do
+ * BSD-style accounting where the process is flagged if it uses root
+ * privs).  The implication of this is that you should do normal
+ * permissions checks first, and check suser() last.
+ */
+#define suser() (current->euid == 0)
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 6d77043..eb4bb2e 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -10,6 +10,7 @@
 #include <linux/head.h>
 #include <linux/fs.h>
 #include <linux/mm.h>
+#include <signal.h>
 
 #if (NR_OPEN > 32)
 #error "Currently the close-on-exec-flags are in one word, max 32 files/proc"
@@ -26,7 +27,7 @@
 #endif
 
 extern int copy_page_tables(unsigned long from, unsigned long to, long size);
-extern int free_page_tables(unsigned long from, long size);
+extern int free_page_tables(unsigned long from, unsigned long size);
 
 extern void sched_init(void);
 extern void schedule(void);
@@ -80,11 +81,11 @@ struct task_struct {
 	long counter;
 	long priority;
 	long signal;
-	fn_ptr sig_restorer;
-	fn_ptr sig_fn[32];
+	struct sigaction sigaction[32];
+	long blocked;	/* bitmap of masked signals */
 /* various fields */
 	int exit_code;
-	unsigned long end_code,end_data,brk,start_stack;
+	unsigned long start_code,end_code,end_data,brk,start_stack;
 	long pid,father,pgrp,session,leader;
 	unsigned short uid,euid,suid;
 	unsigned short gid,egid,sgid;
@@ -96,6 +97,7 @@ struct task_struct {
 	unsigned short umask;
 	struct m_inode * pwd;
 	struct m_inode * root;
+	struct m_inode * executable;
 	unsigned long close_on_exec;
 	struct file * filp[NR_OPEN];
 /* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
@@ -139,6 +141,7 @@ extern long startup_time;
 
 #define CURRENT_TIME (startup_time+jiffies/HZ)
 
+extern void add_timer(long jiffies, void (*fn)(void));
 extern void sleep_on(struct task_struct ** p);
 extern void interruptible_sleep_on(struct task_struct ** p);
 extern void wake_up(struct task_struct ** p);
@@ -169,15 +172,15 @@ __asm__("str %%ax\n\t" \
 struct {long a,b;} __tmp; \
 __asm__("cmpl %%ecx,_current\n\t" \
 	"je 1f\n\t" \
-	"xchgl %%ecx,_current\n\t" \
 	"movw %%dx,%1\n\t" \
+	"xchgl %%ecx,_current\n\t" \
 	"ljmp %0\n\t" \
-	"cmpl %%ecx,%2\n\t" \
+	"cmpl %%ecx,_last_task_used_math\n\t" \
 	"jne 1f\n\t" \
 	"clts\n" \
 	"1:" \
 	::"m" (*&__tmp.a),"m" (*&__tmp.b), \
-	"m" (last_task_used_math),"d" _TSS(n),"c" ((long) task[n])); \
+	"d" (_TSS(n)),"c" ((long) task[n])); \
 }
 
 #define PAGE_ALIGN(n) (((n)+0xfff)&0xfffff000)
diff --git a/include/linux/sys.h b/include/linux/sys.h
index acdcc95..c538fc1 100644
--- a/include/linux/sys.h
+++ b/include/linux/sys.h
@@ -65,6 +65,11 @@ extern int sys_dup2();
 extern int sys_getppid();
 extern int sys_getpgrp();
 extern int sys_setsid();
+extern int sys_sigaction();
+extern int sys_sgetmask();
+extern int sys_ssetmask();
+extern int sys_setreuid();
+extern int sys_setregid();
 
 fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,
 sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,
@@ -77,4 +82,5 @@ sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,
 sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,
 sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,
 sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,
-sys_getpgrp,sys_setsid};
+sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,
+sys_setreuid,sys_setregid };
diff --git a/include/linux/tty.h b/include/linux/tty.h
index 07dba0e..ad846b3 100644
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -33,11 +33,14 @@ struct tty_queue {
 #define PUTCH(c,queue) \
 (void)({(queue).buf[(queue).head]=(c);INC((queue).head);})
 
-#define EOF_CHAR(tty) ((tty)->termios.c_cc[VEOF])
 #define INTR_CHAR(tty) ((tty)->termios.c_cc[VINTR])
-#define STOP_CHAR(tty) ((tty)->termios.c_cc[VSTOP])
-#define START_CHAR(tty) ((tty)->termios.c_cc[VSTART])
+#define QUIT_CHAR(tty) ((tty)->termios.c_cc[VQUIT])
 #define ERASE_CHAR(tty) ((tty)->termios.c_cc[VERASE])
+#define KILL_CHAR(tty) ((tty)->termios.c_cc[VKILL])
+#define EOF_CHAR(tty) ((tty)->termios.c_cc[VEOF])
+#define START_CHAR(tty) ((tty)->termios.c_cc[VSTART])
+#define STOP_CHAR(tty) ((tty)->termios.c_cc[VSTOP])
+#define SUSPEND_CHAR(tty) ((tty)->termios.c_cc[VSUSP])
 
 struct tty_struct {
 	struct termios termios;
@@ -57,7 +60,7 @@ extern struct tty_struct tty_table[];
 	reprint=^R	discard=^U	werase=^W	lnext=^V
 	eol2=\0
 */
-#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\031\0\022\017\027\026\0"
+#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
 
 void rs_init(void);
 void con_init(void);
diff --git a/include/signal.h b/include/signal.h
index 69e3f00..c460bd7 100644
--- a/include/signal.h
+++ b/include/signal.h
@@ -35,6 +35,8 @@ typedef unsigned int sigset_t;		/* 32 bits */
 
 /* Ok, I haven't implemented sigactions, but trying to keep headers POSIX */
 #define SA_NOCLDSTOP	1
+#define SA_NOMASK	0x40000000
+#define SA_ONESHOT	0x80000000
 
 #define SIG_BLOCK		0	/* for blocking signals */
 #define SIG_UNBLOCK		1	/* for unblocking signals */
@@ -47,6 +49,7 @@ struct sigaction {
 	void (*sa_handler)(int);
 	sigset_t sa_mask;
 	int sa_flags;
+	void (*sa_restorer)(void);
 };
 
 void (*signal(int _sig, void (*_func)(int)))(int);
diff --git a/include/string.h b/include/string.h
index 7f97268..494c781 100644
--- a/include/string.h
+++ b/include/string.h
@@ -138,7 +138,7 @@ __asm__("cld\n\t"
 	"movl $1,%1\n"
 	"2:\tmovl %1,%0\n\t"
 	"decl %0"
-	:"=a" (__res):"S" (s),"" (c):"si");
+	:"=a" (__res):"S" (s),"0" (c):"si");
 return __res;
 }
 
@@ -154,7 +154,7 @@ __asm__("cld\n\t"
 	"decl %0\n"
 	"2:\ttestb %%al,%%al\n\t"
 	"jne 1b"
-	:"=d" (__res):"" (0),"S" (s),"a" (c):"ax","si");
+	:"=d" (__res):"0" (0),"S" (s),"a" (c):"ax","si");
 return __res;
 }
 
@@ -177,7 +177,7 @@ __asm__("cld\n\t"
 	"scasb\n\t"
 	"je 1b\n"
 	"2:\tdecl %0"
-	:"=S" (__res):"a" (0),"c" (0xffffffff),"" (cs),"g" (ct)
+	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
 	:"ax","cx","dx","di");
 return __res-cs;
 }
@@ -201,7 +201,7 @@ __asm__("cld\n\t"
 	"scasb\n\t"
 	"jne 1b\n"
 	"2:\tdecl %0"
-	:"=S" (__res):"a" (0),"c" (0xffffffff),"" (cs),"g" (ct)
+	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
 	:"ax","cx","dx","di");
 return __res-cs;
 }
@@ -228,7 +228,7 @@ __asm__("cld\n\t"
 	"jmp 3f\n"
 	"2:\txorl %0,%0\n"
 	"3:"
-	:"=S" (__res):"a" (0),"c" (0xffffffff),"" (cs),"g" (ct)
+	:"=S" (__res):"a" (0),"c" (0xffffffff),"0" (cs),"g" (ct)
 	:"ax","cx","dx","di");
 return __res;
 }
@@ -255,7 +255,7 @@ __asm__("cld\n\t" \
 	"jne 1b\n\t"
 	"xorl %%eax,%%eax\n\t"
 	"2:"
-	:"=a" (__res):"" (0),"c" (0xffffffff),"S" (cs),"g" (ct)
+	:"=a" (__res):"0" (0),"c" (0xffffffff),"S" (cs),"g" (ct)
 	:"cx","dx","di","si");
 return __res;
 }
@@ -268,7 +268,7 @@ __asm__("cld\n\t"
 	"scasb\n\t"
 	"notl %0\n\t"
 	"decl %0"
-	:"=c" (__res):"D" (s),"a" (0),"" (0xffffffff):"di");
+	:"=c" (__res):"D" (s),"a" (0),"0" (0xffffffff):"di");
 return __res;
 }
 
@@ -328,7 +328,7 @@ __asm__("testl %1,%1\n\t"
 	"movl %0,%1\n"
 	"8:"
 	:"=b" (__res),"=S" (___strtok)
-	:"" (___strtok),"1" (s),"g" (ct)
+	:"0" (___strtok),"1" (s),"g" (ct)
 	:"ax","cx","dx","di");
 return __res;
 }
@@ -371,7 +371,7 @@ __asm__("cld\n\t"
 	"jl 1f\n\t"
 	"negl %%eax\n"
 	"1:"
-	:"=a" (__res):"" (0),"D" (cs),"S" (ct),"c" (count)
+	:"=a" (__res):"0" (0),"D" (cs),"S" (ct),"c" (count)
 	:"si","di","cx");
 return __res;
 }
diff --git a/include/unistd.h b/include/unistd.h
index f19f5c7..3803a2b 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -5,7 +5,7 @@
 #define _POSIX_VERSION 198808L
 
 #define _POSIX_CHOWN_RESTRICTED	/* only root can do a chown (I think..) */
-/* #define _POSIX_NO_TRUNC*/	/* pathname truncation (but see in kernel) */
+#define _POSIX_NO_TRUNC		/* no pathname truncation (but see in kernel) */
 #define _POSIX_VDISABLE '\0'	/* character to disable things like ^C */
 /*#define _POSIX_SAVED_IDS */	/* we'll get to this yet */
 /*#define _POSIX_JOB_CONTROL */	/* we aren't there quite yet. Soon hopefully */
@@ -128,12 +128,12 @@
 #define _syscall0(type,name) \
 type name(void) \
 { \
-type __res; \
+long __res; \
 __asm__ volatile ("int $0x80" \
 	: "=a" (__res) \
-	: "" (__NR_##name)); \
+	: "0" (__NR_##name)); \
 if (__res >= 0) \
-	return __res; \
+	return (type) __res; \
 errno = -__res; \
 return -1; \
 }
@@ -141,12 +141,12 @@ return -1; \
 #define _syscall1(type,name,atype,a) \
 type name(atype a) \
 { \
-type __res; \
+long __res; \
 __asm__ volatile ("int $0x80" \
 	: "=a" (__res) \
-	: "" (__NR_##name),"b" (a)); \
+	: "0" (__NR_##name),"b" ((long)(a))); \
 if (__res >= 0) \
-	return __res; \
+	return (type) __res; \
 errno = -__res; \
 return -1; \
 }
@@ -154,12 +154,12 @@ return -1; \
 #define _syscall2(type,name,atype,a,btype,b) \
 type name(atype a,btype b) \
 { \
-type __res; \
+long __res; \
 __asm__ volatile ("int $0x80" \
 	: "=a" (__res) \
-	: "" (__NR_##name),"b" (a),"c" (b)); \
+	: "0" (__NR_##name),"b" ((long)(a)),"c" ((long)(b))); \
 if (__res >= 0) \
-	return __res; \
+	return (type) __res; \
 errno = -__res; \
 return -1; \
 }
@@ -167,13 +167,14 @@ return -1; \
 #define _syscall3(type,name,atype,a,btype,b,ctype,c) \
 type name(atype a,btype b,ctype c) \
 { \
-type __res; \
+long __res; \
 __asm__ volatile ("int $0x80" \
 	: "=a" (__res) \
-	: "" (__NR_##name),"b" (a),"c" (b),"d" (c)); \
-if (__res<0) \
-	errno=-__res , __res = -1; \
-return __res;\
+	: "0" (__NR_##name),"b" ((long)(a)),"c" ((long)(b)),"d" ((long)(c))); \
+if (__res>=0) \
+	return (type) __res; \
+errno=-__res; \
+return -1; \
 }
 
 #endif /* __LIBRARY__ */
diff --git a/init/main.c b/init/main.c
index 2fdb099..6813a7f 100644
--- a/init/main.c
+++ b/init/main.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/init/main.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 #include <time.h>
@@ -16,7 +22,7 @@
  */
 static inline _syscall0(int,fork)
 static inline _syscall0(int,pause)
-static inline _syscall0(int,setup)
+static inline _syscall1(int,setup,void *,BIOS)
 static inline _syscall0(int,sync)
 
 #include <linux/tty.h>
@@ -37,11 +43,23 @@ static char printbuf[1024];
 
 extern int vsprintf();
 extern void init(void);
+extern void blk_dev_init(void);
+extern void chr_dev_init(void);
 extern void hd_init(void);
+extern void floppy_init(void);
+extern void mem_init(long start, long end);
+extern long rd_init(long mem_start, int length);
 extern long kernel_mktime(struct tm * tm);
 extern long startup_time;
 
 /*
+ * This is set up by the setup-routine at boot-time
+ */
+#define EXT_MEM_K (*(unsigned short *)0x90002)
+#define DRIVE_INFO (*(struct drive_info *)0x90080)
+#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)
+
+/*
  * Yeah, yeah, it's ugly, but I cannot find how to do this correctly
  * and this seems to work. I anybody has more info on the real-time
  * clock I'd be interested. Most of this was trial and error, and some
@@ -64,7 +82,7 @@ static void time_init(void)
 		time.tm_min = CMOS_READ(2);
 		time.tm_hour = CMOS_READ(4);
 		time.tm_mday = CMOS_READ(7);
-		time.tm_mon = CMOS_READ(8)-1;
+		time.tm_mon = CMOS_READ(8);
 		time.tm_year = CMOS_READ(9);
 	} while (time.tm_sec != CMOS_READ(0));
 	BCD_TO_BIN(time.tm_sec);
@@ -73,21 +91,48 @@ static void time_init(void)
 	BCD_TO_BIN(time.tm_mday);
 	BCD_TO_BIN(time.tm_mon);
 	BCD_TO_BIN(time.tm_year);
+	time.tm_mon--;
 	startup_time = kernel_mktime(&time);
 }
 
-void main(void)         /* This really IS void, no error here. */
-{                       /* The startup routine assumes (well, ...) this */
+static long memory_end = 0;
+static long buffer_memory_end = 0;
+static long main_memory_start = 0;
+
+struct drive_info { char dummy[32]; } drive_info;
+
+void main(void)		/* This really IS void, no error here. */
+{			/* The startup routine assumes (well, ...) this */
 /*
  * Interrupts are still disabled. Do necessary setups, then
  * enable them
  */
-	time_init();
-	tty_init();
+	ROOT_DEV = ORIG_ROOT_DEV;
+	drive_info = DRIVE_INFO;
+	memory_end = (1<<20) + (EXT_MEM_K<<10);
+	memory_end &= 0xfffff000;
+	if (memory_end > 16*1024*1024)
+		memory_end = 16*1024*1024;
+	if (memory_end > 12*1024*1024)
+		buffer_memory_end = 4*1024*1024;
+	else if (memory_end > 6*1024*1024)
+		buffer_memory_end = 2*1024*1024;
+	else
+		buffer_memory_end = 1*1024*1024;
+	main_memory_start = buffer_memory_end;
+#ifdef RAMDISK
+	main_memory_start += rd_init(main_memory_start, RAMDISK*1024);
+#endif
+	mem_init(main_memory_start,memory_end);
 	trap_init();
+	blk_dev_init();
+	chr_dev_init();
+	tty_init();
+	time_init();
 	sched_init();
-	buffer_init();
+	buffer_init(buffer_memory_end);
 	hd_init();
+	floppy_init();
 	sti();
 	move_to_user_mode();
 	if (!fork()) {		/* we count on this going ok */
@@ -114,34 +159,51 @@ static int printf(const char *fmt, ...)
 	return i;
 }
 
-static char * argv[] = { "-",NULL };
+static char * argv_rc[] = { "/bin/sh", NULL };
+static char * envp_rc[] = { "HOME=/", NULL };
+
+static char * argv[] = { "-/bin/sh",NULL };
 static char * envp[] = { "HOME=/usr/root", NULL };
 
 void init(void)
 {
-	int i,j;
+	int pid,i;
 
-	setup();
-	if (!fork())
-		_exit(execve("/bin/update",NULL,NULL));
+	setup((void *) &drive_info);
 	(void) open("/dev/tty0",O_RDWR,0);
 	(void) dup(0);
 	(void) dup(0);
 	printf("%d buffers = %d bytes buffer space\n\r",NR_BUFFERS,
 		NR_BUFFERS*BLOCK_SIZE);
-	printf(" Ok.\n\r");
-	if ((i=fork())<0)
-		printf("Fork failed in init\r\n");
-	else if (!i) {
-		close(0);close(1);close(2);
-		setsid();
-		(void) open("/dev/tty0",O_RDWR,0);
-		(void) dup(0);
-		(void) dup(0);
-		_exit(execve("/bin/sh",argv,envp));
+	printf("Free mem: %d bytes\n\r",memory_end-main_memory_start);
+	if (!(pid=fork())) {
+		close(0);
+		if (open("/etc/rc",O_RDONLY,0))
+			_exit(1);
+		execve("/bin/sh",argv_rc,envp_rc);
+		_exit(2);
+	}
+	if (pid>0)
+		while (pid != wait(&i))
+			/* nothing */;
+	while (1) {
+		if ((pid=fork())<0) {
+			printf("Fork failed in init\r\n");
+			continue;
+		}
+		if (!pid) {
+			close(0);close(1);close(2);
+			setsid();
+			(void) open("/dev/tty0",O_RDWR,0);
+			(void) dup(0);
+			(void) dup(0);
+			_exit(execve("/bin/sh",argv,envp));
+		}
+		while (1)
+			if (pid == wait(&i))
+				break;
+		printf("\n\rchild %d died with code %04x\n\r",pid,i);
+		sync();
 	}
-	j=wait(&i);
-	printf("child %d died with code %04x\n",j,i);
-	sync();
 	_exit(0);	/* NOTE! _exit, not exit() */
 }
diff --git a/kernel/Makefile b/kernel/Makefile
index 0853767..aa1a271 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -25,29 +25,29 @@ CPP	=gcc -E -nostdinc -I../include
 	-c -o $*.o $<
 
 OBJS  = sched.o system_call.o traps.o asm.o fork.o \
-	panic.o printk.o vsprintf.o tty_io.o console.o \
-	keyboard.o rs_io.o hd.o sys.o exit.o serial.o \
-	mktime.o
+	panic.o printk.o vsprintf.o sys.o exit.o \
+	signal.o mktime.o
 
 kernel.o: $(OBJS)
 	$(LD) -r -o kernel.o $(OBJS)
 	sync
 
 clean:
-	rm -f core *.o *.a tmp_make
+	rm -f core *.o *.a tmp_make keyboard.s
 	for i in *.c;do rm -f `basename $$i .c`.s;done
+	(cd chr_drv; make clean)
+	(cd blk_drv; make clean)
+	(cd math; make clean)
 
 dep:
 	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
 	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
 		$(CPP) -M $$i;done) >> tmp_make
 	cp tmp_make Makefile
+	(cd chr_drv; make dep)
+	(cd blk_drv; make dep)
 
 ### Dependencies:
-console.s console.o : console.c ../include/linux/sched.h ../include/linux/head.h \
-  ../include/linux/fs.h ../include/sys/types.h ../include/linux/mm.h \
-  ../include/linux/tty.h ../include/termios.h ../include/asm/io.h \
-  ../include/asm/system.h
 exit.s exit.o : exit.c ../include/errno.h ../include/signal.h \
   ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \
   ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \
@@ -55,36 +55,29 @@ exit.s exit.o : exit.c ../include/errno.h ../include/signal.h \
   ../include/asm/segment.h
 fork.s fork.o : fork.c ../include/errno.h ../include/linux/sched.h \
   ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/kernel.h ../include/asm/segment.h \
-  ../include/asm/system.h
-hd.s hd.o : hd.c ../include/linux/config.h ../include/linux/sched.h \
-  ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/kernel.h ../include/linux/hdreg.h \
-  ../include/asm/system.h ../include/asm/io.h ../include/asm/segment.h
+  ../include/linux/mm.h ../include/signal.h ../include/linux/kernel.h \
+  ../include/asm/segment.h ../include/asm/system.h
 mktime.s mktime.o : mktime.c ../include/time.h
-panic.s panic.o : panic.c ../include/linux/kernel.h
+panic.s panic.o : panic.c ../include/linux/kernel.h ../include/linux/sched.h \
+  ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
+  ../include/linux/mm.h ../include/signal.h
 printk.s printk.o : printk.c ../include/stdarg.h ../include/stddef.h \
   ../include/linux/kernel.h
 sched.s sched.o : sched.c ../include/linux/sched.h ../include/linux/head.h \
   ../include/linux/fs.h ../include/sys/types.h ../include/linux/mm.h \
-  ../include/linux/kernel.h ../include/signal.h ../include/linux/sys.h \
-  ../include/asm/system.h ../include/asm/io.h ../include/asm/segment.h
-serial.s serial.o : serial.c ../include/linux/tty.h ../include/termios.h \
-  ../include/linux/sched.h ../include/linux/head.h ../include/linux/fs.h \
-  ../include/sys/types.h ../include/linux/mm.h ../include/asm/system.h \
-  ../include/asm/io.h
+  ../include/signal.h ../include/linux/kernel.h ../include/linux/sys.h \
+  ../include/linux/fdreg.h ../include/asm/system.h ../include/asm/io.h \
+  ../include/asm/segment.h
+signal.s signal.o : signal.c ../include/linux/sched.h ../include/linux/head.h \
+  ../include/linux/fs.h ../include/sys/types.h ../include/linux/mm.h \
+  ../include/signal.h ../include/linux/kernel.h ../include/asm/segment.h
 sys.s sys.o : sys.c ../include/errno.h ../include/linux/sched.h \
   ../include/linux/head.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/tty.h ../include/termios.h \
-  ../include/linux/kernel.h ../include/asm/segment.h ../include/sys/times.h \
-  ../include/sys/utsname.h
+  ../include/linux/mm.h ../include/signal.h ../include/linux/tty.h \
+  ../include/termios.h ../include/linux/kernel.h ../include/asm/segment.h \
+  ../include/sys/times.h ../include/sys/utsname.h
 traps.s traps.o : traps.c ../include/string.h ../include/linux/head.h \
   ../include/linux/sched.h ../include/linux/fs.h ../include/sys/types.h \
-  ../include/linux/mm.h ../include/linux/kernel.h ../include/asm/system.h \
-  ../include/asm/segment.h
-tty_io.s tty_io.o : tty_io.c ../include/ctype.h ../include/errno.h \
-  ../include/signal.h ../include/sys/types.h ../include/linux/sched.h \
-  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \
-  ../include/linux/tty.h ../include/termios.h ../include/asm/segment.h \
-  ../include/asm/system.h
+  ../include/linux/mm.h ../include/signal.h ../include/linux/kernel.h \
+  ../include/asm/system.h ../include/asm/segment.h ../include/asm/io.h
 vsprintf.s vsprintf.o : vsprintf.c ../include/stdarg.h ../include/string.h
diff --git a/kernel/asm.s b/kernel/asm.s
index c280803..23ea060 100644
--- a/kernel/asm.s
+++ b/kernel/asm.s
@@ -1,4 +1,10 @@
 /*
+ *  linux/kernel/asm.s
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  * asm.s contains the low-level code for most hardware faults.
  * page_exception is handled by the mm, so that isn't here. This
  * file also handles (hopefully) fpu-exceptions due to TS-bit, as
@@ -6,9 +12,9 @@
  */
 
 .globl _divide_error,_debug,_nmi,_int3,_overflow,_bounds,_invalid_op
-.globl _device_not_available,_double_fault,_coprocessor_segment_overrun
+.globl _double_fault,_coprocessor_segment_overrun
 .globl _invalid_TSS,_segment_not_present,_stack_segment
-.globl _general_protection,_coprocessor_error,_reserved
+.globl _general_protection,_coprocessor_error,_irq13,_reserved
 
 _divide_error:
 	pushl	$_do_divide_error
@@ -68,31 +74,6 @@ _invalid_op:
 	pushl	$_do_invalid_op
 	jmp	no_error_code
 
-math_emulate:
-	popl	%eax
-	pushl	$_do_device_not_available
-	jmp	no_error_code
-_device_not_available:
-	pushl	%eax
-	movl	%cr0,%eax
-	bt	$2,%eax			# EM (math emulation bit)
-	jc	math_emulate
-	clts				# clear TS so that we can use math
-	movl	_current,%eax
-	cmpl	_last_task_used_math,%eax
-	je	1f			# shouldn't happen really ...
-	pushl	%ecx
-	pushl	%edx
-	push	%ds
-	movl	$0x10,%eax
-	mov	%ax,%ds
-	call	_math_state_restore
-	pop	%ds
-	popl	%edx
-	popl	%ecx
-1:	popl	%eax
-	iret
-
 _coprocessor_segment_overrun:
 	pushl	$_do_coprocessor_segment_overrun
 	jmp	no_error_code
@@ -101,9 +82,17 @@ _reserved:
 	pushl	$_do_reserved
 	jmp	no_error_code
 
-_coprocessor_error:
-	pushl	$_do_coprocessor_error
-	jmp	no_error_code
+_irq13:
+	pushl	%eax
+	xorb	%al,%al
+	outb	%al,$0xF0
+	movb	$0x20,%al
+	outb	%al,$0x20
+	jmp	1f
+1:	jmp	1f
+1:	outb	%al,$0xA0
+	popl	%eax
+	jmp	_coprocessor_error
 
 _double_fault:
 	pushl	$_do_double_fault
diff --git a/kernel/blk_drv/Makefile b/kernel/blk_drv/Makefile
new file mode 100644
index 0000000..1303e82
--- /dev/null
+++ b/kernel/blk_drv/Makefile
@@ -0,0 +1,58 @@
+#
+# Makefile for the FREAX-kernel block device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+AR	=gar
+AS	=gas
+LD	=gld
+LDFLAGS	=-s -x
+CC	=gcc
+CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
+	-finline-functions -mstring-insns -nostdinc -I../../include
+CPP	=gcc -E -nostdinc -I../../include
+
+.c.s:
+	$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.s.o:
+	$(AS) -c -o $*.o $<
+.c.o:
+	$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+
+OBJS  = ll_rw_blk.o floppy.o hd.o ramdisk.o
+
+blk_drv.a: $(OBJS)
+	$(AR) rcs blk_drv.a $(OBJS)
+	sync
+
+clean:
+	rm -f core *.o *.a tmp_make
+	for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
+		$(CPP) -M $$i;done) >> tmp_make
+	cp tmp_make Makefile
+
+### Dependencies:
+floppy.s floppy.o : floppy.c ../../include/linux/sched.h ../../include/linux/head.h \
+  ../../include/linux/fs.h ../../include/sys/types.h ../../include/linux/mm.h \
+  ../../include/signal.h ../../include/linux/kernel.h \
+  ../../include/linux/fdreg.h ../../include/asm/system.h \
+  ../../include/asm/io.h ../../include/asm/segment.h blk.h
+hd.s hd.o : hd.c ../../include/linux/config.h ../../include/linux/sched.h \
+  ../../include/linux/head.h ../../include/linux/fs.h \
+  ../../include/sys/types.h ../../include/linux/mm.h ../../include/signal.h \
+  ../../include/linux/kernel.h ../../include/linux/hdreg.h \
+  ../../include/asm/system.h ../../include/asm/io.h \
+  ../../include/asm/segment.h blk.h
+ll_rw_blk.s ll_rw_blk.o : ll_rw_blk.c ../../include/errno.h ../../include/linux/sched.h \
+  ../../include/linux/head.h ../../include/linux/fs.h \
+  ../../include/sys/types.h ../../include/linux/mm.h ../../include/signal.h \
+  ../../include/linux/kernel.h ../../include/asm/system.h blk.h
diff --git a/kernel/blk_drv/blk.h b/kernel/blk_drv/blk.h
new file mode 100644
index 0000000..f7597b0
--- /dev/null
+++ b/kernel/blk_drv/blk.h
@@ -0,0 +1,140 @@
+#ifndef _BLK_H
+#define _BLK_H
+
+#define NR_BLK_DEV	7
+/*
+ * NR_REQUEST is the number of entries in the request-queue.
+ * NOTE that writes may use only the low 2/3 of these: reads
+ * take precedence.
+ *
+ * 32 seems to be a reasonable number: enough to get some benefit
+ * from the elevator-mechanism, but not so much as to lock a lot of
+ * buffers when they are in the queue. 64 seems to be too many (easily
+ * long pauses in reading when heavy writing/syncing is going on)
+ */
+#define NR_REQUEST	32
+
+/*
+ * Ok, this is an expanded form so that we can use the same
+ * request for paging requests when that is implemented. In
+ * paging, 'bh' is NULL, and 'waiting' is used to wait for
+ * read/write completion.
+ */
+struct request {
+	int dev;		/* -1 if no request */
+	int cmd;		/* READ or WRITE */
+	int errors;
+	unsigned long sector;
+	unsigned long nr_sectors;
+	char * buffer;
+	struct task_struct * waiting;
+	struct buffer_head * bh;
+	struct request * next;
+};
+
+/*
+ * This is used in the elevator algorithm: Note that
+ * reads always go before writes. This is natural: reads
+ * are much more time-critical than writes.
+ */
+#define IN_ORDER(s1,s2) \
+((s1)->cmd<(s2)->cmd || (s1)->cmd==(s2)->cmd && \
+((s1)->dev < (s2)->dev || ((s1)->dev == (s2)->dev && \
+(s1)->sector < (s2)->sector)))
+
+struct blk_dev_struct {
+	void (*request_fn)(void);
+	struct request * current_request;
+};
+
+extern struct blk_dev_struct blk_dev[NR_BLK_DEV];
+extern struct request request[NR_REQUEST];
+extern struct task_struct * wait_for_request;
+
+#ifdef MAJOR_NR
+
+/*
+ * Add entries as needed. Currently the only block devices
+ * supported are hard-disks and floppies.
+ */
+
+#if (MAJOR_NR == 1)
+/* ram disk */
+#define DEVICE_NAME "ramdisk"
+#define DEVICE_REQUEST do_rd_request
+#define DEVICE_NR(device) ((device) & 7)
+#define DEVICE_ON(device)
+#define DEVICE_OFF(device)
+
+#elif (MAJOR_NR == 2)
+/* floppy */
+#define DEVICE_NAME "floppy"
+#define DEVICE_INTR do_floppy
+#define DEVICE_REQUEST do_fd_request
+#define DEVICE_NR(device) ((device) & 3)
+#define DEVICE_ON(device) floppy_on(DEVICE_NR(device))
+#define DEVICE_OFF(device) floppy_off(DEVICE_NR(device))
+
+#elif (MAJOR_NR == 3)
+/* harddisk */
+#define DEVICE_NAME "harddisk"
+#define DEVICE_INTR do_hd
+#define DEVICE_REQUEST do_hd_request
+#define DEVICE_NR(device) (MINOR(device)/5)
+#define DEVICE_ON(device)
+#define DEVICE_OFF(device)
+
+#elif
+/* unknown blk device */
+#error "unknown blk device"
+
+#endif
+
+#define CURRENT (blk_dev[MAJOR_NR].current_request)
+#define CURRENT_DEV DEVICE_NR(CURRENT->dev)
+
+#ifdef DEVICE_INTR
+void (*DEVICE_INTR)(void) = NULL;
+#endif
+static void (DEVICE_REQUEST)(void);
+
+extern inline void unlock_buffer(struct buffer_head * bh)
+{
+	if (!bh->b_lock)
+		printk(DEVICE_NAME ": free buffer being unlocked\n");
+	bh->b_lock=0;
+	wake_up(&bh->b_wait);
+}
+
+extern inline void end_request(int uptodate)
+{
+	DEVICE_OFF(CURRENT->dev);
+	if (CURRENT->bh) {
+		CURRENT->bh->b_uptodate = uptodate;
+		unlock_buffer(CURRENT->bh);
+	}
+	if (!uptodate) {
+		printk(DEVICE_NAME " I/O error\n\r");
+		printk("dev %04x, block %d\n\r",CURRENT->dev,
+			CURRENT->bh->b_blocknr);
+	}
+	wake_up(&CURRENT->waiting);
+	wake_up(&wait_for_request);
+	CURRENT->dev = -1;
+	CURRENT = CURRENT->next;
+}
+
+#define INIT_REQUEST \
+repeat: \
+	if (!CURRENT) \
+		return; \
+	if (MAJOR(CURRENT->dev) != MAJOR_NR) \
+		panic(DEVICE_NAME ": request list destroyed"); \
+	if (CURRENT->bh) { \
+		if (!CURRENT->bh->b_lock) \
+			panic(DEVICE_NAME ": block not locked"); \
+	}
+
+#endif
+
+#endif
diff --git a/kernel/blk_drv/floppy.c b/kernel/blk_drv/floppy.c
new file mode 100644
index 0000000..fb608e8
--- /dev/null
+++ b/kernel/blk_drv/floppy.c
@@ -0,0 +1,462 @@
+/*
+ *  linux/kernel/floppy.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ * 02.12.91 - Changed to static variables to indicate need for reset
+ * and recalibrate. This makes some things easier (output_byte reset
+ * checking etc), and means less interrupt jumping in case of errors,
+ * so the code is hopefully easier to understand.
+ */
+
+/*
+ * This file is certainly a mess. I've tried my best to get it working,
+ * but I don't like programming floppies, and I have only one anyway.
+ * Urgel. I should check for more errors, and do more graceful error
+ * recovery. Seems there are problems with several drives. I've tried to
+ * correct them. No promises.
+ */
+
+/*
+ * As with hd.c, all routines within this file can (and will) be called
+ * by interrupts, so extreme caution is needed. A hardware interrupt
+ * handler may not sleep, or a kernel panic will happen. Thus I cannot
+ * call "floppy-on" directly, but have to set a special timer interrupt
+ * etc.
+ *
+ * Also, I'm not certain this works on more than 1 floppy. Bugs may
+ * abund.
+ */
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/fdreg.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/segment.h>
+
+#define MAJOR_NR 2
+#include "blk.h"
+
+static int recalibrate = 0;
+static int reset = 0;
+static int seek = 0;
+
+extern unsigned char current_DOR;
+
+#define immoutb_p(val,port) \
+__asm__("outb %0,%1\n\tjmp 1f\n1:\tjmp 1f\n1:"::"a" ((char) (val)),"i" (port))
+
+#define TYPE(x) ((x)>>2)
+#define DRIVE(x) ((x)&0x03)
+/*
+ * Note that MAX_ERRORS=8 doesn't imply that we retry every bad read
+ * max 8 times - some types of errors increase the errorcount by 2,
+ * so we might actually retry only 5-6 times before giving up.
+ */
+#define MAX_ERRORS 8
+
+/*
+ * globals used by 'result()'
+ */
+#define MAX_REPLIES 7
+static unsigned char reply_buffer[MAX_REPLIES];
+#define ST0 (reply_buffer[0])
+#define ST1 (reply_buffer[1])
+#define ST2 (reply_buffer[2])
+#define ST3 (reply_buffer[3])
+
+/*
+ * This struct defines the different floppy types. Unlike minix
+ * linux doesn't have a "search for right type"-type, as the code
+ * for that is convoluted and weird. I've got enough problems with
+ * this driver as it is.
+ *
+ * The 'stretch' tells if the tracks need to be boubled for some
+ * types (ie 360kB diskette in 1.2MB drive etc). Others should
+ * be self-explanatory.
+ */
+static struct floppy_struct {
+	unsigned int size, sect, head, track, stretch;
+	unsigned char gap,rate,spec1;
+} floppy_type[] = {
+	{    0, 0,0, 0,0,0x00,0x00,0x00 },	/* no testing */
+	{  720, 9,2,40,0,0x2A,0x02,0xDF },	/* 360kB PC diskettes */
+	{ 2400,15,2,80,0,0x1B,0x00,0xDF },	/* 1.2 MB AT-diskettes */
+	{  720, 9,2,40,1,0x2A,0x02,0xDF },	/* 360kB in 720kB drive */
+	{ 1440, 9,2,80,0,0x2A,0x02,0xDF },	/* 3.5" 720kB diskette */
+	{  720, 9,2,40,1,0x23,0x01,0xDF },	/* 360kB in 1.2MB drive */
+	{ 1440, 9,2,80,0,0x23,0x01,0xDF },	/* 720kB in 1.2MB drive */
+	{ 2880,18,2,80,0,0x1B,0x00,0xCF },	/* 1.44MB diskette */
+};
+/*
+ * Rate is 0 for 500kb/s, 2 for 300kbps, 1 for 250kbps
+ * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),
+ * H is head unload time (1=16ms, 2=32ms, etc)
+ *
+ * Spec2 is (HLD<<1 | ND), where HLD is head load time (1=2ms, 2=4 ms etc)
+ * and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).
+ */
+
+extern void floppy_interrupt(void);
+extern char tmp_floppy_area[1024];
+
+/*
+ * These are global variables, as that's the easiest way to give
+ * information to interrupts. They are the data used for the current
+ * request.
+ */
+static int cur_spec1 = -1;
+static int cur_rate = -1;
+static struct floppy_struct * floppy = floppy_type;
+static unsigned char current_drive = 0;
+static unsigned char sector = 0;
+static unsigned char head = 0;
+static unsigned char track = 0;
+static unsigned char seek_track = 0;
+static unsigned char current_track = 255;
+static unsigned char command = 0;
+unsigned char selected = 0;
+struct task_struct * wait_on_floppy_select = NULL;
+
+void floppy_deselect(unsigned int nr)
+{
+	if (nr != (current_DOR & 3))
+		printk("floppy_deselect: drive not selected\n\r");
+	selected = 0;
+	wake_up(&wait_on_floppy_select);
+}
+
+/*
+ * floppy-change is never called from an interrupt, so we can relax a bit
+ * here, sleep etc. Note that floppy-on tries to set current_DOR to point
+ * to the desired drive, but it will probably not survive the sleep if
+ * several floppies are used at the same time: thus the loop.
+ */
+int floppy_change(unsigned int nr)
+{
+repeat:
+	floppy_on(nr);
+	while ((current_DOR & 3) != nr && selected)
+		interruptible_sleep_on(&wait_on_floppy_select);
+	if ((current_DOR & 3) != nr)
+		goto repeat;
+	if (inb(FD_DIR) & 0x80) {
+		floppy_off(nr);
+		return 1;
+	}
+	floppy_off(nr);
+	return 0;
+}
+
+#define copy_buffer(from,to) \
+__asm__("cld ; rep ; movsl" \
+	::"c" (BLOCK_SIZE/4),"S" ((long)(from)),"D" ((long)(to)) \
+	:"cx","di","si")
+
+static void setup_DMA(void)
+{
+	long addr = (long) CURRENT->buffer;
+
+	cli();
+	if (addr >= 0x100000) {
+		addr = (long) tmp_floppy_area;
+		if (command == FD_WRITE)
+			copy_buffer(CURRENT->buffer,tmp_floppy_area);
+	}
+/* mask DMA 2 */
+	immoutb_p(4|2,10);
+/* output command byte. I don't know why, but everyone (minix, */
+/* sanches & canton) output this twice, first to 12 then to 11 */
+	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
+	"outb %%al,$11\n\tjmp 1f\n1:\tjmp 1f\n1:"::
+	"a" ((char) ((command == FD_READ)?DMA_READ:DMA_WRITE)));
+/* 8 low bits of addr */
+	immoutb_p(addr,4);
+	addr >>= 8;
+/* bits 8-15 of addr */
+	immoutb_p(addr,4);
+	addr >>= 8;
+/* bits 16-19 of addr */
+	immoutb_p(addr,0x81);
+/* low 8 bits of count-1 (1024-1=0x3ff) */
+	immoutb_p(0xff,5);
+/* high 8 bits of count-1 */
+	immoutb_p(3,5);
+/* activate DMA 2 */
+	immoutb_p(0|2,10);
+	sti();
+}
+
+static void output_byte(char byte)
+{
+	int counter;
+	unsigned char status;
+
+	if (reset)
+		return;
+	for(counter = 0 ; counter < 10000 ; counter++) {
+		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
+		if (status == STATUS_READY) {
+			outb(byte,FD_DATA);
+			return;
+		}
+	}
+	reset = 1;
+	printk("Unable to send byte to FDC\n\r");
+}
+
+static int result(void)
+{
+	int i = 0, counter, status;
+
+	if (reset)
+		return -1;
+	for (counter = 0 ; counter < 10000 ; counter++) {
+		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
+		if (status == STATUS_READY)
+			return i;
+		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
+			if (i >= MAX_REPLIES)
+				break;
+			reply_buffer[i++] = inb_p(FD_DATA);
+		}
+	}
+	reset = 1;
+	printk("Getstatus times out\n\r");
+	return -1;
+}
+
+static void bad_flp_intr(void)
+{
+	CURRENT->errors++;
+	if (CURRENT->errors > MAX_ERRORS) {
+		floppy_deselect(current_drive);
+		end_request(0);
+	}
+	if (CURRENT->errors > MAX_ERRORS/2)
+		reset = 1;
+	else
+		recalibrate = 1;
+}
+
+/*
+ * Ok, this interrupt is called after a DMA read/write has succeeded,
+ * so we check the results, and copy any buffers.
+ */
+static void rw_interrupt(void)
+{
+	if (result() != 7 || (ST0 & 0xf8) || (ST1 & 0xbf) || (ST2 & 0x73)) {
+		if (ST1 & 0x02) {
+			printk("Drive %d is write protected\n\r",current_drive);
+			floppy_deselect(current_drive);
+			end_request(0);
+		} else
+			bad_flp_intr();
+		do_fd_request();
+		return;
+	}
+	if (command == FD_READ && (unsigned long)(CURRENT->buffer) >= 0x100000)
+		copy_buffer(tmp_floppy_area,CURRENT->buffer);
+	floppy_deselect(current_drive);
+	end_request(1);
+	do_fd_request();
+}
+
+inline void setup_rw_floppy(void)
+{
+	setup_DMA();
+	do_floppy = rw_interrupt;
+	output_byte(command);
+	output_byte(head<<2 | current_drive);
+	output_byte(track);
+	output_byte(head);
+	output_byte(sector);
+	output_byte(2);		/* sector size = 512 */
+	output_byte(floppy->sect);
+	output_byte(floppy->gap);
+	output_byte(0xFF);	/* sector size (0xff when n!=0 ?) */
+	if (reset)
+		do_fd_request();
+}
+
+/*
+ * This is the routine called after every seek (or recalibrate) interrupt
+ * from the floppy controller. Note that the "unexpected interrupt" routine
+ * also does a recalibrate, but doesn't come here.
+ */
+static void seek_interrupt(void)
+{
+/* sense drive status */
+	output_byte(FD_SENSEI);
+	if (result() != 2 || (ST0 & 0xF8) != 0x20 || ST1 != seek_track) {
+		bad_flp_intr();
+		do_fd_request();
+		return;
+	}
+	current_track = ST1;
+	setup_rw_floppy();
+}
+
+/*
+ * This routine is called when everything should be correctly set up
+ * for the transfer (ie floppy motor is on and the correct floppy is
+ * selected).
+ */
+static void transfer(void)
+{
+	if (cur_spec1 != floppy->spec1) {
+		cur_spec1 = floppy->spec1;
+		output_byte(FD_SPECIFY);
+		output_byte(cur_spec1);		/* hut etc */
+		output_byte(6);			/* Head load time =6ms, DMA */
+	}
+	if (cur_rate != floppy->rate)
+		outb_p(cur_rate = floppy->rate,FD_DCR);
+	if (reset) {
+		do_fd_request();
+		return;
+	}
+	if (!seek) {
+		setup_rw_floppy();
+		return;
+	}
+	do_floppy = seek_interrupt;
+	if (seek_track) {
+		output_byte(FD_SEEK);
+		output_byte(head<<2 | current_drive);
+		output_byte(seek_track);
+	} else {
+		output_byte(FD_RECALIBRATE);
+		output_byte(head<<2 | current_drive);
+	}
+	if (reset)
+		do_fd_request();
+}
+
+/*
+ * Special case - used after a unexpected interrupt (or reset)
+ */
+static void recal_interrupt(void)
+{
+	output_byte(FD_SENSEI);
+	if (result()!=2 || (ST0 & 0xE0) == 0x60)
+		reset = 1;
+	else
+		recalibrate = 0;
+	do_fd_request();
+}
+
+void unexpected_floppy_interrupt(void)
+{
+	output_byte(FD_SENSEI);
+	if (result()!=2 || (ST0 & 0xE0) == 0x60)
+		reset = 1;
+	else
+		recalibrate = 1;
+}
+
+static void recalibrate_floppy(void)
+{
+	recalibrate = 0;
+	current_track = 0;
+	do_floppy = recal_interrupt;
+	output_byte(FD_RECALIBRATE);
+	output_byte(head<<2 | current_drive);
+	if (reset)
+		do_fd_request();
+}
+
+static void reset_interrupt(void)
+{
+	output_byte(FD_SENSEI);
+	(void) result();
+	output_byte(FD_SPECIFY);
+	output_byte(cur_spec1);		/* hut etc */
+	output_byte(6);			/* Head load time =6ms, DMA */
+	do_fd_request();
+}
+
+/*
+ * reset is done by pulling bit 2 of DOR low for a while.
+ */
+static void reset_floppy(void)
+{
+	int i;
+
+	reset = 0;
+	cur_spec1 = -1;
+	cur_rate = -1;
+	recalibrate = 1;
+	printk("Reset-floppy called\n\r");
+	cli();
+	do_floppy = reset_interrupt;
+	outb_p(current_DOR & ~0x04,FD_DOR);
+	for (i=0 ; i<100 ; i++)
+		__asm__("nop");
+	outb(current_DOR,FD_DOR);
+	sti();
+}
+
+static void floppy_on_interrupt(void)
+{
+/* We cannot do a floppy-select, as that might sleep. We just force it */
+	selected = 1;
+	if (current_drive != (current_DOR & 3)) {
+		current_DOR &= 0xFC;
+		current_DOR |= current_drive;
+		outb(current_DOR,FD_DOR);
+		add_timer(2,&transfer);
+	} else
+		transfer();
+}
+
+void do_fd_request(void)
+{
+	unsigned int block;
+
+	seek = 0;
+	if (reset) {
+		reset_floppy();
+		return;
+	}
+	if (recalibrate) {
+		recalibrate_floppy();
+		return;
+	}
+	INIT_REQUEST;
+	floppy = (MINOR(CURRENT->dev)>>2) + floppy_type;
+	if (current_drive != CURRENT_DEV)
+		seek = 1;
+	current_drive = CURRENT_DEV;
+	block = CURRENT->sector;
+	if (block+2 > floppy->size) {
+		end_request(0);
+		goto repeat;
+	}
+	sector = block % floppy->sect;
+	block /= floppy->sect;
+	head = block % floppy->head;
+	track = block / floppy->head;
+	seek_track = track << floppy->stretch;
+	if (seek_track != current_track)
+		seek = 1;
+	sector++;
+	if (CURRENT->cmd == READ)
+		command = FD_READ;
+	else if (CURRENT->cmd == WRITE)
+		command = FD_WRITE;
+	else
+		panic("do_fd_request: unknown command");
+	add_timer(ticks_to_floppy_on(current_drive),&floppy_on_interrupt);
+}
+
+void floppy_init(void)
+{
+	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
+	set_trap_gate(0x26,&floppy_interrupt);
+	outb(inb_p(0x21)&~0x40,0x21);
+}
diff --git a/kernel/blk_drv/hd.c b/kernel/blk_drv/hd.c
new file mode 100644
index 0000000..7bb72e9
--- /dev/null
+++ b/kernel/blk_drv/hd.c
@@ -0,0 +1,350 @@
+/*
+ *  linux/kernel/hd.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ * This is the low-level hd interrupt support. It traverses the
+ * request-list, using interrupts to jump between functions. As
+ * all the functions are called within interrupts, we may not
+ * sleep. Special care is recommended.
+ *
+ *  modified by Drew Eckhardt to check nr of hd's from the CMOS.
+ */
+
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/hdreg.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/segment.h>
+
+#define MAJOR_NR 3
+#include "blk.h"
+
+#define CMOS_READ(addr) ({ \
+outb_p(0x80|addr,0x70); \
+inb_p(0x71); \
+})
+
+/* Max read/write errors/sector */
+#define MAX_ERRORS	7
+#define MAX_HD		2
+
+static void recal_intr(void);
+
+static int recalibrate = 1;
+static int reset = 1;
+
+/*
+ *  This struct defines the HD's and their types.
+ */
+struct hd_i_struct {
+	int head,sect,cyl,wpcom,lzone,ctl;
+	};
+#ifdef HD_TYPE
+struct hd_i_struct hd_info[] = { HD_TYPE };
+#define NR_HD ((sizeof (hd_info))/(sizeof (struct hd_i_struct)))
+#else
+struct hd_i_struct hd_info[] = { {0,0,0,0,0,0},{0,0,0,0,0,0} };
+static int NR_HD = 0;
+#endif
+
+static struct hd_struct {
+	long start_sect;
+	long nr_sects;
+} hd[5*MAX_HD]={{0,0},};
+
+#define port_read(port,buf,nr) \
+__asm__("cld;rep;insw"::"d" (port),"D" (buf),"c" (nr):"cx","di")
+
+#define port_write(port,buf,nr) \
+__asm__("cld;rep;outsw"::"d" (port),"S" (buf),"c" (nr):"cx","si")
+
+extern void hd_interrupt(void);
+extern void rd_load(void);
+
+/* This may be used only once, enforced by 'static int callable' */
+int sys_setup(void * BIOS)
+{
+	static int callable = 1;
+	int i,drive;
+	unsigned char cmos_disks;
+	struct partition *p;
+	struct buffer_head * bh;
+
+	if (!callable)
+		return -1;
+	callable = 0;
+#ifndef HD_TYPE
+	for (drive=0 ; drive<2 ; drive++) {
+		hd_info[drive].cyl = *(unsigned short *) BIOS;
+		hd_info[drive].head = *(unsigned char *) (2+BIOS);
+		hd_info[drive].wpcom = *(unsigned short *) (5+BIOS);
+		hd_info[drive].ctl = *(unsigned char *) (8+BIOS);
+		hd_info[drive].lzone = *(unsigned short *) (12+BIOS);
+		hd_info[drive].sect = *(unsigned char *) (14+BIOS);
+		BIOS += 16;
+	}
+	if (hd_info[1].cyl)
+		NR_HD=2;
+	else
+		NR_HD=1;
+#endif
+	for (i=0 ; i<NR_HD ; i++) {
+		hd[i*5].start_sect = 0;
+		hd[i*5].nr_sects = hd_info[i].head*
+				hd_info[i].sect*hd_info[i].cyl;
+	}
+
+	/*
+		We querry CMOS about hard disks : it could be that
+		we have a SCSI/ESDI/etc controller that is BIOS
+		compatable with ST-506, and thus showing up in our
+		BIOS table, but not register compatable, and therefore
+		not present in CMOS.
+
+		Furthurmore, we will assume that our ST-506 drives
+		<if any> are the primary drives in the system, and
+		the ones reflected as drive 1 or 2.
+
+		The first drive is stored in the high nibble of CMOS
+		byte 0x12, the second in the low nibble.  This will be
+		either a 4 bit drive type or 0xf indicating use byte 0x19
+		for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.
+
+		Needless to say, a non-zero value means we have
+		an AT controller hard disk for that drive.
+
+
+	*/
+
+	if ((cmos_disks = CMOS_READ(0x12)) & 0xf0)
+		if (cmos_disks & 0x0f)
+			NR_HD = 2;
+		else
+			NR_HD = 1;
+	else
+		NR_HD = 0;
+	for (i = NR_HD ; i < 2 ; i++) {
+		hd[i*5].start_sect = 0;
+		hd[i*5].nr_sects = 0;
+	}
+	for (drive=0 ; drive<NR_HD ; drive++) {
+		if (!(bh = bread(0x300 + drive*5,0))) {
+			printk("Unable to read partition table of drive %d\n\r",
+				drive);
+			panic("");
+		}
+		if (bh->b_data[510] != 0x55 || (unsigned char)
+				bh->b_data[511] != 0xAA) {
+			printk("Bad partition table on drive %d\n\r",drive);
+			panic("");
+		}
+		p = 0x1BE + (void *)bh->b_data;
+		for (i=1;i<5;i++,p++) {
+			hd[i+5*drive].start_sect = p->start_sect;
+			hd[i+5*drive].nr_sects = p->nr_sects;
+		}
+		brelse(bh);
+	}
+	if (NR_HD)
+		printk("Partition table%s ok.\n\r",(NR_HD>1)?"s":"");
+	rd_load();
+	mount_root();
+	return (0);
+}
+
+static int controller_ready(void)
+{
+	int retries=10000;
+
+	while (--retries && (inb_p(HD_STATUS)&0xc0)!=0x40);
+	return (retries);
+}
+
+static int win_result(void)
+{
+	int i=inb_p(HD_STATUS);
+
+	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
+			== (READY_STAT | SEEK_STAT))
+		return(0); /* ok */
+	if (i&1)
+		i=inb(HD_ERROR);
+	return (1);
+}
+
+static void hd_out(unsigned int drive,unsigned int nsect,unsigned int sect,
+		unsigned int head,unsigned int cyl,unsigned int cmd,
+		void (*intr_addr)(void))
+{
+	register int port asm("dx");
+
+	if (drive>1 || head>15)
+		panic("Trying to write bad sector");
+	if (!controller_ready())
+		panic("HD controller not ready");
+	do_hd = intr_addr;
+	outb_p(hd_info[drive].ctl,HD_CMD);
+	port=HD_DATA;
+	outb_p(hd_info[drive].wpcom>>2,++port);
+	outb_p(nsect,++port);
+	outb_p(sect,++port);
+	outb_p(cyl,++port);
+	outb_p(cyl>>8,++port);
+	outb_p(0xA0|(drive<<4)|head,++port);
+	outb(cmd,++port);
+}
+
+static int drive_busy(void)
+{
+	unsigned int i;
+
+	for (i = 0; i < 10000; i++)
+		if (READY_STAT == (inb_p(HD_STATUS) & (BUSY_STAT|READY_STAT)))
+			break;
+	i = inb(HD_STATUS);
+	i &= BUSY_STAT | READY_STAT | SEEK_STAT;
+	if (i == READY_STAT | SEEK_STAT)
+		return(0);
+	printk("HD controller times out\n\r");
+	return(1);
+}
+
+static void reset_controller(void)
+{
+	int i;
+
+	outb(4,HD_CMD);
+	for(i = 0; i < 100; i++) nop();
+	outb(hd_info[0].ctl & 0x0f ,HD_CMD);
+	if (drive_busy())
+		printk("HD-controller still busy\n\r");
+	if ((i = inb(HD_ERROR)) != 1)
+		printk("HD-controller reset failed: %02x\n\r",i);
+}
+
+static void reset_hd(int nr)
+{
+	reset_controller();
+	hd_out(nr,hd_info[nr].sect,hd_info[nr].sect,hd_info[nr].head-1,
+		hd_info[nr].cyl,WIN_SPECIFY,&recal_intr);
+}
+
+void unexpected_hd_interrupt(void)
+{
+	printk("Unexpected HD interrupt\n\r");
+}
+
+static void bad_rw_intr(void)
+{
+	if (++CURRENT->errors >= MAX_ERRORS)
+		end_request(0);
+	if (CURRENT->errors > MAX_ERRORS/2)
+		reset = 1;
+}
+
+static void read_intr(void)
+{
+	if (win_result()) {
+		bad_rw_intr();
+		do_hd_request();
+		return;
+	}
+	port_read(HD_DATA,CURRENT->buffer,256);
+	CURRENT->errors = 0;
+	CURRENT->buffer += 512;
+	CURRENT->sector++;
+	if (--CURRENT->nr_sectors) {
+		do_hd = &read_intr;
+		return;
+	}
+	end_request(1);
+	do_hd_request();
+}
+
+static void write_intr(void)
+{
+	if (win_result()) {
+		bad_rw_intr();
+		do_hd_request();
+		return;
+	}
+	if (--CURRENT->nr_sectors) {
+		CURRENT->sector++;
+		CURRENT->buffer += 512;
+		do_hd = &write_intr;
+		port_write(HD_DATA,CURRENT->buffer,256);
+		return;
+	}
+	end_request(1);
+	do_hd_request();
+}
+
+static void recal_intr(void)
+{
+	if (win_result())
+		bad_rw_intr();
+	do_hd_request();
+}
+
+void do_hd_request(void)
+{
+	int i,r;
+	unsigned int block,dev;
+	unsigned int sec,head,cyl;
+	unsigned int nsect;
+
+	INIT_REQUEST;
+	dev = MINOR(CURRENT->dev);
+	block = CURRENT->sector;
+	if (dev >= 5*NR_HD || block+2 > hd[dev].nr_sects) {
+		end_request(0);
+		goto repeat;
+	}
+	block += hd[dev].start_sect;
+	dev /= 5;
+	__asm__("divl %4":"=a" (block),"=d" (sec):"0" (block),"1" (0),
+		"r" (hd_info[dev].sect));
+	__asm__("divl %4":"=a" (cyl),"=d" (head):"0" (block),"1" (0),
+		"r" (hd_info[dev].head));
+	sec++;
+	nsect = CURRENT->nr_sectors;
+	if (reset) {
+		reset = 0;
+		recalibrate = 1;
+		reset_hd(CURRENT_DEV);
+		return;
+	}
+	if (recalibrate) {
+		recalibrate = 0;
+		hd_out(dev,hd_info[CURRENT_DEV].sect,0,0,0,
+			WIN_RESTORE,&recal_intr);
+		return;
+	}
+	if (CURRENT->cmd == WRITE) {
+		hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&write_intr);
+		for(i=0 ; i<3000 && !(r=inb_p(HD_STATUS)&DRQ_STAT) ; i++)
+			/* nothing */ ;
+		if (!r) {
+			bad_rw_intr();
+			goto repeat;
+		}
+		port_write(HD_DATA,CURRENT->buffer,256);
+	} else if (CURRENT->cmd == READ) {
+		hd_out(dev,nsect,sec,head,cyl,WIN_READ,&read_intr);
+	} else
+		panic("unknown hd-command");
+}
+
+void hd_init(void)
+{
+	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
+	set_intr_gate(0x2E,&hd_interrupt);
+	outb_p(inb_p(0x21)&0xfb,0x21);
+	outb(inb_p(0xA1)&0xbf,0xA1);
+}
diff --git a/kernel/blk_drv/ll_rw_blk.c b/kernel/blk_drv/ll_rw_blk.c
new file mode 100644
index 0000000..91496f0
--- /dev/null
+++ b/kernel/blk_drv/ll_rw_blk.c
@@ -0,0 +1,165 @@
+/*
+ *  linux/kernel/blk_dev/ll_rw.c
+ *
+ * (C) 1991 Linus Torvalds
+ */
+
+/*
+ * This handles all read/write requests to block devices
+ */
+#include <errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <asm/system.h>
+
+#include "blk.h"
+
+/*
+ * The request-struct contains all necessary data
+ * to load a nr of sectors into memory
+ */
+struct request request[NR_REQUEST];
+
+/*
+ * used to wait on when there are no free requests
+ */
+struct task_struct * wait_for_request = NULL;
+
+/* blk_dev_struct is:
+ *	do_request-address
+ *	next-request
+ */
+struct blk_dev_struct blk_dev[NR_BLK_DEV] = {
+	{ NULL, NULL },		/* no_dev */
+	{ NULL, NULL },		/* dev mem */
+	{ NULL, NULL },		/* dev fd */
+	{ NULL, NULL },		/* dev hd */
+	{ NULL, NULL },		/* dev ttyx */
+	{ NULL, NULL },		/* dev tty */
+	{ NULL, NULL }		/* dev lp */
+};
+
+static inline void lock_buffer(struct buffer_head * bh)
+{
+	cli();
+	while (bh->b_lock)
+		sleep_on(&bh->b_wait);
+	bh->b_lock=1;
+	sti();
+}
+
+static inline void unlock_buffer(struct buffer_head * bh)
+{
+	if (!bh->b_lock)
+		printk("ll_rw_block.c: buffer not locked\n\r");
+	bh->b_lock = 0;
+	wake_up(&bh->b_wait);
+}
+
+/*
+ * add-request adds a request to the linked list.
+ * It disables interrupts so that it can muck with the
+ * request-lists in peace.
+ */
+static void add_request(struct blk_dev_struct * dev, struct request * req)
+{
+	struct request * tmp;
+
+	req->next = NULL;
+	cli();
+	if (req->bh)
+		req->bh->b_dirt = 0;
+	if (!(tmp = dev->current_request)) {
+		dev->current_request = req;
+		sti();
+		(dev->request_fn)();
+		return;
+	}
+	for ( ; tmp->next ; tmp = tmp->next)
+		if ((IN_ORDER(tmp,req) ||
+		    !IN_ORDER(tmp,tmp->next)) &&
+		    IN_ORDER(req,tmp->next))
+			break;
+	req->next = tmp->next;
+	tmp->next = req;
+	sti();
+}
+
+static void make_request(int major,int rw, struct buffer_head * bh)
+{
+	struct request * req;
+	int rw_ahead;
+
+/* WRITEA/READA is special case - it is not really needed, so if the */
+/* buffer is locked, we just forget about it, else it's a normal read */
+	if (rw_ahead = (rw == READA || rw == WRITEA)) {
+		if (bh->b_lock)
+			return;
+		if (rw == READA)
+			rw = READ;
+		else
+			rw = WRITE;
+	}
+	if (rw!=READ && rw!=WRITE)
+		panic("Bad block dev command, must be R/W/RA/WA");
+	lock_buffer(bh);
+	if ((rw == WRITE && !bh->b_dirt) || (rw == READ && bh->b_uptodate)) {
+		unlock_buffer(bh);
+		return;
+	}
+repeat:
+/* we don't allow the write-requests to fill up the queue completely:
+ * we want some room for reads: they take precedence. The last third
+ * of the requests are only for reads.
+ */
+	if (rw == READ)
+		req = request+NR_REQUEST;
+	else
+		req = request+((NR_REQUEST*2)/3);
+/* find an empty request */
+	while (--req >= request)
+		if (req->dev<0)
+			break;
+/* if none found, sleep on new requests: check for rw_ahead */
+	if (req < request) {
+		if (rw_ahead) {
+			unlock_buffer(bh);
+			return;
+		}
+		sleep_on(&wait_for_request);
+		goto repeat;
+	}
+/* fill up the request-info, and add it to the queue */
+	req->dev = bh->b_dev;
+	req->cmd = rw;
+	req->errors=0;
+	req->sector = bh->b_blocknr<<1;
+	req->nr_sectors = 2;
+	req->buffer = bh->b_data;
+	req->waiting = NULL;
+	req->bh = bh;
+	req->next = NULL;
+	add_request(major+blk_dev,req);
+}
+
+void ll_rw_block(int rw, struct buffer_head * bh)
+{
+	unsigned int major;
+
+	if ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
+			!(blk_dev[major].request_fn)) {
+		printk("Trying to read nonexistent block-device\n\r");
+		return;
+	}
+	make_request(major,rw,bh);
+}
+
+void blk_dev_init(void)
+{
+	int i;
+
+	for (i=0 ; i<NR_REQUEST ; i++) {
+		request[i].dev = -1;
+		request[i].next = NULL;
+	}
+}
diff --git a/kernel/blk_drv/ramdisk.c b/kernel/blk_drv/ramdisk.c
new file mode 100644
index 0000000..428e36a
--- /dev/null
+++ b/kernel/blk_drv/ramdisk.c
@@ -0,0 +1,125 @@
+/*
+ *  linux/kernel/blk_drv/ramdisk.c
+ *
+ *  Written by Theodore Ts'o, 12/2/91
+ */
+
+#include <string.h>
+
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <asm/system.h>
+#include <asm/segment.h>
+#include <asm/memory.h>
+
+#define MAJOR_NR 1
+#include "blk.h"
+
+char	*rd_start;
+int	rd_length = 0;
+
+void do_rd_request(void)
+{
+	int	len;
+	char	*addr;
+
+	INIT_REQUEST;
+	addr = rd_start + (CURRENT->sector << 9);
+	len = CURRENT->nr_sectors << 9;
+	if ((MINOR(CURRENT->dev) != 1) || (addr+len > rd_start+rd_length)) {
+		end_request(0);
+		goto repeat;
+	}
+	if (CURRENT-> cmd == WRITE) {
+		(void ) memcpy(addr,
+				CURRENT->buffer,
+				len);
+	} else if (CURRENT->cmd == READ) {
+		(void) memcpy(CURRENT->buffer,
+				addr,
+				len);
+	} else
+		panic("unknown ramdisk-command");
+	end_request(1);
+	goto repeat;
+}
+
+/*
+ * Returns amount of memory which needs to be reserved.
+ */
+long rd_init(long mem_start, int length)
+{
+	int	i;
+	char	*cp;
+
+	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
+	rd_start = (char *) mem_start;
+	rd_length = length;
+	cp = rd_start;
+	for (i=0; i < length; i++)
+		*cp++ = '\0';
+	return(length);
+}
+
+/*
+ * If the root device is the ram disk, try to load it.
+ * In order to do this, the root device is originally set to the
+ * floppy, and we later change it to be ram disk.
+ */
+void rd_load(void)
+{
+	struct buffer_head *bh;
+	struct super_block	s;
+	int		block = 256;	/* Start at block 256 */
+	int		i = 1;
+	int		nblocks;
+	char		*cp;		/* Move pointer */
+
+	if (!rd_length)
+		return;
+	printk("Ram disk: %d bytes, starting at 0x%x\n", rd_length,
+		(int) rd_start);
+	if (MAJOR(ROOT_DEV) != 2)
+		return;
+	bh = breada(ROOT_DEV,block+1,block,block+2,-1);
+	if (!bh) {
+		printk("Disk error while looking for ramdisk!\n");
+		return;
+	}
+	*((struct d_super_block *) &s) = *((struct d_super_block *) bh->b_data);
+	brelse(bh);
+	if (s.s_magic != SUPER_MAGIC)
+		/* No ram disk image present, assume normal floppy boot */
+		return;
+	nblocks = s.s_nzones << s.s_log_zone_size;
+	if (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {
+		printk("Ram disk image too big!  (%d blocks, %d avail)\n",
+			nblocks, rd_length >> BLOCK_SIZE_BITS);
+		return;
+	}
+	printk("Loading %d bytes into ram disk... 0000k",
+		nblocks << BLOCK_SIZE_BITS);
+	cp = rd_start;
+	while (nblocks) {
+		if (nblocks > 2)
+			bh = breada(ROOT_DEV, block, block+1, block+2, -1);
+		else
+			bh = bread(ROOT_DEV, block);
+		if (!bh) {
+			printk("I/O error on block %d, aborting load\n",
+				block);
+			return;
+		}
+		(void) memcpy(cp, bh->b_data, BLOCK_SIZE);
+		brelse(bh);
+		printk("\010\010\010\010\010%4dk",i);
+		cp += BLOCK_SIZE;
+		block++;
+		nblocks--;
+		i++;
+	}
+	printk("\010\010\010\010\010done \n");
+	ROOT_DEV=0x0101;
+}
diff --git a/kernel/chr_drv/Makefile b/kernel/chr_drv/Makefile
new file mode 100644
index 0000000..0507558
--- /dev/null
+++ b/kernel/chr_drv/Makefile
@@ -0,0 +1,68 @@
+#
+# Makefile for the FREAX-kernel character device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+AR	=gar
+AS	=gas
+LD	=gld
+LDFLAGS	=-s -x
+CC	=gcc
+CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
+	-finline-functions -mstring-insns -nostdinc -I../../include
+CPP	=gcc -E -nostdinc -I../../include
+
+.c.s:
+	$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.s.o:
+	$(AS) -c -o $*.o $<
+.c.o:
+	$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+
+OBJS  = tty_io.o console.o keyboard.o serial.o rs_io.o \
+	tty_ioctl.o
+
+chr_drv.a: $(OBJS)
+	$(AR) rcs chr_drv.a $(OBJS)
+	sync
+
+keyboard.s: keyboard.S ../../include/linux/config.h
+	$(CPP) -traditional keyboard.S -o keyboard.s
+
+clean:
+	rm -f core *.o *.a tmp_make keyboard.s
+	for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
+		$(CPP) -M $$i;done) >> tmp_make
+	cp tmp_make Makefile
+
+### Dependencies:
+console.s console.o : console.c ../../include/linux/sched.h \
+  ../../include/linux/head.h ../../include/linux/fs.h \
+  ../../include/sys/types.h ../../include/linux/mm.h ../../include/signal.h \
+  ../../include/linux/tty.h ../../include/termios.h ../../include/asm/io.h \
+  ../../include/asm/system.h
+serial.s serial.o : serial.c ../../include/linux/tty.h ../../include/termios.h \
+  ../../include/linux/sched.h ../../include/linux/head.h \
+  ../../include/linux/fs.h ../../include/sys/types.h ../../include/linux/mm.h \
+  ../../include/signal.h ../../include/asm/system.h ../../include/asm/io.h
+tty_io.s tty_io.o : tty_io.c ../../include/ctype.h ../../include/errno.h \
+  ../../include/signal.h ../../include/sys/types.h \
+  ../../include/linux/sched.h ../../include/linux/head.h \
+  ../../include/linux/fs.h ../../include/linux/mm.h ../../include/linux/tty.h \
+  ../../include/termios.h ../../include/asm/segment.h \
+  ../../include/asm/system.h
+tty_ioctl.s tty_ioctl.o : tty_ioctl.c ../../include/errno.h ../../include/termios.h \
+  ../../include/linux/sched.h ../../include/linux/head.h \
+  ../../include/linux/fs.h ../../include/sys/types.h ../../include/linux/mm.h \
+  ../../include/signal.h ../../include/linux/kernel.h \
+  ../../include/linux/tty.h ../../include/asm/io.h \
+  ../../include/asm/segment.h ../../include/asm/system.h
diff --git a/kernel/chr_drv/console.c b/kernel/chr_drv/console.c
new file mode 100644
index 0000000..6a664e9
--- /dev/null
+++ b/kernel/chr_drv/console.c
@@ -0,0 +1,712 @@
+/*
+ *  linux/kernel/console.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ *	console.c
+ *
+ * This module implements the console io functions
+ *	'void con_init(void)'
+ *	'void con_write(struct tty_queue * queue)'
+ * Hopefully this will be a rather complete VT102 implementation.
+ *
+ * Beeping thanks to John T Kohl.
+ */
+
+/*
+ *  NOTE!!! We sometimes disable and enable interrupts for a short while
+ * (to put a word in video IO), but this will work even for keyboard
+ * interrupts. We know interrupts aren't enabled when getting a keyboard
+ * interrupt, as we use trap-gates. Hopefully all is well.
+ */
+
+/*
+ * Code to check for different video-cards mostly by Galen Hunt,
+ * <g-hunt@ee.utah.edu>
+ */
+
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+/*
+ * These are set up by the setup-routine at boot-time:
+ */
+
+#define ORIG_X			(*(unsigned char *)0x90000)
+#define ORIG_Y			(*(unsigned char *)0x90001)
+#define ORIG_VIDEO_PAGE		(*(unsigned short *)0x90004)
+#define ORIG_VIDEO_MODE		((*(unsigned short *)0x90006) & 0xff)
+#define ORIG_VIDEO_COLS 	(((*(unsigned short *)0x90006) & 0xff00) >> 8)
+#define ORIG_VIDEO_LINES	(25)
+#define ORIG_VIDEO_EGA_AX	(*(unsigned short *)0x90008)
+#define ORIG_VIDEO_EGA_BX	(*(unsigned short *)0x9000a)
+#define ORIG_VIDEO_EGA_CX	(*(unsigned short *)0x9000c)
+
+#define VIDEO_TYPE_MDA		0x10	/* Monochrome Text Display	*/
+#define VIDEO_TYPE_CGA		0x11	/* CGA Display 			*/
+#define VIDEO_TYPE_EGAM		0x20	/* EGA/VGA in Monochrome Mode	*/
+#define VIDEO_TYPE_EGAC		0x21	/* EGA/VGA in Color Mode	*/
+
+#define NPAR 16
+
+extern void keyboard_interrupt(void);
+
+static unsigned char	video_type;		/* Type of display being used	*/
+static unsigned long	video_num_columns;	/* Number of text columns	*/
+static unsigned long	video_size_row;		/* Bytes per row		*/
+static unsigned long	video_num_lines;	/* Number of test lines		*/
+static unsigned char	video_page;		/* Initial video page		*/
+static unsigned long	video_mem_start;	/* Start of video RAM		*/
+static unsigned long	video_mem_end;		/* End of video RAM (sort of)	*/
+static unsigned short	video_port_reg;		/* Video register select port	*/
+static unsigned short	video_port_val;		/* Video register value port	*/
+static unsigned short	video_erase_char;	/* Char+Attrib to erase with	*/
+
+static unsigned long	origin;		/* Used for EGA/VGA fast scroll	*/
+static unsigned long	scr_end;	/* Used for EGA/VGA fast scroll	*/
+static unsigned long	pos;
+static unsigned long	x,y;
+static unsigned long	top,bottom;
+static unsigned long	state=0;
+static unsigned long	npar,par[NPAR];
+static unsigned long	ques=0;
+static unsigned char	attr=0x07;
+
+static void sysbeep(void);
+
+/*
+ * this is what the terminal answers to a ESC-Z or csi0c
+ * query (= vt100 response).
+ */
+#define RESPONSE "\033[?1;2c"
+
+/* NOTE! gotoxy thinks x==video_num_columns is ok */
+static inline void gotoxy(unsigned int new_x,unsigned int new_y)
+{
+	if (new_x > video_num_columns || new_y >= video_num_lines)
+		return;
+	x=new_x;
+	y=new_y;
+	pos=origin + y*video_size_row + (x<<1);
+}
+
+static inline void set_origin(void)
+{
+	cli();
+	outb_p(12, video_port_reg);
+	outb_p(0xff&((origin-video_mem_start)>>9), video_port_val);
+	outb_p(13, video_port_reg);
+	outb_p(0xff&((origin-video_mem_start)>>1), video_port_val);
+	sti();
+}
+
+static void scrup(void)
+{
+	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
+	{
+		if (!top && bottom == video_num_lines) {
+			origin += video_size_row;
+			pos += video_size_row;
+			scr_end += video_size_row;
+			if (scr_end > video_mem_end) {
+				__asm__("cld\n\t"
+					"rep\n\t"
+					"movsl\n\t"
+					"movl _video_num_columns,%1\n\t"
+					"rep\n\t"
+					"stosw"
+					::"a" (video_erase_char),
+					"c" ((video_num_lines-1)*video_num_columns>>1),
+					"D" (video_mem_start),
+					"S" (origin)
+					:"cx","di","si");
+				scr_end -= origin-video_mem_start;
+				pos -= origin-video_mem_start;
+				origin = video_mem_start;
+			} else {
+				__asm__("cld\n\t"
+					"rep\n\t"
+					"stosw"
+					::"a" (video_erase_char),
+					"c" (video_num_columns),
+					"D" (scr_end-video_size_row)
+					:"cx","di");
+			}
+			set_origin();
+		} else {
+			__asm__("cld\n\t"
+				"rep\n\t"
+				"movsl\n\t"
+				"movl _video_num_columns,%%ecx\n\t"
+				"rep\n\t"
+				"stosw"
+				::"a" (video_erase_char),
+				"c" ((bottom-top-1)*video_num_columns>>1),
+				"D" (origin+video_size_row*top),
+				"S" (origin+video_size_row*(top+1))
+				:"cx","di","si");
+		}
+	}
+	else		/* Not EGA/VGA */
+	{
+		__asm__("cld\n\t"
+			"rep\n\t"
+			"movsl\n\t"
+			"movl _video_num_columns,%%ecx\n\t"
+			"rep\n\t"
+			"stosw"
+			::"a" (video_erase_char),
+			"c" ((bottom-top-1)*video_num_columns>>1),
+			"D" (origin+video_size_row*top),
+			"S" (origin+video_size_row*(top+1))
+			:"cx","di","si");
+	}
+}
+
+static void scrdown(void)
+{
+	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
+	{
+		__asm__("std\n\t"
+			"rep\n\t"
+			"movsl\n\t"
+			"addl $2,%%edi\n\t"	/* %edi has been decremented by 4 */
+			"movl _video_num_columns,%%ecx\n\t"
+			"rep\n\t"
+			"stosw"
+			::"a" (video_erase_char),
+			"c" ((bottom-top-1)*video_num_columns>>1),
+			"D" (origin+video_size_row*bottom-4),
+			"S" (origin+video_size_row*(bottom-1)-4)
+			:"ax","cx","di","si");
+	}
+	else		/* Not EGA/VGA */
+	{
+		__asm__("std\n\t"
+			"rep\n\t"
+			"movsl\n\t"
+			"addl $2,%%edi\n\t"	/* %edi has been decremented by 4 */
+			"movl _video_num_columns,%%ecx\n\t"
+			"rep\n\t"
+			"stosw"
+			::"a" (video_erase_char),
+			"c" ((bottom-top-1)*video_num_columns>>1),
+			"D" (origin+video_size_row*bottom-4),
+			"S" (origin+video_size_row*(bottom-1)-4)
+			:"ax","cx","di","si");
+	}
+}
+
+static void lf(void)
+{
+	if (y+1<bottom) {
+		y++;
+		pos += video_size_row;
+		return;
+	}
+	scrup();
+}
+
+static void ri(void)
+{
+	if (y>top) {
+		y--;
+		pos -= video_size_row;
+		return;
+	}
+	scrdown();
+}
+
+static void cr(void)
+{
+	pos -= x<<1;
+	x=0;
+}
+
+static void del(void)
+{
+	if (x) {
+		pos -= 2;
+		x--;
+		*(unsigned short *)pos = video_erase_char;
+	}
+}
+
+static void csi_J(int par)
+{
+	long count __asm__("cx");
+	long start __asm__("di");
+
+	switch (par) {
+		case 0:	/* erase from cursor to end of display */
+			count = (scr_end-pos)>>1;
+			start = pos;
+			break;
+		case 1:	/* erase from start to cursor */
+			count = (pos-origin)>>1;
+			start = origin;
+			break;
+		case 2: /* erase whole display */
+			count = video_num_columns * video_num_lines;
+			start = origin;
+			break;
+		default:
+			return;
+	}
+	__asm__("cld\n\t"
+		"rep\n\t"
+		"stosw\n\t"
+		::"c" (count),
+		"D" (start),"a" (video_erase_char)
+		:"cx","di");
+}
+
+static void csi_K(int par)
+{
+	long count __asm__("cx");
+	long start __asm__("di");
+
+	switch (par) {
+		case 0:	/* erase from cursor to end of line */
+			if (x>=video_num_columns)
+				return;
+			count = video_num_columns-x;
+			start = pos;
+			break;
+		case 1:	/* erase from start of line to cursor */
+			start = pos - (x<<1);
+			count = (x<video_num_columns)?x:video_num_columns;
+			break;
+		case 2: /* erase whole line */
+			start = pos - (x<<1);
+			count = video_num_columns;
+			break;
+		default:
+			return;
+	}
+	__asm__("cld\n\t"
+		"rep\n\t"
+		"stosw\n\t"
+		::"c" (count),
+		"D" (start),"a" (video_erase_char)
+		:"cx","di");
+}
+
+void csi_m(void)
+{
+	int i;
+
+	for (i=0;i<=npar;i++)
+		switch (par[i]) {
+			case 0:attr=0x07;break;
+			case 1:attr=0x0f;break;
+			case 4:attr=0x0f;break;
+			case 7:attr=0x70;break;
+			case 27:attr=0x07;break;
+		}
+}
+
+static inline void set_cursor(void)
+{
+	cli();
+	outb_p(14, video_port_reg);
+	outb_p(0xff&((pos-video_mem_start)>>9), video_port_val);
+	outb_p(15, video_port_reg);
+	outb_p(0xff&((pos-video_mem_start)>>1), video_port_val);
+	sti();
+}
+
+static void respond(struct tty_struct * tty)
+{
+	char * p = RESPONSE;
+
+	cli();
+	while (*p) {
+		PUTCH(*p,tty->read_q);
+		p++;
+	}
+	sti();
+	copy_to_cooked(tty);
+}
+
+static void insert_char(void)
+{
+	int i=x;
+	unsigned short tmp, old = video_erase_char;
+	unsigned short * p = (unsigned short *) pos;
+
+	while (i++ < video_num_columns) {
+		tmp = *p;
+		*p = old;
+		old = tmp;
+		p++;
+	}
+}
+
+static void insert_line(void)
+{
+	int oldtop,oldbottom;
+
+	oldtop=top;
+	oldbottom=bottom;
+	top=y;
+	bottom = video_num_lines;
+	scrdown();
+	top=oldtop;
+	bottom=oldbottom;
+}
+
+static void delete_char(void)
+{
+	int i;
+	unsigned short * p = (unsigned short *) pos;
+
+	if (x >= video_num_columns)
+		return;
+	i = x;
+	while (++i < video_num_columns) {
+		*p = *(p+1);
+		p++;
+	}
+	*p = video_erase_char;
+}
+
+static void delete_line(void)
+{
+	int oldtop,oldbottom;
+
+	oldtop=top;
+	oldbottom=bottom;
+	top=y;
+	bottom = video_num_lines;
+	scrup();
+	top=oldtop;
+	bottom=oldbottom;
+}
+
+static void csi_at(unsigned int nr)
+{
+	if (nr > video_num_columns)
+		nr = video_num_columns;
+	else if (!nr)
+		nr = 1;
+	while (nr--)
+		insert_char();
+}
+
+static void csi_L(unsigned int nr)
+{
+	if (nr > video_num_lines)
+		nr = video_num_lines;
+	else if (!nr)
+		nr = 1;
+	while (nr--)
+		insert_line();
+}
+
+static void csi_P(unsigned int nr)
+{
+	if (nr > video_num_columns)
+		nr = video_num_columns;
+	else if (!nr)
+		nr = 1;
+	while (nr--)
+		delete_char();
+}
+
+static void csi_M(unsigned int nr)
+{
+	if (nr > video_num_lines)
+		nr = video_num_lines;
+	else if (!nr)
+		nr=1;
+	while (nr--)
+		delete_line();
+}
+
+static int saved_x=0;
+static int saved_y=0;
+
+static void save_cur(void)
+{
+	saved_x = x;
+	saved_y = y;
+}
+
+static void restore_cur(void)
+{
+	gotoxy(saved_x, saved_y);
+}
+
+void con_write(struct tty_struct * tty)
+{
+	int nr;
+	char c;
+
+	nr = CHARS(tty->write_q);
+	while (nr--) {
+		GETCH(tty->write_q,c);
+		switch(state) {
+			case 0:
+				if (c > 31 && c < 127) {
+					if (x >= video_num_columns) {
+						x -= video_num_columns;
+						pos -= video_size_row;
+						lf();
+					}
+					__asm__("movb _attr,%%ah\n\t"
+						"movw %%ax,%1\n\t"
+						::"a" (c),"m" (*(short *)pos)
+						:"ax");
+					pos += 2;
+					x++;
+				} else if (c == 27)
+					state = 1;
+				else if (c == 10 || c == 11 || c == 12)
+					lf();
+				else if (c == 13)
+					cr();
+				else if (c == ERASE_CHAR(tty))
+					del();
+				else if (c == 8) {
+					if (x) {
+						x--;
+						pos -= 2;
+					}
+				} else if (c == 9) {
+					c = 8 - (x&7);
+					x += c;
+					pos += c<<1;
+					if (x > video_num_columns) {
+						x -= video_num_columns;
+						pos -= video_size_row;
+						lf();
+					}
+					c = 9;
+				} else if (c == 7)
+					sysbeep();
+				break;
+			case 1:
+				state=0;
+				if (c=='[')
+					state=2;
+				else if (c=='E')
+					gotoxy(0,y+1);
+				else if (c=='M')
+					ri();
+				else if (c=='D')
+					lf();
+				else if (c=='Z')
+					respond(tty);
+				else if (x=='7')
+					save_cur();
+				else if (x=='8')
+					restore_cur();
+				break;
+			case 2:
+				for(npar=0;npar<NPAR;npar++)
+					par[npar]=0;
+				npar=0;
+				state=3;
+				if (ques=(c=='?'))
+					break;
+			case 3:
+				if (c==';' && npar<NPAR-1) {
+					npar++;
+					break;
+				} else if (c>='0' && c<='9') {
+					par[npar]=10*par[npar]+c-'0';
+					break;
+				} else state=4;
+			case 4:
+				state=0;
+				switch(c) {
+					case 'G': case '`':
+						if (par[0]) par[0]--;
+						gotoxy(par[0],y);
+						break;
+					case 'A':
+						if (!par[0]) par[0]++;
+						gotoxy(x,y-par[0]);
+						break;
+					case 'B': case 'e':
+						if (!par[0]) par[0]++;
+						gotoxy(x,y+par[0]);
+						break;
+					case 'C': case 'a':
+						if (!par[0]) par[0]++;
+						gotoxy(x+par[0],y);
+						break;
+					case 'D':
+						if (!par[0]) par[0]++;
+						gotoxy(x-par[0],y);
+						break;
+					case 'E':
+						if (!par[0]) par[0]++;
+						gotoxy(0,y+par[0]);
+						break;
+					case 'F':
+						if (!par[0]) par[0]++;
+						gotoxy(0,y-par[0]);
+						break;
+					case 'd':
+						if (par[0]) par[0]--;
+						gotoxy(x,par[0]);
+						break;
+					case 'H': case 'f':
+						if (par[0]) par[0]--;
+						if (par[1]) par[1]--;
+						gotoxy(par[1],par[0]);
+						break;
+					case 'J':
+						csi_J(par[0]);
+						break;
+					case 'K':
+						csi_K(par[0]);
+						break;
+					case 'L':
+						csi_L(par[0]);
+						break;
+					case 'M':
+						csi_M(par[0]);
+						break;
+					case 'P':
+						csi_P(par[0]);
+						break;
+					case '@':
+						csi_at(par[0]);
+						break;
+					case 'm':
+						csi_m();
+						break;
+					case 'r':
+						if (par[0])
+							par[0]--;
+						if (!par[1])
+							par[1] = video_num_lines;
+						if (par[0] < par[1] &&
+								par[1] <= video_num_lines) {
+							top=par[0];
+							bottom=par[1];
+						}
+						break;
+					case 's':
+						save_cur();
+						break;
+					case 'u':
+						restore_cur();
+						break;
+				}
+		}
+	}
+	set_cursor();
+}
+
+/*
+ *  void con_init(void);
+ *
+ * This routine initalizes console interrupts, and does nothing
+ * else. If you want the screen to clear, call tty_write with
+ * the appropriate escape-sequece.
+ *
+ * Reads the information preserved by setup.s to determine the current display
+ * type and sets everything accordingly.
+ */
+void con_init(void)
+{
+	register unsigned char a;
+	char *display_desc = "????";
+	char *display_ptr;
+
+	video_num_columns = ORIG_VIDEO_COLS;
+	video_size_row = video_num_columns * 2;
+	video_num_lines = ORIG_VIDEO_LINES;
+	video_page = ORIG_VIDEO_PAGE;
+	video_erase_char = 0x0720;
+
+	if (ORIG_VIDEO_MODE == 7)	/* Is this a monochrome display? */
+	{
+		video_mem_start = 0xb0000;
+		video_port_reg = 0x3b4;
+		video_port_val = 0x3b5;
+		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
+		{
+			video_type = VIDEO_TYPE_EGAM;
+			video_mem_end = 0xb8000;
+			display_desc = "EGAm";
+		}
+		else
+		{
+			video_type = VIDEO_TYPE_MDA;
+			video_mem_end	= 0xb2000;
+			display_desc = "*MDA";
+		}
+	}
+	else		/* If not, it is color. */
+	{
+		video_mem_start = 0xb8000;
+		video_port_reg	= 0x3d4;
+		video_port_val	= 0x3d5;
+		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
+		{
+			video_type = VIDEO_TYPE_EGAC;
+			video_mem_end = 0xbc000;
+			display_desc = "EGAc";
+		}
+		else
+		{
+			video_type = VIDEO_TYPE_CGA;
+			video_mem_end = 0xba000;
+			display_desc = "*CGA";
+		}
+	}
+
+	/* Let the user known what kind of display driver we are using */
+
+	display_ptr = ((char *)video_mem_start) + video_size_row - 8;
+	while (*display_desc)
+	{
+		*display_ptr++ = *display_desc++;
+		display_ptr++;
+	}
+
+	/* Initialize the variables used for scrolling (mostly EGA/VGA)	*/
+
+	origin	= video_mem_start;
+	scr_end	= video_mem_start + video_num_lines * video_size_row;
+	top	= 0;
+	bottom	= video_num_lines;
+
+	gotoxy(ORIG_X,ORIG_Y);
+	set_trap_gate(0x21,&keyboard_interrupt);
+	outb_p(inb_p(0x21)&0xfd,0x21);
+	a=inb_p(0x61);
+	outb_p(a|0x80,0x61);
+	outb(a,0x61);
+}
+/* from bsd-net-2: */
+
+void sysbeepstop(void)
+{
+	/* disable counter 2 */
+	outb(inb_p(0x61)&0xFC, 0x61);
+}
+
+int beepcount = 0;
+
+static void sysbeep(void)
+{
+	/* enable counter 2 */
+	outb_p(inb_p(0x61)|3, 0x61);
+	/* set command for counter 2, 2 byte write */
+	outb_p(0xB6, 0x43);
+	/* send 0x637 for 750 HZ */
+	outb_p(0x37, 0x42);
+	outb(0x06, 0x42);
+	/* 1/8 second */
+	beepcount = HZ/8;
+}
diff --git a/kernel/chr_drv/keyboard.S b/kernel/chr_drv/keyboard.S
new file mode 100644
index 0000000..8312863
--- /dev/null
+++ b/kernel/chr_drv/keyboard.S
@@ -0,0 +1,588 @@
+/*
+ *  linux/kernel/keyboard.S
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ *	Thanks to Alfred Leung for US keyboard patches
+ *		Wolfgang Thiel for German keyboard patches
+ *		Marc Corsini for the French keyboard
+ */
+
+#include <linux/config.h>
+
+.text
+.globl _keyboard_interrupt
+
+/*
+ * these are for the keyboard read functions
+ */
+size	= 1024		/* must be a power of two ! And MUST be the same
+			   as in tty_io.c !!!! */
+head = 4
+tail = 8
+proc_list = 12
+buf = 16
+
+mode:	.byte 0		/* caps, alt, ctrl and shift mode */
+leds:	.byte 2		/* num-lock, caps, scroll-lock mode (nom-lock on) */
+e0:	.byte 0
+
+/*
+ *  con_int is the real interrupt routine that reads the
+ *  keyboard scan-code and converts it into the appropriate
+ *  ascii character(s).
+ */
+_keyboard_interrupt:
+	pushl	%eax
+	pushl	%ebx
+	pushl	%ecx
+	pushl	%edx
+	push	%ds
+	push	%es
+	movl	$0x10,%eax
+	mov	%ax,%ds
+	mov	%ax,%es
+	xorl	%al,%al		/* %eax is scan code */
+	inb	$0x60,%al
+	cmpb	$0xe0,%al
+	je	set_e0
+	cmpb	$0xe1,%al
+	je	set_e1
+	call	key_table(,%eax,4)
+	movb	$0,e0
+e0_e1:	inb	$0x61,%al
+	jmp	1f
+1:	jmp	1f
+1:	orb	$0x80,%al
+	jmp	1f
+1:	jmp	1f
+1:	outb	%al,$0x61
+	jmp	1f
+1:	jmp	1f
+1:	andb	$0x7F,%al
+	outb	%al,$0x61
+	movb	$0x20,%al
+	outb	%al,$0x20
+	pushl	$0
+	call	_do_tty_interrupt
+	addl	$4,%esp
+	pop	%es
+	pop	%ds
+	popl	%edx
+	popl	%ecx
+	popl	%ebx
+	popl	%eax
+	iret
+set_e0:movb	$1,e0
+	jmp	e0_e1
+set_e1:movb	$2,e0
+	jmp	e0_e1
+
+/*
+ * This routine fills the buffer with max 8 bytes, taken from
+ * %ebx:%eax. (%edx is high). The bytes are written in the
+ * order %al,%ah,%eal,%eah,%bl,%bh ... until %eax is zero.
+ */
+put_queue:
+	pushl	%ecx
+	pushl	%edx
+	movl	_table_list,%edx	# read-queue for console
+	movl	head(%edx),%ecx
+1:	movb	%al,buf(%edx,%ecx)
+	incl	%ecx
+	andl	$size-1,%ecx
+	cmpl	tail(%edx),%ecx		# buffer full - discard everything
+	je	3f
+	shrdl	$8,%ebx,%eax
+	je	2f
+	shrl	$8,%ebx
+	jmp	1b
+2:	movl	%ecx,head(%edx)
+	movl	proc_list(%edx),%ecx
+	testl	%ecx,%ecx
+	je	3f
+	movl	$0,(%ecx)
+3:	popl	%edx
+	popl	%ecx
+	ret
+
+ctrl:	movb	$0x04,%al
+	jmp	1f
+alt:	movb	$0x10,%al
+1:	cmpb	$0,e0
+	je	2f
+	addb	%al,%al
+2:	orb	%al,mode
+	ret
+unctrl:movb	$0x04,%al
+	jmp	1f
+unalt:	movb	$0x10,%al
+1:	cmpb	$0,e0
+	je	2f
+	addb	%al,%al
+2:	notb	%al
+	andb	%al,mode
+	ret
+
+lshift:
+	orb	$0x01,mode
+	ret
+unlshift:
+	andb	$0xfe,mode
+	ret
+rshift:
+	orb	$0x02,mode
+	ret
+unrshift:
+	andb	$0xfd,mode
+	ret
+
+caps:	testb	$0x80,mode
+	jne	1f
+	xorb	$4,leds
+	xorb	$0x40,mode
+	orb	$0x80,mode
+set_leds:
+	call	kb_wait
+	movb	$0xed,%al	/* set leds command */
+	outb	%al,$0x60
+	call	kb_wait
+	movb	leds,%al
+	outb	%al,$0x60
+	ret
+uncaps:andb	$0x7f,mode
+	ret
+scroll:
+	xorb	$1,leds
+	jmp	set_leds
+num:	xorb	$2,leds
+	jmp	set_leds
+
+/*
+ *  curosr-key/numeric keypad cursor keys are handled here.
+ *  checking for numeric keypad etc.
+ */
+cursor:
+	subb	$0x47,%al
+	jb	1f
+	cmpb	$12,%al
+	ja	1f
+	jne	cur2		/* check for ctrl-alt-del */
+	testb	$0x0c,mode
+	je	cur2
+	testb	$0x30,mode
+	jne	reboot
+cur2:	cmpb	$0x01,e0	/* e0 forces cursor movement */
+	je	cur
+	testb	$0x02,leds	/* not num-lock forces cursor */
+	je	cur
+	testb	$0x03,mode	/* shift forces cursor */
+	jne	cur
+	xorl	%ebx,%ebx
+	movb	num_table(%eax),%al
+	jmp	put_queue
+1:	ret
+
+cur:	movb	cur_table(%eax),%al
+	cmpb	$'9,%al
+	ja	ok_cur
+	movb	$'~,%ah
+ok_cur:shll	$16,%eax
+	movw	$0x5b1b,%ax
+	xorl	%ebx,%ebx
+	jmp	put_queue
+
+#if defined(KBD_FR)
+num_table:
+	.ascii	"789 456 1230."
+#else
+num_table:
+	.ascii	"789 456 1230,"
+#endif
+cur_table:
+	.ascii	"HA5 DGC YB623"
+
+/*
+ * this routine handles function keys
+ */
+func:
+	pushl	%eax
+	pushl	%ecx
+	pushl	%edx
+	call	_show_stat
+	popl	%edx
+	popl	%ecx
+	popl	%eax
+	subb	$0x3B,%al
+	jb	end_func
+	cmpb	$9,%al
+	jb	ok_func
+	subb	$18,%al
+	cmpb	$10,%al
+	jb	end_func
+	cmpb	$11,%al
+	ja	end_func
+ok_func:
+	cmpl	$4,%ecx		/* check that there is enough room */
+	jl	end_func
+	movl	func_table(,%eax,4),%eax
+	xorl	%ebx,%ebx
+	jmp	put_queue
+end_func:
+	ret
+
+/*
+ * function keys send F1:'esc [ [ A' F2:'esc [ [ B' etc.
+ */
+func_table:
+	.long	0x415b5b1b,0x425b5b1b,0x435b5b1b,0x445b5b1b
+	.long	0x455b5b1b,0x465b5b1b,0x475b5b1b,0x485b5b1b
+	.long	0x495b5b1b,0x4a5b5b1b,0x4b5b5b1b,0x4c5b5b1b
+
+#if	defined(KBD_FINNISH)
+key_map:
+	.byte	0,27
+	.ascii	"1234567890+'"
+	.byte	127,9
+	.ascii	"qwertyuiop}"
+	.byte	0,13,0
+	.ascii	"asdfghjkl|{"
+	.byte	0,0
+	.ascii	"'zxcvbnm,.-"
+	.byte	0,'*,0,32	/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	'-,0,0,0,'+	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'<
+	.fill	10,1,0
+
+shift_map:
+	.byte	0,27
+	.ascii	"!\"#$%&/()=?`"
+	.byte	127,9
+	.ascii	"QWERTYUIOP]^"
+	.byte	13,0
+	.ascii	"ASDFGHJKL\\["
+	.byte	0,0
+	.ascii	"*ZXCVBNM;:_"
+	.byte	0,'*,0,32	/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	'-,0,0,0,'+	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'>
+	.fill	10,1,0
+
+alt_map:
+	.byte	0,0
+	.ascii	"\0@\0$\0\0{[]}\\\0"
+	.byte	0,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	'~,13,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	0,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	0,0,0,0		/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	0,0,0,0,0	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'|
+	.fill	10,1,0
+
+#elif defined(KBD_US)
+
+key_map:
+	.byte	0,27
+	.ascii	"1234567890-="
+	.byte	127,9
+	.ascii	"qwertyuiop[]"
+	.byte	13,0
+	.ascii	"asdfghjkl;'"
+	.byte	'`,0
+	.ascii	"\\zxcvbnm,./"
+	.byte	0,'*,0,32	/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	'-,0,0,0,'+	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'<
+	.fill	10,1,0
+
+
+shift_map:
+	.byte	0,27
+	.ascii	"!@#$%^&*()_+"
+	.byte	127,9
+	.ascii	"QWERTYUIOP{}"
+	.byte	13,0
+	.ascii	"ASDFGHJKL:\""
+	.byte	'~,0
+	.ascii	"|ZXCVBNM<>?"
+	.byte	0,'*,0,32	/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	'-,0,0,0,'+	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'>
+	.fill	10,1,0
+
+alt_map:
+	.byte	0,0
+	.ascii	"\0@\0$\0\0{[]}\\\0"
+	.byte	0,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	'~,13,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	0,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	0,0,0,0		/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	0,0,0,0,0	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'|
+	.fill	10,1,0
+
+#elif defined(KBD_GR)
+
+key_map:
+	.byte	0,27
+	.ascii	"1234567890\\'"
+	.byte	127,9
+	.ascii	"qwertzuiop@+"
+	.byte	13,0
+	.ascii	"asdfghjkl[]^"
+	.byte	0,'#
+	.ascii	"yxcvbnm,.-"
+	.byte	0,'*,0,32	/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	'-,0,0,0,'+	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'<
+	.fill	10,1,0
+
+
+shift_map:
+	.byte	0,27
+	.ascii	"!\"#$%&/()=?`"
+	.byte	127,9
+	.ascii	"QWERTZUIOP\\*"
+	.byte	13,0
+	.ascii	"ASDFGHJKL{}~"
+	.byte	0,''
+	.ascii	"YXCVBNM;:_"
+	.byte	0,'*,0,32	/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	'-,0,0,0,'+	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'>
+	.fill	10,1,0
+
+alt_map:
+	.byte	0,0
+	.ascii	"\0@\0$\0\0{[]}\\\0"
+	.byte	0,0
+	.byte	'@,0,0,0,0,0,0,0,0,0,0
+	.byte	'~,13,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	0,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	0,0,0,0		/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	0,0,0,0,0	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'|
+	.fill	10,1,0
+
+
+#elif defined(KBD_FR)
+
+key_map:
+	.byte	0,27
+	.ascii	"&{\"'(-}_/@)="
+	.byte	127,9
+	.ascii	"azertyuiop^$"
+	.byte	13,0
+	.ascii	"qsdfghjklm|"
+	.byte	'`,0,42		/* coin sup gauche, don't know, [*|mu] */
+	.ascii	"wxcvbn,;:!"
+	.byte	0,'*,0,32	/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	'-,0,0,0,'+	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'<
+	.fill	10,1,0
+
+shift_map:
+	.byte	0,27
+	.ascii	"1234567890]+"
+	.byte	127,9
+	.ascii	"AZERTYUIOP<>"
+	.byte	13,0
+	.ascii	"QSDFGHJKLM%"
+	.byte	'~,0,'#
+	.ascii	"WXCVBN?./\\"
+	.byte	0,'*,0,32	/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	'-,0,0,0,'+	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'>
+	.fill	10,1,0
+
+alt_map:
+	.byte	0,0
+	.ascii	"\0~#{[|`\\^@]}"
+	.byte	0,0
+	.byte	'@,0,0,0,0,0,0,0,0,0,0
+	.byte	'~,13,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	0,0
+	.byte	0,0,0,0,0,0,0,0,0,0,0
+	.byte	0,0,0,0		/* 36-39 */
+	.fill	16,1,0		/* 3A-49 */
+	.byte	0,0,0,0,0	/* 4A-4E */
+	.byte	0,0,0,0,0,0,0	/* 4F-55 */
+	.byte	'|
+	.fill	10,1,0
+
+#else
+#error "KBD-type not defined"
+#endif
+/*
+ * do_self handles "normal" keys, ie keys that don't change meaning
+ * and which have just one character returns.
+ */
+do_self:
+	lea	alt_map,%ebx
+	testb	$0x20,mode		/* alt-gr */
+	jne	1f
+	lea	shift_map,%ebx
+	testb	$0x03,mode
+	jne	1f
+	lea	key_map,%ebx
+1:	movb	(%ebx,%eax),%al
+	orb	%al,%al
+	je	none
+	testb	$0x4c,mode		/* ctrl or caps */
+	je	2f
+	cmpb	$'a,%al
+	jb	2f
+	cmpb	$'},%al
+	ja	2f
+	subb	$32,%al
+2:	testb	$0x0c,mode		/* ctrl */
+	je	3f
+	cmpb	$64,%al
+	jb	3f
+	cmpb	$64+32,%al
+	jae	3f
+	subb	$64,%al
+3:	testb	$0x10,mode		/* left alt */
+	je	4f
+	orb	$0x80,%al
+4:	andl	$0xff,%eax
+	xorl	%ebx,%ebx
+	call	put_queue
+none:	ret
+
+/*
+ * minus has a routine of it's own, as a 'E0h' before
+ * the scan code for minus means that the numeric keypad
+ * slash was pushed.
+ */
+minus:	cmpb	$1,e0
+	jne	do_self
+	movl	$'/,%eax
+	xorl	%ebx,%ebx
+	jmp	put_queue
+
+/*
+ * This table decides which routine to call when a scan-code has been
+ * gotten. Most routines just call do_self, or none, depending if
+ * they are make or break.
+ */
+key_table:
+	.long	none,do_self,do_self,do_self	/* 00-03 s0 esc 1 2 */
+	.long	do_self,do_self,do_self,do_self	/* 04-07 3 4 5 6 */
+	.long	do_self,do_self,do_self,do_self	/* 08-0B 7 8 9 0 */
+	.long	do_self,do_self,do_self,do_self	/* 0C-0F + ' bs tab */
+	.long	do_self,do_self,do_self,do_self	/* 10-13 q w e r */
+	.long	do_self,do_self,do_self,do_self	/* 14-17 t y u i */
+	.long	do_self,do_self,do_self,do_self	/* 18-1B o p } ^ */
+	.long	do_self,ctrl,do_self,do_self	/* 1C-1F enter ctrl a s */
+	.long	do_self,do_self,do_self,do_self	/* 20-23 d f g h */
+	.long	do_self,do_self,do_self,do_self	/* 24-27 j k l | */
+	.long	do_self,do_self,lshift,do_self	/* 28-2B { para lshift , */
+	.long	do_self,do_self,do_self,do_self	/* 2C-2F z x c v */
+	.long	do_self,do_self,do_self,do_self	/* 30-33 b n m , */
+	.long	do_self,minus,rshift,do_self	/* 34-37 . - rshift * */
+	.long	alt,do_self,caps,func		/* 38-3B alt sp caps f1 */
+	.long	func,func,func,func		/* 3C-3F f2 f3 f4 f5 */
+	.long	func,func,func,func		/* 40-43 f6 f7 f8 f9 */
+	.long	func,num,scroll,cursor		/* 44-47 f10 num scr home */
+	.long	cursor,cursor,do_self,cursor	/* 48-4B up pgup - left */
+	.long	cursor,cursor,do_self,cursor	/* 4C-4F n5 right + end */
+	.long	cursor,cursor,cursor,cursor	/* 50-53 dn pgdn ins del */
+	.long	none,none,do_self,func		/* 54-57 sysreq ? < f11 */
+	.long	func,none,none,none		/* 58-5B f12 ? ? ? */
+	.long	none,none,none,none		/* 5C-5F ? ? ? ? */
+	.long	none,none,none,none		/* 60-63 ? ? ? ? */
+	.long	none,none,none,none		/* 64-67 ? ? ? ? */
+	.long	none,none,none,none		/* 68-6B ? ? ? ? */
+	.long	none,none,none,none		/* 6C-6F ? ? ? ? */
+	.long	none,none,none,none		/* 70-73 ? ? ? ? */
+	.long	none,none,none,none		/* 74-77 ? ? ? ? */
+	.long	none,none,none,none		/* 78-7B ? ? ? ? */
+	.long	none,none,none,none		/* 7C-7F ? ? ? ? */
+	.long	none,none,none,none		/* 80-83 ? br br br */
+	.long	none,none,none,none		/* 84-87 br br br br */
+	.long	none,none,none,none		/* 88-8B br br br br */
+	.long	none,none,none,none		/* 8C-8F br br br br */
+	.long	none,none,none,none		/* 90-93 br br br br */
+	.long	none,none,none,none		/* 94-97 br br br br */
+	.long	none,none,none,none		/* 98-9B br br br br */
+	.long	none,unctrl,none,none		/* 9C-9F br unctrl br br */
+	.long	none,none,none,none		/* A0-A3 br br br br */
+	.long	none,none,none,none		/* A4-A7 br br br br */
+	.long	none,none,unlshift,none		/* A8-AB br br unlshift br */
+	.long	none,none,none,none		/* AC-AF br br br br */
+	.long	none,none,none,none		/* B0-B3 br br br br */
+	.long	none,none,unrshift,none		/* B4-B7 br br unrshift br */
+	.long	unalt,none,uncaps,none		/* B8-BB unalt br uncaps br */
+	.long	none,none,none,none		/* BC-BF br br br br */
+	.long	none,none,none,none		/* C0-C3 br br br br */
+	.long	none,none,none,none		/* C4-C7 br br br br */
+	.long	none,none,none,none		/* C8-CB br br br br */
+	.long	none,none,none,none		/* CC-CF br br br br */
+	.long	none,none,none,none		/* D0-D3 br br br br */
+	.long	none,none,none,none		/* D4-D7 br br br br */
+	.long	none,none,none,none		/* D8-DB br ? ? ? */
+	.long	none,none,none,none		/* DC-DF ? ? ? ? */
+	.long	none,none,none,none		/* E0-E3 e0 e1 ? ? */
+	.long	none,none,none,none		/* E4-E7 ? ? ? ? */
+	.long	none,none,none,none		/* E8-EB ? ? ? ? */
+	.long	none,none,none,none		/* EC-EF ? ? ? ? */
+	.long	none,none,none,none		/* F0-F3 ? ? ? ? */
+	.long	none,none,none,none		/* F4-F7 ? ? ? ? */
+	.long	none,none,none,none		/* F8-FB ? ? ? ? */
+	.long	none,none,none,none		/* FC-FF ? ? ? ? */
+
+/*
+ * kb_wait waits for the keyboard controller buffer to empty.
+ * there is no timeout - if the buffer doesn't empty, we hang.
+ */
+kb_wait:
+	pushl	%eax
+1:	inb	$0x64,%al
+	testb	$0x02,%al
+	jne	1b
+	popl	%eax
+	ret
+/*
+ * This routine reboots the machine by asking the keyboard
+ * controller to pulse the reset-line low.
+ */
+reboot:
+	call	kb_wait
+	movw	$0x1234,0x472	/* don't do memory check */
+	movb	$0xfc,%al	/* pulse reset and A20 low */
+	outb	%al,$0x64
+die:	jmp	die
diff --git a/kernel/chr_drv/rs_io.s b/kernel/chr_drv/rs_io.s
new file mode 100644
index 0000000..ffb6121
--- /dev/null
+++ b/kernel/chr_drv/rs_io.s
@@ -0,0 +1,147 @@
+/*
+ *  linux/kernel/rs_io.s
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ *	rs_io.s
+ *
+ * This module implements the rs232 io interrupts.
+ */
+
+.text
+.globl _rs1_interrupt,_rs2_interrupt
+
+size	= 1024				/* must be power of two !
+					   and must match the value
+					   in tty_io.c!!! */
+
+/* these are the offsets into the read/write buffer structures */
+rs_addr = 0
+head = 4
+tail = 8
+proc_list = 12
+buf = 16
+
+startup	= 256		/* chars left in write queue when we restart it */
+
+/*
+ * These are the actual interrupt routines. They look where
+ * the interrupt is coming from, and take appropriate action.
+ */
+.align 2
+_rs1_interrupt:
+	pushl	$_table_list+8
+	jmp	rs_int
+.align 2
+_rs2_interrupt:
+	pushl	$_table_list+16
+rs_int:
+	pushl	%edx
+	pushl	%ecx
+	pushl	%ebx
+	pushl	%eax
+	push	%es
+	push	%ds		/* as this is an interrupt, we cannot */
+	pushl	$0x10		/* know that bs is ok. Load it */
+	pop	%ds
+	pushl	$0x10
+	pop	%es
+	movl	24(%esp),%edx
+	movl	(%edx),%edx
+	movl	rs_addr(%edx),%edx
+	addl	$2,%edx		/* interrupt ident. reg */
+rep_int:
+	xorl	%eax,%eax
+	inb	%dx,%al
+	testb	$1,%al
+	jne	end
+	cmpb	$6,%al		/* this shouldn't happen, but ... */
+	ja	end
+	movl	24(%esp),%ecx
+	pushl	%edx
+	subl	$2,%edx
+	call	jmp_table(,%eax,2)		/* NOTE! not *4, bit0 is 0 already */
+	popl	%edx
+	jmp	rep_int
+end:	movb	$0x20,%al
+	outb	%al,$0x20	/* EOI */
+	pop	%ds
+	pop	%es
+	popl	%eax
+	popl	%ebx
+	popl	%ecx
+	popl	%edx
+	addl	$4,%esp		# jump over _table_list entry
+	iret
+
+jmp_table:
+	.long	modem_status,write_char,read_char,line_status
+
+.align 2
+modem_status:
+	addl	$6,%edx		/* clear intr by reading modem status reg */
+	inb	%dx,%al
+	ret
+
+.align 2
+line_status:
+	addl	$5,%edx		/* clear intr by reading line status reg. */
+	inb	%dx,%al
+	ret
+
+.align 2
+read_char:
+	inb	%dx,%al
+	movl	%ecx,%edx
+	subl	$_table_list,%edx
+	shrl	$3,%edx
+	movl	(%ecx),%ecx		# read-queue
+	movl	head(%ecx),%ebx
+	movb	%al,buf(%ecx,%ebx)
+	incl	%ebx
+	andl	$size-1,%ebx
+	cmpl	tail(%ecx),%ebx
+	je	1f
+	movl	%ebx,head(%ecx)
+1:	pushl	%edx
+	call	_do_tty_interrupt
+	addl	$4,%esp
+	ret
+
+.align 2
+write_char:
+	movl	4(%ecx),%ecx		# write-queue
+	movl	head(%ecx),%ebx
+	subl	tail(%ecx),%ebx
+	andl	$size-1,%ebx		# nr chars in queue
+	je	write_buffer_empty
+	cmpl	$startup,%ebx
+	ja	1f
+	movl	proc_list(%ecx),%ebx	# wake up sleeping process
+	testl	%ebx,%ebx		# is there any?
+	je	1f
+	movl	$0,(%ebx)
+1:	movl	tail(%ecx),%ebx
+	movb	buf(%ecx,%ebx),%al
+	outb	%al,%dx
+	incl	%ebx
+	andl	$size-1,%ebx
+	movl	%ebx,tail(%ecx)
+	cmpl	head(%ecx),%ebx
+	je	write_buffer_empty
+	ret
+.align 2
+write_buffer_empty:
+	movl	proc_list(%ecx),%ebx	# wake up sleeping process
+	testl	%ebx,%ebx		# is there any?
+	je	1f
+	movl	$0,(%ebx)
+1:	incl	%edx
+	inb	%dx,%al
+	jmp	1f
+1:	jmp	1f
+1:	andb	$0xd,%al		/* disable transmit interrupt */
+	outb	%al,%dx
+	ret
diff --git a/kernel/serial.c b/kernel/chr_drv/serial.c
similarity index 61%
rename from kernel/serial.c
rename to kernel/chr_drv/serial.c
index 8a7f1a5..aba25df 100644
--- a/kernel/serial.c
+++ b/kernel/chr_drv/serial.c
@@ -1,9 +1,15 @@
 /*
- *      serial.c
+ *  linux/kernel/serial.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ *	serial.c
  *
  * This module implements the rs232 io functions
- *      void rs_write(struct tty_struct * queue);
- *      void rs_init(void);
+ *	void rs_write(struct tty_struct * queue);
+ *	void rs_init(void);
  * and all interrupts pertaining to serial IO.
  */
 
@@ -19,13 +25,13 @@ extern void rs2_interrupt(void);
 
 static void init(int port)
 {
-	outb_p(0x80,port+3);    /* set DLAB of line control reg */
-	outb_p(0x30,port);      /* LS of divisor (48 -> 2400 bps */
-	outb_p(0x00,port+1);    /* MS of divisor */
-	outb_p(0x03,port+3);    /* reset DLAB */
-	outb_p(0x0b,port+4);    /* set DTR,RTS, OUT_2 */
-	outb_p(0x0d,port+1);    /* enable all intrs but writes */
-	(void)inb(port);        /* read data port to reset things (?) */
+	outb_p(0x80,port+3);	/* set DLAB of line control reg */
+	outb_p(0x30,port);	/* LS of divisor (48 -> 2400 bps */
+	outb_p(0x00,port+1);	/* MS of divisor */
+	outb_p(0x03,port+3);	/* reset DLAB */
+	outb_p(0x0b,port+4);	/* set DTR,RTS, OUT_2 */
+	outb_p(0x0d,port+1);	/* enable all intrs but writes */
+	(void)inb(port);	/* read data port to reset things (?) */
 }
 
 void rs_init(void)
@@ -42,7 +48,7 @@ void rs_init(void)
  * the write_queue. It must check wheter the queue is empty, and
  * set the interrupt register accordingly
  *
- *      void _rs_write(struct tty_struct * tty);
+ *	void _rs_write(struct tty_struct * tty);
  */
 void rs_write(struct tty_struct * tty)
 {
diff --git a/kernel/tty_io.c b/kernel/chr_drv/tty_io.c
similarity index 62%
rename from kernel/tty_io.c
rename to kernel/chr_drv/tty_io.c
index 9673f19..92129c1 100644
--- a/kernel/tty_io.c
+++ b/kernel/chr_drv/tty_io.c
@@ -1,59 +1,70 @@
 /*
+ *  linux/kernel/tty_io.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  * 'tty_io.c' gives an orthogonal feeling to tty's, be they consoles
- * or rs-channels. It also implements echoing, cooked mode etc (well,
- * not currently, but ...)
+ * or rs-channels. It also implements echoing, cooked mode etc.
+ *
+ * Kill-line thanks to John T Kohl.
  */
 #include <ctype.h>
 #include <errno.h>
 #include <signal.h>
 
 #define ALRMMASK (1<<(SIGALRM-1))
+#define KILLMASK (1<<(SIGKILL-1))
+#define INTMASK (1<<(SIGINT-1))
+#define QUITMASK (1<<(SIGQUIT-1))
+#define TSTPMASK (1<<(SIGTSTP-1))
 
 #include <linux/sched.h>
 #include <linux/tty.h>
 #include <asm/segment.h>
 #include <asm/system.h>
 
-#define _L_FLAG(tty,f)  ((tty)->termios.c_lflag & f)
-#define _I_FLAG(tty,f)  ((tty)->termios.c_iflag & f)
-#define _O_FLAG(tty,f)  ((tty)->termios.c_oflag & f)
+#define _L_FLAG(tty,f)	((tty)->termios.c_lflag & f)
+#define _I_FLAG(tty,f)	((tty)->termios.c_iflag & f)
+#define _O_FLAG(tty,f)	((tty)->termios.c_oflag & f)
 
-#define L_CANON(tty)    _L_FLAG((tty),ICANON)
-#define L_ISIG(tty)     _L_FLAG((tty),ISIG)
-#define L_ECHO(tty)     _L_FLAG((tty),ECHO)
-#define L_ECHOE(tty)    _L_FLAG((tty),ECHOE)
-#define L_ECHOK(tty)    _L_FLAG((tty),ECHOK)
-#define L_ECHOCTL(tty)  _L_FLAG((tty),ECHOCTL)
-#define L_ECHOKE(tty)   _L_FLAG((tty),ECHOKE)
+#define L_CANON(tty)	_L_FLAG((tty),ICANON)
+#define L_ISIG(tty)	_L_FLAG((tty),ISIG)
+#define L_ECHO(tty)	_L_FLAG((tty),ECHO)
+#define L_ECHOE(tty)	_L_FLAG((tty),ECHOE)
+#define L_ECHOK(tty)	_L_FLAG((tty),ECHOK)
+#define L_ECHOCTL(tty)	_L_FLAG((tty),ECHOCTL)
+#define L_ECHOKE(tty)	_L_FLAG((tty),ECHOKE)
 
-#define I_UCLC(tty)     _I_FLAG((tty),IUCLC)
-#define I_NLCR(tty)     _I_FLAG((tty),INLCR)
-#define I_CRNL(tty)     _I_FLAG((tty),ICRNL)
-#define I_NOCR(tty)     _I_FLAG((tty),IGNCR)
+#define I_UCLC(tty)	_I_FLAG((tty),IUCLC)
+#define I_NLCR(tty)	_I_FLAG((tty),INLCR)
+#define I_CRNL(tty)	_I_FLAG((tty),ICRNL)
+#define I_NOCR(tty)	_I_FLAG((tty),IGNCR)
 
-#define O_POST(tty)     _O_FLAG((tty),OPOST)
-#define O_NLCR(tty)     _O_FLAG((tty),ONLCR)
-#define O_CRNL(tty)     _O_FLAG((tty),OCRNL)
-#define O_NLRET(tty)    _O_FLAG((tty),ONLRET)
-#define O_LCUC(tty)     _O_FLAG((tty),OLCUC)
+#define O_POST(tty)	_O_FLAG((tty),OPOST)
+#define O_NLCR(tty)	_O_FLAG((tty),ONLCR)
+#define O_CRNL(tty)	_O_FLAG((tty),OCRNL)
+#define O_NLRET(tty)	_O_FLAG((tty),ONLRET)
+#define O_LCUC(tty)	_O_FLAG((tty),OLCUC)
 
 struct tty_struct tty_table[] = {
 	{
-		{0,
-		OPOST|ONLCR,    /* change outgoing NL to CRNL */
+		{ICRNL,		/* change incoming CR to NL */
+		OPOST|ONLCR,	/* change outgoing NL to CRNL */
 		0,
-		ICANON | ECHO | ECHOCTL | ECHOKE,
-		0,              /* console termio */
+		ISIG | ICANON | ECHO | ECHOCTL | ECHOKE,
+		0,		/* console termio */
 		INIT_C_CC},
-		0,                      /* initial pgrp */
-		0,                      /* initial stopped */
+		0,			/* initial pgrp */
+		0,			/* initial stopped */
 		con_write,
-		{0,0,0,0,""},           /* console read-queue */
-		{0,0,0,0,""},           /* console write-queue */
-		{0,0,0,0,""}            /* console secondary queue */
+		{0,0,0,0,""},		/* console read-queue */
+		{0,0,0,0,""},		/* console write-queue */
+		{0,0,0,0,""}		/* console secondary queue */
 	},{
-		{0, /*IGNCR*/
-		OPOST | ONLRET,         /* change outgoing NL to CR */
+		{0, /* no translation */
+		0,  /* no translation */
 		B2400 | CS8,
 		0,
 		0,
@@ -61,12 +72,12 @@ struct tty_struct tty_table[] = {
 		0,
 		0,
 		rs_write,
-		{0x3f8,0,0,0,""},               /* rs 1 */
+		{0x3f8,0,0,0,""},		/* rs 1 */
 		{0x3f8,0,0,0,""},
 		{0,0,0,0,""}
 	},{
-		{0, /*IGNCR*/
-		OPOST | ONLRET,         /* change outgoing NL to CR */
+		{0, /* no translation */
+		0,  /* no translation */
 		B2400 | CS8,
 		0,
 		0,
@@ -74,7 +85,7 @@ struct tty_struct tty_table[] = {
 		0,
 		0,
 		rs_write,
-		{0x2f8,0,0,0,""},               /* rs 2 */
+		{0x2f8,0,0,0,""},		/* rs 2 */
 		{0x2f8,0,0,0,""},
 		{0,0,0,0,""}
 	}
@@ -97,7 +108,7 @@ void tty_init(void)
 	con_init();
 }
 
-void tty_intr(struct tty_struct * tty, int signal)
+void tty_intr(struct tty_struct * tty, int mask)
 {
 	int i;
 
@@ -105,7 +116,7 @@ void tty_intr(struct tty_struct * tty, int signal)
 		return;
 	for (i=0;i<NR_TASKS;i++)
 		if (task[i] && task[i]->pgrp==tty->pgrp)
-			task[i]->signal |= 1<<(signal-1);
+			task[i]->signal |= mask;
 }
 
 static void sleep_if_empty(struct tty_queue * queue)
@@ -126,6 +137,11 @@ static void sleep_if_full(struct tty_queue * queue)
 	sti();
 }
 
+void wait_for_keypress(void)
+{
+	sleep_if_empty(&tty_table[0].secondary);
+}
+
 void copy_to_cooked(struct tty_struct * tty)
 {
 	signed char c;
@@ -143,6 +159,21 @@ void copy_to_cooked(struct tty_struct * tty)
 		if (I_UCLC(tty))
 			c=tolower(c);
 		if (L_CANON(tty)) {
+			if (c==KILL_CHAR(tty)) {
+				/* deal with killing the input line */
+				while(!(EMPTY(tty->secondary) ||
+				      (c=LAST(tty->secondary))==10 ||
+				      c==EOF_CHAR(tty))) {
+					if (L_ECHO(tty)) {
+						if (c<32)
+							PUTCH(127,tty->write_q);
+						PUTCH(127,tty->write_q);
+						tty->write(tty);
+					}
+					DEC(tty->secondary.head);
+				}
+				continue;
+			}
 			if (c==ERASE_CHAR(tty)) {
 				if (EMPTY(tty->secondary) ||
 				   (c=LAST(tty->secondary))==10 ||
@@ -166,9 +197,13 @@ void copy_to_cooked(struct tty_struct * tty)
 				continue;
 			}
 		}
-		if (!L_ISIG(tty)) {
+		if (L_ISIG(tty)) {
 			if (c==INTR_CHAR(tty)) {
-				tty_intr(tty,SIGINT);
+				tty_intr(tty,INTMASK);
+				continue;
+			}
+			if (c==QUIT_CHAR(tty)) {
+				tty_intr(tty,QUITMASK);
 				continue;
 			}
 		}
@@ -202,8 +237,8 @@ int tty_read(unsigned channel, char * buf, int nr)
 	if (channel>2 || nr<0) return -1;
 	tty = &tty_table[channel];
 	oldalarm = current->alarm;
-	time = (unsigned) 10*tty->termios.c_cc[VTIME];
-	minimum = (unsigned) tty->termios.c_cc[VMIN];
+	time = 10L*tty->termios.c_cc[VTIME];
+	minimum = tty->termios.c_cc[VMIN];
 	if (time && !minimum) {
 		minimum=1;
 		if (flag=(!oldalarm || time+jiffies<oldalarm))
@@ -291,16 +326,24 @@ int tty_write(unsigned channel, char * buf, int nr)
 }
 
 /*
-* Jeh, sometimes I really like the 386.
-* This routine is called from an interrupt,
-* and there should be absolutely no problem
-* with sleeping even in an interrupt (I hope).
-* Of course, if somebody proves me wrong, I'll
-* hate intel for all time :-). We'll have to
-* be careful and see to reinstating the interrupt
-* chips before calling this, though.
-*/
+ * Jeh, sometimes I really like the 386.
+ * This routine is called from an interrupt,
+ * and there should be absolutely no problem
+ * with sleeping even in an interrupt (I hope).
+ * Of course, if somebody proves me wrong, I'll
+ * hate intel for all time :-). We'll have to
+ * be careful and see to reinstating the interrupt
+ * chips before calling this, though.
+ *
+ * I don't think we sleep here under normal circumstances
+ * anyway, which is good, as the task sleeping might be
+ * totally innocent.
+ */
 void do_tty_interrupt(int tty)
 {
 	copy_to_cooked(tty_table+tty);
 }
+
+void chr_dev_init(void)
+{
+}
diff --git a/fs/tty_ioctl.c b/kernel/chr_drv/tty_ioctl.c
similarity index 81%
rename from fs/tty_ioctl.c
rename to kernel/chr_drv/tty_ioctl.c
index 8fa1fa9..d6db48b 100644
--- a/fs/tty_ioctl.c
+++ b/kernel/chr_drv/tty_ioctl.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/kernel/chr_drv/tty_ioctl.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <errno.h>
 #include <termios.h>
 
@@ -5,9 +11,31 @@
 #include <linux/kernel.h>
 #include <linux/tty.h>
 
+#include <asm/io.h>
 #include <asm/segment.h>
 #include <asm/system.h>
 
+static unsigned short quotient[] = {
+	0, 2304, 1536, 1047, 857,
+	768, 576, 384, 192, 96,
+	64, 48, 24, 12, 6, 3
+};
+
+static void change_speed(struct tty_struct * tty)
+{
+	unsigned short port,quot;
+
+	if (!(port = tty->read_q.data))
+		return;
+	quot = quotient[tty->termios.c_cflag & CBAUD];
+	cli();
+	outb_p(0x80,port+3);		/* set DLAB */
+	outb_p(quot & 0xff,port);	/* LS of divisor */
+	outb_p(quot >> 8,port+1);	/* MS of divisor */
+	outb(0x03,port+3);		/* reset DLAB */
+	sti();
+}
+
 static void flush(struct tty_queue * queue)
 {
 	cli();
@@ -33,14 +61,15 @@ static int get_termios(struct tty_struct * tty, struct termios * termios)
 	for (i=0 ; i< (sizeof (*termios)) ; i++)
 		put_fs_byte( ((char *)&tty->termios)[i] , i+(char *)termios );
 	return 0;
-	}
+}
 
-	static int set_termios(struct tty_struct * tty, struct termios * termios)
-	{
+static int set_termios(struct tty_struct * tty, struct termios * termios)
+{
 	int i;
 
 	for (i=0 ; i< (sizeof (*termios)) ; i++)
 		((char *)&tty->termios)[i]=get_fs_byte(i+(char *)termios);
+	change_speed(tty);
 	return 0;
 }
 
@@ -62,6 +91,9 @@ static int get_termio(struct tty_struct * tty, struct termio * termio)
 	return 0;
 }
 
+/*
+ * This only works as the 386 is low-byt-first
+ */
 static int set_termio(struct tty_struct * tty, struct termio * termio)
 {
 	int i;
@@ -76,6 +108,7 @@ static int set_termio(struct tty_struct * tty, struct termio * termio)
 	tty->termios.c_line = tmp_termio.c_line;
 	for(i=0 ; i < NCC ; i++)
 		tty->termios.c_cc[i] = tmp_termio.c_cc[i];
+	change_speed(tty);
 	return 0;
 }
 
@@ -83,8 +116,8 @@ int tty_ioctl(int dev, int cmd, int arg)
 {
 	struct tty_struct * tty;
 	if (MAJOR(dev) == 5) {
-		dev=current->tty;
-		if (dev<0)
+		dev = current->tty;
+		if (dev < 0)
 			panic("tty_ioctl: dev<0");
 	} else
 		dev=MINOR(dev);
@@ -142,6 +175,11 @@ int tty_ioctl(int dev, int cmd, int arg)
 			verify_area((void *) arg,4);
 			put_fs_long(CHARS(tty->write_q),(unsigned long *) arg);
 			return 0;
+		case TIOCINQ:
+			verify_area((void *) arg,4);
+			put_fs_long(CHARS(tty->secondary),
+				(unsigned long *) arg);
+			return 0;
 		case TIOCSTI:
 			return -EINVAL; /* not implemented */
 		case TIOCGWINSZ:
diff --git a/kernel/console.c b/kernel/console.c
deleted file mode 100644
index c953554..0000000
--- a/kernel/console.c
+++ /dev/null
@@ -1,550 +0,0 @@
-/*
- *      console.c
- *
- * This module implements the console io functions
- *      'void con_init(void)'
- *      'void con_write(struct tty_queue * queue)'
- * Hopefully this will be a rather complete VT102 implementation.
- *
- */
-
-/*
- *  NOTE!!! We sometimes disable and enable interrupts for a short while
- * (to put a word in video IO), but this will work even for keyboard
- * interrupts. We know interrupts aren't enabled when getting a keyboard
- * interrupt, as we use trap-gates. Hopefully all is well.
- */
-
-#include <linux/sched.h>
-#include <linux/tty.h>
-#include <asm/io.h>
-#include <asm/system.h>
-
-#define SCREEN_START 0xb8000
-#define SCREEN_END   0xc0000
-#define LINES 25
-#define COLUMNS 80
-#define NPAR 16
-
-extern void keyboard_interrupt(void);
-
-static unsigned long origin=SCREEN_START;
-static unsigned long scr_end=SCREEN_START+LINES*COLUMNS*2;
-static unsigned long pos;
-static unsigned long x,y;
-static unsigned long top=0,bottom=LINES;
-static unsigned long lines=LINES,columns=COLUMNS;
-static unsigned long state=0;
-static unsigned long npar,par[NPAR];
-static unsigned long ques=0;
-static unsigned char attr=0x07;
-
-/*
- * this is what the terminal answers to a ESC-Z or csi0c
- * query (= vt100 response).
- */
-#define RESPONSE "\033[?1;2c"
-
-static inline void gotoxy(unsigned int new_x,unsigned int new_y)
-{
-	if (new_x>=columns || new_y>=lines)
-		return;
-	x=new_x;
-	y=new_y;
-	pos=origin+((y*columns+x)<<1);
-}
-
-static inline void set_origin(void)
-{
-	cli();
-	outb_p(12,0x3d4);
-	outb_p(0xff&((origin-SCREEN_START)>>9),0x3d5);
-	outb_p(13,0x3d4);
-	outb_p(0xff&((origin-SCREEN_START)>>1),0x3d5);
-	sti();
-}
-
-static void scrup(void)
-{
-	if (!top && bottom==lines) {
-		origin += columns<<1;
-		pos += columns<<1;
-		scr_end += columns<<1;
-		if (scr_end>SCREEN_END) {
-			__asm__("cld\n\t"
-				"rep\n\t"
-				"movsl\n\t"
-				"movl _columns,%1\n\t"
-				"rep\n\t"
-				"stosw"
-				::"a" (0x0720),
-				"c" ((lines-1)*columns>>1),
-				"D" (SCREEN_START),
-				"S" (origin)
-				:"cx","di","si");
-			scr_end -= origin-SCREEN_START;
-			pos -= origin-SCREEN_START;
-			origin = SCREEN_START;
-		} else {
-			__asm__("cld\n\t"
-				"rep\n\t"
-				"stosl"
-				::"a" (0x07200720),
-				"c" (columns>>1),
-				"D" (scr_end-(columns<<1))
-				:"cx","di");
-		}
-		set_origin();
-	} else {
-		__asm__("cld\n\t"
-			"rep\n\t"
-			"movsl\n\t"
-			"movl _columns,%%ecx\n\t"
-			"rep\n\t"
-			"stosw"
-			::"a" (0x0720),
-			"c" ((bottom-top-1)*columns>>1),
-			"D" (origin+(columns<<1)*top),
-			"S" (origin+(columns<<1)*(top+1))
-			:"cx","di","si");
-	}
-}
-
-static void scrdown(void)
-{
-	__asm__("std\n\t"
-		"rep\n\t"
-		"movsl\n\t"
-		"addl $2,%%edi\n\t"     /* %edi has been decremented by 4 */
-		"movl _columns,%%ecx\n\t"
-		"rep\n\t"
-		"stosw"
-		::"a" (0x0720),
-		"c" ((bottom-top-1)*columns>>1),
-		"D" (origin+(columns<<1)*bottom-4),
-		"S" (origin+(columns<<1)*(bottom-1)-4)
-		:"ax","cx","di","si");
-}
-
-static void lf(void)
-{
-	if (y+1<bottom) {
-		y++;
-		pos += columns<<1;
-		return;
-	}
-	scrup();
-}
-
-static void ri(void)
-{
-	if (y>top) {
-		y--;
-		pos -= columns<<1;
-		return;
-	}
-	scrdown();
-}
-
-static void cr(void)
-{
-	pos -= x<<1;
-	x=0;
-}
-
-static void del(void)
-{
-	if (x) {
-		pos -= 2;
-		x--;
-		*(unsigned short *)pos = 0x0720;
-	}
-}
-
-static void csi_J(int par)
-{
-	long count __asm__("cx");
-	long start __asm__("di");
-
-	switch (par) {
-		case 0: /* erase from cursor to end of display */
-			count = (scr_end-pos)>>1;
-			start = pos;
-			break;
-		case 1: /* erase from start to cursor */
-			count = (pos-origin)>>1;
-			start = origin;
-			break;
-		case 2: /* erase whole display */
-			count = columns*lines;
-			start = origin;
-			break;
-		default:
-			return;
-	}
-	__asm__("cld\n\t"
-		"rep\n\t"
-		"stosw\n\t"
-		::"c" (count),
-		"D" (start),"a" (0x0720)
-		:"cx","di");
-}
-
-static void csi_K(int par)
-{
-	long count __asm__("cx");
-	long start __asm__("di");
-
-	switch (par) {
-		case 0: /* erase from cursor to end of line */
-			if (x>=columns)
-				return;
-			count = columns-x;
-			start = pos;
-			break;
-		case 1: /* erase from start of line to cursor */
-			start = pos - (x<<1);
-			count = (x<columns)?x:columns;
-			break;
-		case 2: /* erase whole line */
-			start = pos - (x<<1);
-			count = columns;
-			break;
-		default:
-			return;
-	}
-	__asm__("cld\n\t"
-		"rep\n\t"
-		"stosw\n\t"
-		::"c" (count),
-		"D" (start),"a" (0x0720)
-		:"cx","di");
-}
-
-void csi_m(void)
-{
-	int i;
-
-	for (i=0;i<=npar;i++)
-		switch (par[i]) {
-			case 0:attr=0x07;break;
-			case 1:attr=0x0f;break;
-			case 4:attr=0x0f;break;
-			case 7:attr=0x70;break;
-			case 27:attr=0x07;break;
-		}
-}
-
-static inline void set_cursor(void)
-{
-	cli();
-	outb_p(14,0x3d4);
-	outb_p(0xff&((pos-SCREEN_START)>>9),0x3d5);
-	outb_p(15,0x3d4);
-	outb_p(0xff&((pos-SCREEN_START)>>1),0x3d5);
-	sti();
-}
-
-static void respond(struct tty_struct * tty)
-{
-	char * p = RESPONSE;
-
-	cli();
-	while (*p) {
-		PUTCH(*p,tty->read_q);
-		p++;
-	}
-	sti();
-	copy_to_cooked(tty);
-}
-
-static void insert_char(void)
-{
-	int i=x;
-	unsigned short tmp,old=0x0720;
-	unsigned short * p = (unsigned short *) pos;
-
-	while (i++<columns) {
-		tmp=*p;
-		*p=old;
-		old=tmp;
-		p++;
-	}
-}
-
-static void insert_line(void)
-{
-	int oldtop,oldbottom;
-
-	oldtop=top;
-	oldbottom=bottom;
-	top=y;
-	bottom=lines;
-	scrdown();
-	top=oldtop;
-	bottom=oldbottom;
-}
-
-static void delete_char(void)
-{
-	int i;
-	unsigned short * p = (unsigned short *) pos;
-
-	if (x>=columns)
-		return;
-	i = x;
-	while (++i < columns) {
-		*p = *(p+1);
-		p++;
-	}
-	*p=0x0720;
-}
-
-static void delete_line(void)
-{
-	int oldtop,oldbottom;
-
-	oldtop=top;
-	oldbottom=bottom;
-	top=y;
-	bottom=lines;
-	scrup();
-	top=oldtop;
-	bottom=oldbottom;
-}
-
-static void csi_at(int nr)
-{
-	if (nr>columns)
-		nr=columns;
-	else if (!nr)
-		nr=1;
-	while (nr--)
-		insert_char();
-}
-
-static void csi_L(int nr)
-{
-	if (nr>lines)
-		nr=lines;
-	else if (!nr)
-		nr=1;
-	while (nr--)
-		insert_line();
-}
-
-static void csi_P(int nr)
-{
-	if (nr>columns)
-		nr=columns;
-	else if (!nr)
-		nr=1;
-	while (nr--)
-		delete_char();
-}
-
-static void csi_M(int nr)
-{
-	if (nr>lines)
-		nr=lines;
-	else if (!nr)
-		nr=1;
-	while (nr--)
-		delete_line();
-}
-
-static int saved_x=0;
-static int saved_y=0;
-
-static void save_cur(void)
-{
-	saved_x=x;
-	saved_y=y;
-}
-
-static void restore_cur(void)
-{
-	x=saved_x;
-	y=saved_y;
-	pos=origin+((y*columns+x)<<1);
-}
-
-void con_write(struct tty_struct * tty)
-{
-	int nr;
-	char c;
-
-	nr = CHARS(tty->write_q);
-	while (nr--) {
-		GETCH(tty->write_q,c);
-		switch(state) {
-			case 0:
-				if (c>31 && c<127) {
-					if (x>=columns) {
-						x -= columns;
-						pos -= columns<<1;
-						lf();
-					}
-					__asm__("movb _attr,%%ah\n\t"
-						"movw %%ax,%1\n\t"
-						::"a" (c),"m" (*(short *)pos)
-						:"ax");
-					pos += 2;
-					x++;
-				} else if (c==27)
-					state=1;
-				else if (c==10 || c==11 || c==12)
-					lf();
-				else if (c==13)
-					cr();
-				else if (c==ERASE_CHAR(tty))
-					del();
-				else if (c==8) {
-					if (x) {
-						x--;
-						pos -= 2;
-					}
-				} else if (c==9) {
-					c=8-(x&7);
-					x += c;
-					pos += c<<1;
-					if (x>columns) {
-						x -= columns;
-						pos -= columns<<1;
-						lf();
-					}
-					c=9;
-				}
-				break;
-			case 1:
-				state=0;
-				if (c=='[')
-					state=2;
-				else if (c=='E')
-					gotoxy(0,y+1);
-				else if (c=='M')
-					ri();
-				else if (c=='D')
-					lf();
-				else if (c=='Z')
-					respond(tty);
-				else if (x=='7')
-					save_cur();
-				else if (x=='8')
-					restore_cur();
-				break;
-			case 2:
-				for(npar=0;npar<NPAR;npar++)
-					par[npar]=0;
-				npar=0;
-				state=3;
-				if (ques=(c=='?'))
-					break;
-			case 3:
-				if (c==';' && npar<NPAR-1) {
-					npar++;
-					break;
-				} else if (c>='' && c<='9') {
-					par[npar]=10*par[npar]+c-'';
-					break;
-				} else state=4;
-			case 4:
-				state=0;
-				switch(c) {
-					case 'G': case '`':
-						if (par[0]) par[0]--;
-						gotoxy(par[0],y);
-						break;
-					case 'A':
-						if (!par[0]) par[0]++;
-						gotoxy(x,y-par[0]);
-						break;
-					case 'B': case 'e':
-						if (!par[0]) par[0]++;
-						gotoxy(x,y+par[0]);
-						break;
-					case 'C': case 'a':
-						if (!par[0]) par[0]++;
-						gotoxy(x+par[0],y);
-						break;
-					case 'D':
-						if (!par[0]) par[0]++;
-						gotoxy(x-par[0],y);
-						break;
-					case 'E':
-						if (!par[0]) par[0]++;
-						gotoxy(0,y+par[0]);
-						break;
-					case 'F':
-						if (!par[0]) par[0]++;
-						gotoxy(0,y-par[0]);
-						break;
-					case 'd':
-						if (par[0]) par[0]--;
-						gotoxy(x,par[0]);
-						break;
-					case 'H': case 'f':
-						if (par[0]) par[0]--;
-						if (par[1]) par[1]--;
-						gotoxy(par[1],par[0]);
-						break;
-					case 'J':
-						csi_J(par[0]);
-						break;
-					case 'K':
-						csi_K(par[0]);
-						break;
-					case 'L':
-						csi_L(par[0]);
-						break;
-					case 'M':
-						csi_M(par[0]);
-						break;
-					case 'P':
-						csi_P(par[0]);
-						break;
-					case '@':
-						csi_at(par[0]);
-						break;
-					case 'm':
-						csi_m();
-						break;
-					case 'r':
-						if (par[0]) par[0]--;
-						if (!par[1]) par[1]=lines;
-						if (par[0] < par[1] &&
-						    par[1] <= lines) {
-							top=par[0];
-							bottom=par[1];
-						}
-						break;
-					case 's':
-						save_cur();
-						break;
-					case 'u':
-						restore_cur();
-						break;
-				}
-		}
-	}
-	set_cursor();
-}
-
-/*
-*  void con_init(void);
-*
-* This routine initalizes console interrupts, and does nothing
-* else. If you want the screen to clear, call tty_write with
-* the appropriate escape-sequece.
-*/
-void con_init(void)
-{
-	register unsigned char a;
-
-	gotoxy(*(unsigned char *)(0x90000+510),*(unsigned char *)(0x90000+511));
-	set_trap_gate(0x21,&keyboard_interrupt);
-	outb_p(inb_p(0x21)&0xfd,0x21);
-	a=inb_p(0x61);
-	outb_p(a|0x80,0x61);
-	outb(a,0x61);
-}
diff --git a/kernel/exit.c b/kernel/exit.c
index 7136871..6c9eeea 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/kernel/exit.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <errno.h>
 #include <signal.h>
 #include <sys/wait.h>
@@ -26,39 +32,71 @@ void release(struct task_struct * p)
 	panic("trying to release non-existent task");
 }
 
-static inline void send_sig(long sig,struct task_struct * p,int priv)
+static inline int send_sig(long sig,struct task_struct * p,int priv)
 {
 	if (!p || sig<1 || sig>32)
-		return;
-	if (priv ||
-	    current->uid==p->uid ||
-	    current->euid==p->uid ||
-	    current->uid==p->euid ||
-	    current->euid==p->euid)
+		return -EINVAL;
+	if (priv || (current->euid==p->euid) || suser())
 		p->signal |= (1<<(sig-1));
+	else
+		return -EPERM;
+	return 0;
+}
+
+static void kill_session(void)
+{
+	struct task_struct **p = NR_TASKS + task;
+
+	while (--p > &FIRST_TASK) {
+		if (*p && (*p)->session == current->session)
+			(*p)->signal |= 1<<(SIGHUP-1);
+	}
 }
 
-void do_kill(long pid,long sig,int priv)
+/*
+ * XXX need to check permissions needed to send signals to process
+ * groups, etc. etc.  kill() permissions semantics are tricky!
+ */
+int sys_kill(int pid,int sig)
 {
 	struct task_struct **p = NR_TASKS + task;
+	int err, retval = 0;
 
 	if (!pid) while (--p > &FIRST_TASK) {
 		if (*p && (*p)->pgrp == current->pid)
-			send_sig(sig,*p,priv);
+			if (err=send_sig(sig,*p,1))
+				retval = err;
 	} else if (pid>0) while (--p > &FIRST_TASK) {
 		if (*p && (*p)->pid == pid)
-			send_sig(sig,*p,priv);
+			if (err=send_sig(sig,*p,0))
+				retval = err;
 	} else if (pid == -1) while (--p > &FIRST_TASK)
-		send_sig(sig,*p,priv);
+		if (err = send_sig(sig,*p,0))
+			retval = err;
 	else while (--p > &FIRST_TASK)
 		if (*p && (*p)->pgrp == -pid)
-			send_sig(sig,*p,priv);
+			if (err = send_sig(sig,*p,0))
+				retval = err;
+	return retval;
 }
 
-int sys_kill(int pid,int sig)
+static void tell_father(int pid)
 {
-	do_kill(pid,sig,!(current->uid || current->euid));
-	return 0;
+	int i;
+
+	if (pid)
+		for (i=0;i<NR_TASKS;i++) {
+			if (!task[i])
+				continue;
+			if (task[i]->pid != pid)
+				continue;
+			task[i]->signal |= (1<<(SIGCHLD-1));
+			return;
+		}
+/* if we don't find any fathers, we just release ourselves */
+/* This is not really OK. Must change it to make father 1 */
+	printk("BAD BAD - no father found\n\r");
+	release(current);
 }
 
 int do_exit(long code)
@@ -68,8 +106,12 @@ int do_exit(long code)
 	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
 	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
 	for (i=0 ; i<NR_TASKS ; i++)
-		if (task[i] && task[i]->father == current->pid)
-			task[i]->father = 0;
+		if (task[i] && task[i]->father == current->pid) {
+			task[i]->father = 1;
+			if (task[i]->state == TASK_ZOMBIE)
+				/* assumption task[1] is always init */
+				(void) send_sig(SIGCHLD, task[1], 1);
+		}
 	for (i=0 ; i<NR_OPEN ; i++)
 		if (current->filp[i])
 			sys_close(i);
@@ -77,16 +119,17 @@ int do_exit(long code)
 	current->pwd = NULL;
 	iput(current->root);
 	current->root = NULL;
+	iput(current->executable);
+	current->executable = NULL;
 	if (current->leader && current->tty >= 0)
 		tty_table[current->tty].pgrp = 0;
 	if (last_task_used_math == current)
 		last_task_used_math = NULL;
-	if (current->father) {
-		current->state = TASK_ZOMBIE;
-		do_kill(current->father,SIGCHLD,1);
-		current->exit_code = code;
-	} else
-		release(current);
+	if (current->leader)
+		kill_session();
+	current->state = TASK_ZOMBIE;
+	current->exit_code = code;
+	tell_father(current->father);
 	schedule();
 	return (-1);	/* just to suppress warnings */
 }
@@ -96,34 +139,53 @@ int sys_exit(int error_code)
 	return do_exit((error_code&0xff)<<8);
 }
 
-int sys_waitpid(pid_t pid,int * stat_addr, int options)
+int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)
 {
-	int flag=0;
+	int flag, code;
 	struct task_struct ** p;
 
 	verify_area(stat_addr,4);
 repeat:
-	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
-		if (*p && *p != current &&
-		   (pid==-1 || (*p)->pid==pid ||
-		   (pid==0 && (*p)->pgrp==current->pgrp) ||
-		   (pid<0 && (*p)->pgrp==-pid)))
-			if ((*p)->father == current->pid) {
+	flag=0;
+	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
+		if (!*p || *p == current)
+			continue;
+		if ((*p)->father != current->pid)
+			continue;
+		if (pid>0) {
+			if ((*p)->pid != pid)
+				continue;
+		} else if (!pid) {
+			if ((*p)->pgrp != current->pgrp)
+				continue;
+		} else if (pid != -1) {
+			if ((*p)->pgrp != -pid)
+				continue;
+		}
+		switch ((*p)->state) {
+			case TASK_STOPPED:
+				if (!(options & WUNTRACED))
+					continue;
+				put_fs_long(0x7f,stat_addr);
+				return (*p)->pid;
+			case TASK_ZOMBIE:
+				current->cutime += (*p)->utime;
+				current->cstime += (*p)->stime;
+				flag = (*p)->pid;
+				code = (*p)->exit_code;
+				release(*p);
+				put_fs_long(code,stat_addr);
+				return flag;
+			default:
 				flag=1;
-				if ((*p)->state==TASK_ZOMBIE) {
-					put_fs_long((*p)->exit_code,
-						(unsigned long *) stat_addr);
-					current->cutime += (*p)->utime;
-					current->cstime += (*p)->stime;
-					flag = (*p)->pid;
-					release(*p);
-					return flag;
-				}
-			}
+				continue;
+		}
+	}
 	if (flag) {
 		if (options & WNOHANG)
 			return 0;
-		sys_pause();
+		current->state=TASK_INTERRUPTIBLE;
+		schedule();
 		if (!(current->signal &= ~(1<<(SIGCHLD-1))))
 			goto repeat;
 		else
diff --git a/kernel/fork.c b/kernel/fork.c
index 70f9ddd..38a997a 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1,4 +1,10 @@
 /*
+ *  linux/kernel/fork.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  *  'fork.c' contains the help-routines for the 'fork' system call
  * (see also system_call.s), and some misc functions ('verify_area').
  * Fork is rather simple, once you get the hang of it, but the memory
@@ -44,6 +50,7 @@ int copy_mem(int nr,struct task_struct * p)
 	if (data_limit < code_limit)
 		panic("Bad data_limit");
 	new_data_base = new_code_base = nr * 0x4000000;
+	p->start_code = new_code_base;
 	set_base(p->ldt[1],new_code_base);
 	set_base(p->ldt[2],new_data_base);
 	if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
@@ -70,8 +77,9 @@ int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
 	p = (struct task_struct *) get_free_page();
 	if (!p)
 		return -EAGAIN;
+	task[nr] = p;
 	*p = *current;	/* NOTE! this doesn't copy the supervisor stack */
-	p->state = TASK_RUNNING;
+	p->state = TASK_UNINTERRUPTIBLE;
 	p->pid = last_pid;
 	p->father = current->pid;
 	p->counter = p->priority;
@@ -103,8 +111,9 @@ int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
 	p->tss.ldt = _LDT(nr);
 	p->tss.trace_bitmap = 0x80000000;
 	if (last_task_used_math == current)
-		__asm__("fnsave %0"::"m" (p->tss.i387));
+		__asm__("clts ; fnsave %0"::"m" (p->tss.i387));
 	if (copy_mem(nr,p)) {
+		task[nr] = NULL;
 		free_page((long) p);
 		return -EAGAIN;
 	}
@@ -115,9 +124,11 @@ int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
 		current->pwd->i_count++;
 	if (current->root)
 		current->root->i_count++;
+	if (current->executable)
+		current->executable->i_count++;
 	set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
 	set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
-	task[nr] = p;	/* do this last, just in case */
+	p->state = TASK_RUNNING;	/* do this last, just in case */
 	return last_pid;
 }
 
diff --git a/kernel/hd.c b/kernel/hd.c
deleted file mode 100644
index ca52cb2..0000000
--- a/kernel/hd.c
+++ /dev/null
@@ -1,413 +0,0 @@
-#include <linux/config.h>
-#include <linux/sched.h>
-#include <linux/fs.h>
-#include <linux/kernel.h>
-#include <linux/hdreg.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/segment.h>
-
-/*
- * This code handles all hd-interrupts, and read/write requests to
- * the hard-disk. It is relatively straigthforward (not obvious maybe,
- * but interrupts never are), while still being efficient, and never
- * disabling interrupts (except to overcome possible race-condition).
- * The elevator block-seek algorithm doesn't need to disable interrupts
- * due to clever programming.
- */
-
-/* Max read/write errors/sector */
-#define MAX_ERRORS      5
-#define MAX_HD          2
-#define NR_REQUEST      32
-
-/*
- *  This struct defines the HD's and their types.
- *  Currently defined for CP3044's, ie a modified
- *  type 17.
- */
-static struct hd_i_struct{
-	int head,sect,cyl,wpcom,lzone,ctl;
-	} hd_info[]= { HD_TYPE };
-
-#define NR_HD ((sizeof (hd_info))/(sizeof (struct hd_i_struct)))
-
-static struct hd_struct {
-	long start_sect;
-	long nr_sects;
-} hd[5*MAX_HD]={{0,0},};
-
-static struct hd_request {
-	int hd;         /* -1 if no request */
-	int nsector;
-	int sector;
-	int head;
-	int cyl;
-	int cmd;
-	int errors;
-	struct buffer_head * bh;
-	struct hd_request * next;
-} request[NR_REQUEST];
-
-#define IN_ORDER(s1,s2) \
-((s1)->hd<(s2)->hd || (s1)->hd==(s2)->hd && \
-((s1)->cyl<(s2)->cyl || (s1)->cyl==(s2)->cyl && \
-((s1)->head<(s2)->head || (s1)->head==(s2)->head && \
-((s1)->sector<(s2)->sector))))
-
-static struct hd_request * this_request = NULL;
-
-static int sorting=0;
-
-static void do_request(void);
-static void reset_controller(void);
-static void rw_abs_hd(int rw,unsigned int nr,unsigned int sec,unsigned int head,
-	unsigned int cyl,struct buffer_head * bh);
-void hd_init(void);
-
-#define port_read(port,buf,nr) \
-__asm__("cld;rep;insw"::"d" (port),"D" (buf),"c" (nr):"cx","di")
-
-#define port_write(port,buf,nr) \
-__asm__("cld;rep;outsw"::"d" (port),"S" (buf),"c" (nr):"cx","si")
-
-extern void hd_interrupt(void);
-
-static struct task_struct * wait_for_request=NULL;
-
-static inline void lock_buffer(struct buffer_head * bh)
-{
-	if (bh->b_lock)
-		printk("hd.c: buffer multiply locked\n");
-	bh->b_lock=1;
-}
-
-static inline void unlock_buffer(struct buffer_head * bh)
-{
-	if (!bh->b_lock)
-		printk("hd.c: free buffer being unlocked\n");
-	bh->b_lock=0;
-	wake_up(&bh->b_wait);
-}
-
-static inline void wait_on_buffer(struct buffer_head * bh)
-{
-	cli();
-	while (bh->b_lock)
-		sleep_on(&bh->b_wait);
-	sti();
-}
-
-void rw_hd(int rw, struct buffer_head * bh)
-{
-	unsigned int block,dev;
-	unsigned int sec,head,cyl;
-
-	block = bh->b_blocknr << 1;
-	dev = MINOR(bh->b_dev);
-	if (dev >= 5*NR_HD || block+2 > hd[dev].nr_sects)
-		return;
-	block += hd[dev].start_sect;
-	dev /= 5;
-	__asm__("divl %4":"=a" (block),"=d" (sec):"" (block),"1" (0),
-		"r" (hd_info[dev].sect));
-	__asm__("divl %4":"=a" (cyl),"=d" (head):"" (block),"1" (0),
-		"r" (hd_info[dev].head));
-	rw_abs_hd(rw,dev,sec+1,head,cyl,bh);
-}
-
-/* This may be used only once, enforced by 'static int callable' */
-int sys_setup(void)
-{
-	static int callable = 1;
-	int i,drive;
-	struct partition *p;
-
-	if (!callable)
-		return -1;
-	callable = 0;
-	for (drive=0 ; drive<NR_HD ; drive++) {
-		rw_abs_hd(READ,drive,1,0,0,(struct buffer_head *) start_buffer);
-		if (!start_buffer->b_uptodate) {
-			printk("Unable to read partition table of drive %d\n\r",
-				drive);
-			panic("");
-		}
-		if (start_buffer->b_data[510] != 0x55 || (unsigned char)
-		    start_buffer->b_data[511] != 0xAA) {
-			printk("Bad partition table on drive %d\n\r",drive);
-			panic("");
-		}
-		p = 0x1BE + (void *)start_buffer->b_data;
-		for (i=1;i<5;i++,p++) {
-			hd[i+5*drive].start_sect = p->start_sect;
-			hd[i+5*drive].nr_sects = p->nr_sects;
-		}
-	}
-	printk("Partition table%s ok.\n\r",(NR_HD>1)?"s":"");
-	mount_root();
-	return (0);
-}
-
-/*
-* This is the pointer to a routine to be executed at every hd-interrupt.
-* Interesting way of doing things, but should be rather practical.
-*/
-void (*do_hd)(void) = NULL;
-
-static int controller_ready(void)
-{
-	int retries=1000;
-
-	while (--retries && (inb(HD_STATUS)&0xc0)!=0x40);
-	return (retries);
-}
-
-static int win_result(void)
-{
-	int i=inb(HD_STATUS);
-
-	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
-	    == (READY_STAT | SEEK_STAT))
-		return(0); /* ok */
-	if (i&1) i=inb(HD_ERROR);
-	return (1);
-}
-
-static void hd_out(unsigned int drive,unsigned int nsect,unsigned int sect,
-		unsigned int head,unsigned int cyl,unsigned int cmd,
-		void (*intr_addr)(void))
-{
-	register int port asm("dx");
-
-	if (drive>1 || head>15)
-		panic("Trying to write bad sector");
-	if (!controller_ready())
-		panic("HD controller not ready");
-	do_hd = intr_addr;
-	outb(_CTL,HD_CMD);
-	port=HD_DATA;
-	outb_p(_WPCOM,++port);
-	outb_p(nsect,++port);
-	outb_p(sect,++port);
-	outb_p(cyl,++port);
-	outb_p(cyl>>8,++port);
-	outb_p(0xA0|(drive<<4)|head,++port);
-	outb(cmd,++port);
-}
-
-static int drive_busy(void)
-{
-	unsigned int i;
-
-	for (i = 0; i < 100000; i++)
-		if (READY_STAT == (inb(HD_STATUS) & (BUSY_STAT | READY_STAT)))
-			break;
-	i = inb(HD_STATUS);
-	i &= BUSY_STAT | READY_STAT | SEEK_STAT;
-	if (i == READY_STAT | SEEK_STAT)
-		return(0);
-	printk("HD controller times out\n\r");
-	return(1);
-}
-
-static void reset_controller(void)
-{
-	int     i;
-
-	outb(4,HD_CMD);
-	for(i = 0; i < 1000; i++) nop();
-	outb(0,HD_CMD);
-	for(i = 0; i < 10000 && drive_busy(); i++) /* nothing */;
-	if (drive_busy())
-		printk("HD-controller still busy\n\r");
-	if((i = inb(ERR_STAT)) != 1)
-		printk("HD-controller reset failed: %02x\n\r",i);
-}
-
-static void reset_hd(int nr)
-{
-	reset_controller();
-	hd_out(nr,_SECT,_SECT,_HEAD-1,_CYL,WIN_SPECIFY,&do_request);
-	}
-
-	void unexpected_hd_interrupt(void)
-	{
-	panic("Unexpected HD interrupt\n\r");
-}
-
-static void bad_rw_intr(void)
-{
-	int i = this_request->hd;
-
-	if (this_request->errors++ >= MAX_ERRORS) {
-		this_request->bh->b_uptodate = 0;
-		unlock_buffer(this_request->bh);
-		wake_up(&wait_for_request);
-		this_request->hd = -1;
-		this_request=this_request->next;
-	}
-	reset_hd(i);
-}
-
-static void read_intr(void)
-{
-	if (win_result()) {
-		bad_rw_intr();
-		return;
-	}
-	port_read(HD_DATA,this_request->bh->b_data+
-		512*(this_request->nsector&1),256);
-	this_request->errors = 0;
-	if (--this_request->nsector)
-		return;
-	this_request->bh->b_uptodate = 1;
-	this_request->bh->b_dirt = 0;
-	wake_up(&wait_for_request);
-	unlock_buffer(this_request->bh);
-	this_request->hd = -1;
-	this_request=this_request->next;
-	do_request();
-	}
-
-	static void write_intr(void)
-	{
-	if (win_result()) {
-		bad_rw_intr();
-		return;
-	}
-	if (--this_request->nsector) {
-		port_write(HD_DATA,this_request->bh->b_data+512,256);
-		return;
-	}
-	this_request->bh->b_uptodate = 1;
-	this_request->bh->b_dirt = 0;
-	wake_up(&wait_for_request);
-	unlock_buffer(this_request->bh);
-	this_request->hd = -1;
-	this_request=this_request->next;
-	do_request();
-}
-
-static void do_request(void)
-{
-	int i,r;
-
-	if (sorting)
-		return;
-	if (!this_request) {
-		do_hd=NULL;
-		return;
-	}
-	if (this_request->cmd == WIN_WRITE) {
-		hd_out(this_request->hd,this_request->nsector,this_request->
-			sector,this_request->head,this_request->cyl,
-			this_request->cmd,&write_intr);
-		for(i=0 ; i<3000 && !(r=inb_p(HD_STATUS)&DRQ_STAT) ; i++)
-			/* nothing */ ;
-		if (!r) {
-			reset_hd(this_request->hd);
-			return;
-		}
-		port_write(HD_DATA,this_request->bh->b_data+
-			512*(this_request->nsector&1),256);
-	} else if (this_request->cmd == WIN_READ) {
-		hd_out(this_request->hd,this_request->nsector,this_request->
-			sector,this_request->head,this_request->cyl,
-			this_request->cmd,&read_intr);
-	} else
-		panic("unknown hd-command");
-}
-
-/*
-* add-request adds a request to the linked list.
-* It sets the 'sorting'-variable when doing something
-* that interrupts shouldn't touch.
-*/
-static void add_request(struct hd_request * req)
-{
-	struct hd_request * tmp;
-
-	if (req->nsector != 2)
-		panic("nsector!=2 not implemented");
-/*
-* Not to mess up the linked lists, we never touch the two first
-* entries (not this_request, as it is used by current interrups,
-* and not this_request->next, as it can be assigned to this_request).
-* This is not too high a price to pay for the ability of not
-* disabling interrupts.
-*/
-	sorting=1;
-	if (!(tmp=this_request))
-		this_request=req;
-	else {
-		if (!(tmp->next))
-			tmp->next=req;
-		else {
-			tmp=tmp->next;
-			for ( ; tmp->next ; tmp=tmp->next)
-				if ((IN_ORDER(tmp,req) ||
-				    !IN_ORDER(tmp,tmp->next)) &&
-				    IN_ORDER(req,tmp->next))
-					break;
-			req->next=tmp->next;
-			tmp->next=req;
-		}
-	}
-	sorting=0;
-/*
-* NOTE! As a result of sorting, the interrupts may have died down,
-* as they aren't redone due to locking with sorting=1. They might
-* also never have started, if this is the first request in the queue,
-* so we restart them if necessary.
-*/
-	if (!do_hd)
-		do_request();
-}
-
-void rw_abs_hd(int rw,unsigned int nr,unsigned int sec,unsigned int head,
-	unsigned int cyl,struct buffer_head * bh)
-{
-	struct hd_request * req;
-
-	if (rw!=READ && rw!=WRITE)
-		panic("Bad hd command, must be R/W");
-	lock_buffer(bh);
-repeat:
-	for (req=0+request ; req<NR_REQUEST+request ; req++)
-		if (req->hd<0)
-			break;
-	if (req==NR_REQUEST+request) {
-		sleep_on(&wait_for_request);
-		goto repeat;
-	}
-	req->hd=nr;
-	req->nsector=2;
-	req->sector=sec;
-	req->head=head;
-	req->cyl=cyl;
-	req->cmd = ((rw==READ)?WIN_READ:WIN_WRITE);
-	req->bh=bh;
-	req->errors=0;
-	req->next=NULL;
-	add_request(req);
-	wait_on_buffer(bh);
-}
-
-void hd_init(void)
-{
-	int i;
-
-	for (i=0 ; i<NR_REQUEST ; i++) {
-		request[i].hd = -1;
-		request[i].next = NULL;
-	}
-	for (i=0 ; i<NR_HD ; i++) {
-		hd[i*5].start_sect = 0;
-		hd[i*5].nr_sects = hd_info[i].head*
-				hd_info[i].sect*hd_info[i].cyl;
-	}
-	set_trap_gate(0x2E,&hd_interrupt);
-	outb_p(inb_p(0x21)&0xfb,0x21);
-	outb(inb_p(0xA1)&0xbf,0xA1);
-}
diff --git a/kernel/keyboard.s b/kernel/keyboard.s
deleted file mode 100644
index 8c776cc..0000000
--- a/kernel/keyboard.s
+++ /dev/null
@@ -1,409 +0,0 @@
-/*
- *      keyboard.s
- */
-
-.text
-.globl _keyboard_interrupt
-
-/*
- * these are for the keyboard read functions
- */
-size    = 1024          /* must be a power of two ! And MUST be the same
-                           as in tty_io.c !!!! */
-head = 4
-tail = 8
-proc_list = 12
-buf = 16
-
-mode:   .byte 0         /* caps, alt, ctrl and shift mode */
-leds:   .byte 2         /* num-lock, caps, scroll-lock mode (nom-lock on) */
-e0:     .byte 0
-
-/*
- *  con_int is the real interrupt routine that reads the
- *  keyboard scan-code and converts it into the appropriate
- *  ascii character(s).
- */
-_keyboard_interrupt:
-	pushl %eax
-	pushl %ebx
-	pushl %ecx
-	pushl %edx
-	push %ds
-	push %es
-	movl $0x10,%eax
-	mov %ax,%ds
-	mov %ax,%es
-	xorl %al,%al            /* %eax is scan code */
-	inb $0x60,%al
-	cmpb $0xe0,%al
-	je set_e0
-	cmpb $0xe1,%al
-	je set_e1
-	call key_table(,%eax,4)
-	movb $0,e0
-e0_e1:  inb $0x61,%al
-	jmp 1f
-1:      jmp 1f
-1:      orb $0x80,%al
-	jmp 1f
-1:      jmp 1f
-1:      outb %al,$0x61
-	jmp 1f
-1:      jmp 1f
-1:      andb $0x7F,%al
-	outb %al,$0x61
-	movb $0x20,%al
-	outb %al,$0x20
-	pushl $0
-	call _do_tty_interrupt
-	addl $4,%esp
-	pop %es
-	pop %ds
-	popl %edx
-	popl %ecx
-	popl %ebx
-	popl %eax
-	iret
-set_e0: movb $1,e0
-	jmp e0_e1
-set_e1: movb $2,e0
-	jmp e0_e1
-
-/*
- * This routine fills the buffer with max 8 bytes, taken from
- * %ebx:%eax. (%edx is high). The bytes are written in the
- * order %al,%ah,%eal,%eah,%bl,%bh ... until %eax is zero.
- */
-put_queue:
-	pushl %ecx
-	pushl %edx
-	movl _table_list,%edx           # read-queue for console
-	movl head(%edx),%ecx
-1:      movb %al,buf(%edx,%ecx)
-	incl %ecx
-	andl $size-1,%ecx
-	cmpl tail(%edx),%ecx            # buffer full - discard everything
-	je 3f
-	shrdl $8,%ebx,%eax
-	je 2f
-	shrl $8,%ebx
-	jmp 1b
-2:      movl %ecx,head(%edx)
-	movl proc_list(%edx),%ecx
-	testl %ecx,%ecx
-	je 3f
-	movl $0,(%ecx)
-3:      popl %edx
-	popl %ecx
-	ret
-
-ctrl:   movb $0x04,%al
-	jmp 1f
-alt:    movb $0x10,%al
-1:      cmpb $0,e0
-	je 2f
-	addb %al,%al
-2:      orb %al,mode
-	ret
-unctrl: movb $0x04,%al
-	jmp 1f
-unalt:  movb $0x10,%al
-1:      cmpb $0,e0
-	je 2f
-	addb %al,%al
-2:      notb %al
-	andb %al,mode
-	ret
-
-lshift:
-	orb $0x01,mode
-	ret
-unlshift:
-	andb $0xfe,mode
-	ret
-rshift:
-	orb $0x02,mode
-	ret
-unrshift:
-	andb $0xfd,mode
-	ret
-
-caps:   testb $0x80,mode
-	jne 1f
-	xorb $4,leds
-	xorb $0x40,mode
-	orb $0x80,mode
-set_leds:
-	call kb_wait
-	movb $0xed,%al          /* set leds command */
-	outb %al,$0x60
-	call kb_wait
-	movb leds,%al
-	outb %al,$0x60
-	ret
-uncaps: andb $0x7f,mode
-	ret
-scroll:
-	xorb $1,leds
-	jmp set_leds
-num:    xorb $2,leds
-	jmp set_leds
-
-/*
- *  curosr-key/numeric keypad cursor keys are handled here.
- *  checking for numeric keypad etc.
- */
-cursor:
-	subb $0x47,%al
-	jb 1f
-	cmpb $12,%al
-	ja 1f
-	jne cur2                /* check for ctrl-alt-del */
-	testb $0x0c,mode
-	je cur2
-	testb $0x30,mode
-	jne reboot
-cur2:   cmpb $0x01,e0           /* e0 forces cursor movement */
-	je cur
-	testb $0x02,leds        /* not num-lock forces cursor */
-	je cur
-	testb $0x03,mode        /* shift forces cursor */
-	jne cur
-	xorl %ebx,%ebx
-	movb num_table(%eax),%al
-	jmp put_queue
-1:      ret
-
-cur:    movb cur_table(%eax),%al
-	cmpb $'9,%al
-	ja ok_cur
-	movb $'~,%ah
-ok_cur: shll $16,%eax
-	movw $0x5b1b,%ax
-	xorl %ebx,%ebx
-	jmp put_queue
-
-num_table:
-	.ascii "789 456 1230,"
-cur_table:
-	.ascii "HA5 DGC YB623"
-
-/*
- * this routine handles function keys
- */
-func:
-	subb $0x3B,%al
-	jb end_func
-	cmpb $9,%al
-	jbe ok_func
-	subb $18,%al
-	cmpb $10,%al
-	jb end_func
-	cmpb $11,%al
-	ja end_func
-ok_func:
-	cmpl $4,%ecx            /* check that there is enough room */
-	jl end_func
-	movl func_table(,%eax,4),%eax
-	xorl %ebx,%ebx
-	jmp put_queue
-end_func:
-	ret
-
-/*
- * function keys send F1:'esc [ [ A' F2:'esc [ [ B' etc.
- */
-func_table:
-	.long 0x415b5b1b,0x425b5b1b,0x435b5b1b,0x445b5b1b
-	.long 0x455b5b1b,0x465b5b1b,0x475b5b1b,0x485b5b1b
-	.long 0x495b5b1b,0x4a5b5b1b,0x4b5b5b1b,0x4c5b5b1b
-
-key_map:
-	.byte 0,27
-	.ascii "1234567890+'"
-	.byte 127,9
-	.ascii "qwertyuiop}"
-	.byte 0,10,0
-	.ascii "asdfghjkl|{"
-	.byte 0,0
-	.ascii "'zxcvbnm,.-"
-	.byte 0,'*,0,32         /* 36-39 */
-	.fill 16,1,0            /* 3A-49 */
-	.byte '-,0,0,0,'+       /* 4A-4E */
-	.byte 0,0,0,0,0,0,0     /* 4F-55 */
-	.byte '<
-	.fill 10,1,0
-
-shift_map:
-	.byte 0,27
-	.ascii "!\"#$%&/()=?`"
-	.byte 127,9
-	.ascii "QWERTYUIOP]^"
-	.byte 10,0
-	.ascii "ASDFGHJKL\\["
-	.byte 0,0
-	.ascii "*ZXCVBNM;:_"
-	.byte 0,'*,0,32         /* 36-39 */
-	.fill 16,1,0            /* 3A-49 */
-	.byte '-,0,0,0,'+       /* 4A-4E */
-	.byte 0,0,0,0,0,0,0     /* 4F-55 */
-	.byte '>
-	.fill 10,1,0
-
-alt_map:
-	.byte 0,0
-	.ascii "\0@\0$\0\0{[]}\\\0"
-	.byte 0,0
-	.byte 0,0,0,0,0,0,0,0,0,0,0
-	.byte '~,10,0
-	.byte 0,0,0,0,0,0,0,0,0,0,0
-	.byte 0,0
-	.byte 0,0,0,0,0,0,0,0,0,0,0
-	.byte 0,0,0,0           /* 36-39 */
-	.fill 16,1,0            /* 3A-49 */
-	.byte 0,0,0,0,0         /* 4A-4E */
-	.byte 0,0,0,0,0,0,0     /* 4F-55 */
-	.byte '|
-	.fill 10,1,0
-
-/*
- * do_self handles "normal" keys, ie keys that don't change meaning
- * and which have just one character returns.
- */
-do_self:
-	lea alt_map,%ebx
-	testb $0x20,mode                /* alt-gr */
-	jne 1f
-	lea shift_map,%ebx
-	testb $0x03,mode
-	jne 1f
-	lea key_map,%ebx
-1:      movb (%ebx,%eax),%al
-	orb %al,%al
-	je none
-	testb $0x4c,mode                /* ctrl or caps */
-	je 2f
-	cmpb $'a,%al
-	jb 2f
-	cmpb $'z,%al
-	ja 2f
-	subb $32,%al
-2:      testb $0x0c,mode                /* ctrl */
-	je 3f
-	cmpb $64,%al
-	jb 3f
-	cmpb $64+32,%al
-	jae 3f
-	subb $64,%al
-3:      testb $0x10,mode                /* left alt */
-	je 4f
-	orb $0x80,%al
-4:      andl $0xff,%eax
-	xorl %ebx,%ebx
-	call put_queue
-none:   ret
-
-/*
- * minus has a routine of it's own, as a 'E0h' before
- * the scan code for minus means that the numeric keypad
- * slash was pushed.
- */
-minus:  cmpb $1,e0
-	jne do_self
-	movl $'/,%eax
-	xorl %ebx,%ebx
-	jmp put_queue
-
-/*
- * This table decides which routine to call when a scan-code has been
- * gotten. Most routines just call do_self, or none, depending if
- * they are make or break.
- */
-key_table:
-	.long none,do_self,do_self,do_self      /* 00-03 s0 esc 1 2 */
-	.long do_self,do_self,do_self,do_self   /* 04-07 3 4 5 6 */
-	.long do_self,do_self,do_self,do_self   /* 08-0B 7 8 9 0 */
-	.long do_self,do_self,do_self,do_self   /* 0C-0F + ' bs tab */
-	.long do_self,do_self,do_self,do_self   /* 10-13 q w e r */
-	.long do_self,do_self,do_self,do_self   /* 14-17 t y u i */
-	.long do_self,do_self,do_self,do_self   /* 18-1B o p } ^ */
-	.long do_self,ctrl,do_self,do_self      /* 1C-1F enter ctrl a s */
-	.long do_self,do_self,do_self,do_self   /* 20-23 d f g h */
-	.long do_self,do_self,do_self,do_self   /* 24-27 j k l | */
-	.long do_self,do_self,lshift,do_self    /* 28-2B { para lshift , */
-	.long do_self,do_self,do_self,do_self   /* 2C-2F z x c v */
-	.long do_self,do_self,do_self,do_self   /* 30-33 b n m , */
-	.long do_self,minus,rshift,do_self      /* 34-37 . - rshift * */
-	.long alt,do_self,caps,func             /* 38-3B alt sp caps f1 */
-	.long func,func,func,func               /* 3C-3F f2 f3 f4 f5 */
-	.long func,func,func,func               /* 40-43 f6 f7 f8 f9 */
-	.long func,num,scroll,cursor            /* 44-47 f10 num scr home */
-	.long cursor,cursor,do_self,cursor      /* 48-4B up pgup - left */
-	.long cursor,cursor,do_self,cursor      /* 4C-4F n5 right + end */
-	.long cursor,cursor,cursor,cursor       /* 50-53 dn pgdn ins del */
-	.long none,none,do_self,func            /* 54-57 sysreq ? < f11 */
-	.long func,none,none,none               /* 58-5B f12 ? ? ? */
-	.long none,none,none,none               /* 5C-5F ? ? ? ? */
-	.long none,none,none,none               /* 60-63 ? ? ? ? */
-	.long none,none,none,none               /* 64-67 ? ? ? ? */
-	.long none,none,none,none               /* 68-6B ? ? ? ? */
-	.long none,none,none,none               /* 6C-6F ? ? ? ? */
-	.long none,none,none,none               /* 70-73 ? ? ? ? */
-	.long none,none,none,none               /* 74-77 ? ? ? ? */
-	.long none,none,none,none               /* 78-7B ? ? ? ? */
-	.long none,none,none,none               /* 7C-7F ? ? ? ? */
-	.long none,none,none,none               /* 80-83 ? br br br */
-	.long none,none,none,none               /* 84-87 br br br br */
-	.long none,none,none,none               /* 88-8B br br br br */
-	.long none,none,none,none               /* 8C-8F br br br br */
-	.long none,none,none,none               /* 90-93 br br br br */
-	.long none,none,none,none               /* 94-97 br br br br */
-	.long none,none,none,none               /* 98-9B br br br br */
-	.long none,unctrl,none,none             /* 9C-9F br unctrl br br */
-	.long none,none,none,none               /* A0-A3 br br br br */
-	.long none,none,none,none               /* A4-A7 br br br br */
-	.long none,none,unlshift,none           /* A8-AB br br unlshift br */
-	.long none,none,none,none               /* AC-AF br br br br */
-	.long none,none,none,none               /* B0-B3 br br br br */
-	.long none,none,unrshift,none           /* B4-B7 br br unrshift br */
-	.long unalt,none,uncaps,none            /* B8-BB unalt br uncaps br */
-	.long none,none,none,none               /* BC-BF br br br br */
-	.long none,none,none,none               /* C0-C3 br br br br */
-	.long none,none,none,none               /* C4-C7 br br br br */
-	.long none,none,none,none               /* C8-CB br br br br */
-	.long none,none,none,none               /* CC-CF br br br br */
-	.long none,none,none,none               /* D0-D3 br br br br */
-	.long none,none,none,none               /* D4-D7 br br br br */
-	.long none,none,none,none               /* D8-DB br ? ? ? */
-	.long none,none,none,none               /* DC-DF ? ? ? ? */
-	.long none,none,none,none               /* E0-E3 e0 e1 ? ? */
-	.long none,none,none,none               /* E4-E7 ? ? ? ? */
-	.long none,none,none,none               /* E8-EB ? ? ? ? */
-	.long none,none,none,none               /* EC-EF ? ? ? ? */
-	.long none,none,none,none               /* F0-F3 ? ? ? ? */
-	.long none,none,none,none               /* F4-F7 ? ? ? ? */
-	.long none,none,none,none               /* F8-FB ? ? ? ? */
-	.long none,none,none,none               /* FC-FF ? ? ? ? */
-
-/*
- * kb_wait waits for the keyboard controller buffer to empty.
- * there is no timeout - if the buffer doesn't empty, we hang.
- */
-kb_wait:
-	pushl %eax
-1:      inb $0x64,%al
-	testb $0x02,%al
-	jne 1b
-	popl %eax
-	ret
-/*
-* This routine reboots the machine by asking the keyboard
-* controller to pulse the reset-line low.
-*/
-reboot:
-	call kb_wait
-	movw $0x1234,0x472      /* don't do memory check */
-	movb $0xfc,%al          /* pulse reset and A20 low */
-	outb %al,$0x64
-die:    jmp die
diff --git a/kernel/math/Makefile b/kernel/math/Makefile
new file mode 100644
index 0000000..7e0b4c4
--- /dev/null
+++ b/kernel/math/Makefile
@@ -0,0 +1,43 @@
+#
+# Makefile for the FREAX-kernel character device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+AR	=gar
+AS	=gas
+LD	=gld
+LDFLAGS	=-s -x
+CC	=gcc
+CFLAGS	=-Wall -O -fstrength-reduce -fomit-frame-pointer -fcombine-regs \
+	-finline-functions -mstring-insns -nostdinc -I../../include
+CPP	=gcc -E -nostdinc -I../../include
+
+.c.s:
+	$(CC) $(CFLAGS) \
+	-S -o $*.s $<
+.s.o:
+	$(AS) -c -o $*.o $<
+.c.o:
+	$(CC) $(CFLAGS) \
+	-c -o $*.o $<
+
+OBJS  = math_emulate.o
+
+math.a: $(OBJS)
+	$(AR) rcs math.a $(OBJS)
+	sync
+
+clean:
+	rm -f core *.o *.a tmp_make
+	for i in *.c;do rm -f `basename $$i .c`.s;done
+
+dep:
+	sed '/\#\#\# Dependencies/q' < Makefile > tmp_make
+	(for i in *.c;do echo -n `echo $$i | sed 's,\.c,\.s,'`" "; \
+		$(CPP) -M $$i;done) >> tmp_make
+	cp tmp_make Makefile
+
+### Dependencies:
diff --git a/kernel/math/math_emulate.c b/kernel/math/math_emulate.c
new file mode 100644
index 0000000..825e528
--- /dev/null
+++ b/kernel/math/math_emulate.c
@@ -0,0 +1,42 @@
+/*
+ * linux/kernel/math/math_emulate.c
+ *
+ * (C) 1991 Linus Torvalds
+ */
+
+/*
+ * This directory should contain the math-emulation code.
+ * Currently only results in a signal.
+ */
+
+#include <signal.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <asm/segment.h>
+
+void math_emulate(long edi, long esi, long ebp, long sys_call_ret,
+	long eax,long ebx,long ecx,long edx,
+	unsigned short fs,unsigned short es,unsigned short ds,
+	unsigned long eip,unsigned short cs,unsigned long eflags,
+	unsigned short ss, unsigned long esp)
+{
+	unsigned char first, second;
+
+/* 0x0007 means user code space */
+	if (cs != 0x000F) {
+		printk("math_emulate: %04x:%08x\n\r",cs,eip);
+		panic("Math emulation needed in kernel");
+	}
+	first = get_fs_byte((char *)((*&eip)++));
+	second = get_fs_byte((char *)((*&eip)++));
+	printk("%04x:%08x %02x %02x\n\r",cs,eip-2,first,second);
+	current->signal |= 1<<(SIGFPE-1);
+}
+
+void math_error(void)
+{
+	__asm__("fnclex");
+	if (last_task_used_math)
+		last_task_used_math->signal |= 1<<(SIGFPE-1);
+}
diff --git a/kernel/mktime.c b/kernel/mktime.c
index 3ba79be..a67db96 100644
--- a/kernel/mktime.c
+++ b/kernel/mktime.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/kernel/mktime.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <time.h>
 
 /*
diff --git a/kernel/panic.c b/kernel/panic.c
index feab0cc..7d8a06b 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -1,11 +1,24 @@
 /*
+ *  linux/kernel/panic.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  * This function is used through-out the kernel (includeinh mm and fs)
  * to indicate a major problem.
  */
 #include <linux/kernel.h>
+#include <linux/sched.h>
+
+void sys_sync(void);	/* it's really int */
 
 volatile void panic(const char * s)
 {
 	printk("Kernel panic: %s\n\r",s);
+	if (current == task[0])
+		printk("In swapper task - not syncing\n\r");
+	else
+		sys_sync();
 	for(;;);
 }
diff --git a/kernel/printk.c b/kernel/printk.c
index 7a70dc3..c464d43 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -1,4 +1,10 @@
 /*
+ *  linux/kernel/printk.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  * When in kernel-mode, we cannot use printf, as fs is liable to
  * point to 'interesting' things. Make a printf with fs-saving, and
  * all is well.
@@ -10,6 +16,8 @@
 
 static char buf[1024];
 
+extern int vsprintf(char * buf, const char * fmt, va_list args);
+
 int printk(const char *fmt, ...)
 {
 	va_list args;
diff --git a/kernel/rs_io.s b/kernel/rs_io.s
deleted file mode 100644
index c34a015..0000000
--- a/kernel/rs_io.s
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- *      rs_io.s
- *
- * This module implements the rs232 io interrupts.
- */
-
-.text
-.globl _rs1_interrupt,_rs2_interrupt
-
-size    = 1024                          /* must be power of two !
-                                           and must match the value
-                                           in tty_io.c!!! */
-
-/* these are the offsets into the read/write buffer structures */
-rs_addr = 0
-head = 4
-tail = 8
-proc_list = 12
-buf = 16
-
-startup = 256           /* chars left in write queue when we restart it */
-
-/*
- * These are the actual interrupt routines. They look where
- * the interrupt is coming from, and take appropriate action.
- */
-.align 2
-_rs1_interrupt:
-	pushl $_table_list+8
-	jmp rs_int
-.align 2
-_rs2_interrupt:
-	pushl $_table_list+16
-rs_int:
-	pushl %edx
-	pushl %ecx
-	pushl %ebx
-	pushl %eax
-	push %es
-	push %ds                /* as this is an interrupt, we cannot */
-	pushl $0x10             /* know that bs is ok. Load it */
-	pop %ds
-	pushl $0x10
-	pop %es
-	movl 24(%esp),%edx
-	movl (%edx),%edx
-	movl rs_addr(%edx),%edx
-	addl $2,%edx            /* interrupt ident. reg */
-rep_int:
-	xorl %eax,%eax
-	inb %dx,%al
-	testb $1,%al
-	jne end
-	cmpb $6,%al             /* this shouldn't happen, but ... */
-	ja end
-	movl 24(%esp),%ecx
-	pushl %edx
-	subl $2,%edx
-	call jmp_table(,%eax,2)         /* NOTE! not *4, bit0 is 0 already */
-	popl %edx
-	jmp rep_int
-end:    movb $0x20,%al
-	outb %al,$0x20          /* EOI */
-	pop %ds
-	pop %es
-	popl %eax
-	popl %ebx
-	popl %ecx
-	popl %edx
-	addl $4,%esp            # jump over _table_list entry
-	iret
-
-jmp_table:
-	.long modem_status,write_char,read_char,line_status
-
-.align 2
-modem_status:
-	addl $6,%edx            /* clear intr by reading modem status reg */
-	inb %dx,%al
-	ret
-
-.align 2
-line_status:
-	addl $5,%edx            /* clear intr by reading line status reg. */
-	inb %dx,%al
-	ret
-
-.align 2
-read_char:
-	inb %dx,%al
-	movl %ecx,%edx
-	subl $_table_list,%edx
-	shrl $3,%edx
-	movl (%ecx),%ecx                # read-queue
-	movl head(%ecx),%ebx
-	movb %al,buf(%ecx,%ebx)
-	incl %ebx
-	andl $size-1,%ebx
-	cmpl tail(%ecx),%ebx
-	je 1f
-	movl %ebx,head(%ecx)
-	pushl %edx
-	call _do_tty_interrupt
-	addl $4,%esp
-1:      ret
-
-.align 2
-write_char:
-	movl 4(%ecx),%ecx               # write-queue
-	movl head(%ecx),%ebx
-	subl tail(%ecx),%ebx
-	andl $size-1,%ebx               # nr chars in queue
-	je write_buffer_empty
-	cmpl $startup,%ebx
-	ja 1f
-	movl proc_list(%ecx),%ebx       # wake up sleeping process
-	testl %ebx,%ebx                 # is there any?
-	je 1f
-	movl $0,(%ebx)
-1:      movl tail(%ecx),%ebx
-	movb buf(%ecx,%ebx),%al
-	outb %al,%dx
-	incl %ebx
-	andl $size-1,%ebx
-	movl %ebx,tail(%ecx)
-	cmpl head(%ecx),%ebx
-	je write_buffer_empty
-	ret
-.align 2
-write_buffer_empty:
-	movl proc_list(%ecx),%ebx       # wake up sleeping process
-	testl %ebx,%ebx                 # is there any?
-	je 1f
-	movl $0,(%ebx)
-1:      incl %edx
-	inb %dx,%al
-	jmp 1f
-1:      jmp 1f
-1:      andb $0xd,%al           /* disable transmit interrupt */
-	outb %al,%dx
-	ret
diff --git a/kernel/sched.c b/kernel/sched.c
index 03399fa..a9ee7ff 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -1,4 +1,10 @@
 /*
+ *  linux/kernel/sched.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  * 'sched.c' is the main kernel file. It contains scheduling primitives
  * (sleep_on, wakeup, schedule etc) as well as a number of simple system
  * call functions (type getpid(), which just extracts a field from
@@ -6,12 +12,37 @@
  */
 #include <linux/sched.h>
 #include <linux/kernel.h>
-#include <signal.h>
 #include <linux/sys.h>
+#include <linux/fdreg.h>
 #include <asm/system.h>
 #include <asm/io.h>
 #include <asm/segment.h>
 
+#include <signal.h>
+
+#define _S(nr) (1<<((nr)-1))
+#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))
+
+void show_task(int nr,struct task_struct * p)
+{
+	int i,j = 4096-sizeof(struct task_struct);
+
+	printk("%d: pid=%d, state=%d, ",nr,p->pid,p->state);
+	i=0;
+	while (i<j && !((char *)(p+1))[i])
+		i++;
+	printk("%d (of %d) chars free in kernel stack\n\r",i,j);
+}
+
+void show_stat(void)
+{
+	int i;
+
+	for (i=0;i<NR_TASKS;i++)
+		if (task[i])
+			show_task(i,task[i]);
+}
+
 #define LATCH (1193180/HZ)
 
 extern void mem_use(void);
@@ -28,7 +59,8 @@ static union task_union init_task = {INIT_TASK,};
 
 long volatile jiffies=0;
 long startup_time=0;
-struct task_struct *current = &(init_task.task), *last_task_used_math = NULL;
+struct task_struct *current = &(init_task.task);
+struct task_struct *last_task_used_math = NULL;
 
 struct task_struct * task[NR_TASKS] = {&(init_task.task), };
 
@@ -44,15 +76,19 @@ struct {
  */
 void math_state_restore()
 {
-	if (last_task_used_math)
+	if (last_task_used_math == current)
+		return;
+	__asm__("fwait");
+	if (last_task_used_math) {
 		__asm__("fnsave %0"::"m" (last_task_used_math->tss.i387));
-	if (current->used_math)
+	}
+	last_task_used_math=current;
+	if (current->used_math) {
 		__asm__("frstor %0"::"m" (current->tss.i387));
-	else {
+	} else {
 		__asm__("fninit"::);
 		current->used_math=1;
 	}
-	last_task_used_math=current;
 }
 
 /*
@@ -78,7 +114,8 @@ void schedule(void)
 					(*p)->signal |= (1<<(SIGALRM-1));
 					(*p)->alarm = 0;
 				}
-			if ((*p)->signal && (*p)->state==TASK_INTERRUPTIBLE)
+			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
+			(*p)->state==TASK_INTERRUPTIBLE)
 				(*p)->state=TASK_RUNNING;
 		}
 
@@ -156,12 +193,142 @@ void wake_up(struct task_struct **p)
 	}
 }
 
+/*
+ * OK, here are some floppy things that shouldn't be in the kernel
+ * proper. They are here because the floppy needs a timer, and this
+ * was the easiest way of doing it.
+ */
+static struct task_struct * wait_motor[4] = {NULL,NULL,NULL,NULL};
+static int  mon_timer[4]={0,0,0,0};
+static int moff_timer[4]={0,0,0,0};
+unsigned char current_DOR = 0x0C;
+
+int ticks_to_floppy_on(unsigned int nr)
+{
+	extern unsigned char selected;
+	unsigned char mask = 0x10 << nr;
+
+	if (nr>3)
+		panic("floppy_on: nr>3");
+	moff_timer[nr]=10000;		/* 100 s = very big :-) */
+	cli();				/* use floppy_off to turn it off */
+	mask |= current_DOR;
+	if (!selected) {
+		mask &= 0xFC;
+		mask |= nr;
+	}
+	if (mask != current_DOR) {
+		outb(mask,FD_DOR);
+		if ((mask ^ current_DOR) & 0xf0)
+			mon_timer[nr] = HZ/2;
+		else if (mon_timer[nr] < 2)
+			mon_timer[nr] = 2;
+		current_DOR = mask;
+	}
+	sti();
+	return mon_timer[nr];
+}
+
+void floppy_on(unsigned int nr)
+{
+	cli();
+	while (ticks_to_floppy_on(nr))
+		sleep_on(nr+wait_motor);
+	sti();
+}
+
+void floppy_off(unsigned int nr)
+{
+	moff_timer[nr]=3*HZ;
+}
+
+void do_floppy_timer(void)
+{
+	int i;
+	unsigned char mask = 0x10;
+
+	for (i=0 ; i<4 ; i++,mask <<= 1) {
+		if (!(mask & current_DOR))
+			continue;
+		if (mon_timer[i]) {
+			if (!--mon_timer[i])
+				wake_up(i+wait_motor);
+		} else if (!moff_timer[i]) {
+			current_DOR &= ~mask;
+			outb(current_DOR,FD_DOR);
+		} else
+			moff_timer[i]--;
+	}
+}
+
+#define TIME_REQUESTS 64
+
+static struct timer_list {
+	long jiffies;
+	void (*fn)();
+	struct timer_list * next;
+} timer_list[TIME_REQUESTS], * next_timer = NULL;
+
+void add_timer(long jiffies, void (*fn)(void))
+{
+	struct timer_list * p;
+
+	if (!fn)
+		return;
+	cli();
+	if (jiffies <= 0)
+		(fn)();
+	else {
+		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
+			if (!p->fn)
+				break;
+		if (p >= timer_list + TIME_REQUESTS)
+			panic("No more time requests free");
+		p->fn = fn;
+		p->jiffies = jiffies;
+		p->next = next_timer;
+		next_timer = p;
+		while (p->next && p->next->jiffies < p->jiffies) {
+			p->jiffies -= p->next->jiffies;
+			fn = p->fn;
+			p->fn = p->next->fn;
+			p->next->fn = fn;
+			jiffies = p->jiffies;
+			p->jiffies = p->next->jiffies;
+			p->next->jiffies = jiffies;
+			p = p->next;
+		}
+	}
+	sti();
+}
+
 void do_timer(long cpl)
 {
+	extern int beepcount;
+	extern void sysbeepstop(void);
+
+	if (beepcount)
+		if (!--beepcount)
+			sysbeepstop();
+
 	if (cpl)
 		current->utime++;
 	else
 		current->stime++;
+
+	if (next_timer) {
+		next_timer->jiffies--;
+		while (next_timer && next_timer->jiffies <= 0) {
+			void (*fn)(void);
+
+			fn = next_timer->fn;
+			next_timer->fn = NULL;
+			next_timer = next_timer->next;
+			(fn)();
+		}
+	}
+	if (current_DOR & 0xf0)
+		do_floppy_timer();
 	if ((--current->counter)>0) return;
 	current->counter=0;
 	if (!cpl) return;
@@ -170,8 +337,12 @@ void do_timer(long cpl)
 
 int sys_alarm(long seconds)
 {
+	int old = current->alarm;
+
+	if (old)
+		old = (old - jiffies) / HZ;
 	current->alarm = (seconds>0)?(jiffies+HZ*seconds):0;
-	return seconds;
+	return (old);
 }
 
 int sys_getpid(void)
@@ -211,28 +382,13 @@ int sys_nice(long increment)
 	return 0;
 }
 
-int sys_signal(long signal,long addr,long restorer)
-{
-	long i;
-
-	switch (signal) {
-		case SIGHUP: case SIGINT: case SIGQUIT: case SIGILL:
-		case SIGTRAP: case SIGABRT: case SIGFPE: case SIGUSR1:
-		case SIGSEGV: case SIGUSR2: case SIGPIPE: case SIGALRM:
-		case SIGCHLD:
-			i=(long) current->sig_fn[signal-1];
-			current->sig_fn[signal-1] = (fn_ptr) addr;
-			current->sig_restorer = (fn_ptr) restorer;
-			return i;
-		default: return -1;
-	}
-}
-
 void sched_init(void)
 {
 	int i;
 	struct desc_struct * p;
 
+	if (sizeof(struct sigaction) != 16)
+		panic("Struct sigaction MUST be 16 bytes");
 	set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
 	set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
 	p = gdt+2+FIRST_TSS_ENTRY;
@@ -243,6 +399,8 @@ void sched_init(void)
 		p->a=p->b=0;
 		p++;
 	}
+/* Clear NT, so that we won't have troubles with that later on */
+	__asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
 	ltr(0);
 	lldt(0);
 	outb_p(0x36,0x43);		/* binary, mode 3, LSB/MSB, ch 0 */
diff --git a/kernel/signal.c b/kernel/signal.c
new file mode 100644
index 0000000..055fc20
--- /dev/null
+++ b/kernel/signal.c
@@ -0,0 +1,119 @@
+/*
+ *  linux/kernel/signal.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <asm/segment.h>
+
+#include <signal.h>
+
+volatile void do_exit(int error_code);
+
+int sys_sgetmask()
+{
+	return current->blocked;
+}
+
+int sys_ssetmask(int newmask)
+{
+	int old=current->blocked;
+
+	current->blocked = newmask & ~(1<<(SIGKILL-1));
+	return old;
+}
+
+static inline void save_old(char * from,char * to)
+{
+	int i;
+
+	verify_area(to, sizeof(struct sigaction));
+	for (i=0 ; i< sizeof(struct sigaction) ; i++) {
+		put_fs_byte(*from,to);
+		from++;
+		to++;
+	}
+}
+
+static inline void get_new(char * from,char * to)
+{
+	int i;
+
+	for (i=0 ; i< sizeof(struct sigaction) ; i++)
+		*(to++) = get_fs_byte(from++);
+}
+
+int sys_signal(int signum, long handler, long restorer)
+{
+	struct sigaction tmp;
+
+	if (signum<1 || signum>32 || signum==SIGKILL)
+		return -1;
+	tmp.sa_handler = (void (*)(int)) handler;
+	tmp.sa_mask = 0;
+	tmp.sa_flags = SA_ONESHOT | SA_NOMASK;
+	tmp.sa_restorer = (void (*)(void)) restorer;
+	handler = (long) current->sigaction[signum-1].sa_handler;
+	current->sigaction[signum-1] = tmp;
+	return handler;
+}
+
+int sys_sigaction(int signum, const struct sigaction * action,
+	struct sigaction * oldaction)
+{
+	struct sigaction tmp;
+
+	if (signum<1 || signum>32 || signum==SIGKILL)
+		return -1;
+	tmp = current->sigaction[signum-1];
+	get_new((char *) action,
+		(char *) (signum-1+current->sigaction));
+	if (oldaction)
+		save_old((char *) &tmp,(char *) oldaction);
+	if (current->sigaction[signum-1].sa_flags & SA_NOMASK)
+		current->sigaction[signum-1].sa_mask = 0;
+	else
+		current->sigaction[signum-1].sa_mask |= (1<<(signum-1));
+	return 0;
+}
+
+void do_signal(long signr,long eax, long ebx, long ecx, long edx,
+	long fs, long es, long ds,
+	long eip, long cs, long eflags,
+	unsigned long * esp, long ss)
+{
+	unsigned long sa_handler;
+	long old_eip=eip;
+	struct sigaction * sa = current->sigaction + signr - 1;
+	int longs;
+	unsigned long * tmp_esp;
+
+	sa_handler = (unsigned long) sa->sa_handler;
+	if (sa_handler==1)
+		return;
+	if (!sa_handler) {
+		if (signr==SIGCHLD)
+			return;
+		else
+			do_exit(1<<(signr-1));
+	}
+	if (sa->sa_flags & SA_ONESHOT)
+		sa->sa_handler = NULL;
+	*(&eip) = sa_handler;
+	longs = (sa->sa_flags & SA_NOMASK)?7:8;
+	*(&esp) -= longs;
+	verify_area(esp,longs*4);
+	tmp_esp=esp;
+	put_fs_long((long) sa->sa_restorer,tmp_esp++);
+	put_fs_long(signr,tmp_esp++);
+	if (!(sa->sa_flags & SA_NOMASK))
+		put_fs_long(current->blocked,tmp_esp++);
+	put_fs_long(eax,tmp_esp++);
+	put_fs_long(ecx,tmp_esp++);
+	put_fs_long(edx,tmp_esp++);
+	put_fs_long(eflags,tmp_esp++);
+	put_fs_long(old_eip,tmp_esp++);
+	current->blocked |= sa->sa_mask;
+}
diff --git a/kernel/sys.c b/kernel/sys.c
index f18ee7e..d3f977a 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/kernel/sys.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <errno.h>
 
 #include <linux/sched.h>
@@ -12,31 +18,11 @@ int sys_ftime()
 	return -ENOSYS;
 }
 
-int sys_mknod()
-{
-	return -ENOSYS;
-}
-
 int sys_break()
 {
 	return -ENOSYS;
 }
 
-int sys_mount()
-{
-	return -ENOSYS;
-}
-
-int sys_umount()
-{
-	return -ENOSYS;
-}
-
-int sys_ustat(int dev,struct ustat * ubuf)
-{
-	return -1;
-}
-
 int sys_ptrace()
 {
 	return -ENOSYS;
@@ -62,18 +48,32 @@ int sys_prof()
 	return -ENOSYS;
 }
 
-int sys_setgid(int gid)
+int sys_setregid(int rgid, int egid)
 {
-	if (current->euid && current->uid)
-		if (current->gid==gid || current->sgid==gid)
-			current->egid=gid;
+	if (rgid>0) {
+		if ((current->gid == rgid) ||
+		    suser())
+			current->gid = rgid;
+		else
+			return(-EPERM);
+	}
+	if (egid>0) {
+		if ((current->gid == egid) ||
+		    (current->egid == egid) ||
+		    (current->sgid == egid) ||
+		    suser())
+			current->egid = egid;
 		else
-			return -EPERM;
-	else
-		current->gid=current->egid=gid;
+			return(-EPERM);
+	}
 	return 0;
 }
 
+int sys_setgid(int gid)
+{
+	return(sys_setregid(gid, gid));
+}
+
 int sys_acct()
 {
 	return -ENOSYS;
@@ -111,35 +111,57 @@ int sys_time(long * tloc)
 	return i;
 }
 
-int sys_setuid(int uid)
+/*
+ * Unprivileged users may change the real user id to the effective uid
+ * or vice versa.
+ */
+int sys_setreuid(int ruid, int euid)
 {
-	if (current->euid && current->uid)
-		if (uid==current->uid || current->suid==current->uid)
-			current->euid=uid;
+	int old_ruid = current->uid;
+
+	if (ruid>0) {
+		if ((current->euid==ruid) ||
+		    (old_ruid == ruid) ||
+		    suser())
+			current->uid = ruid;
 		else
-			return -EPERM;
-	else
-		current->euid=current->uid=uid;
+			return(-EPERM);
+	}
+	if (euid>0) {
+		if ((old_ruid == euid) ||
+		    (current->euid == euid) ||
+		    suser())
+			current->euid = euid;
+		else {
+			current->uid = old_ruid;
+			return(-EPERM);
+		}
+	}
 	return 0;
 }
 
+int sys_setuid(int uid)
+{
+	return(sys_setreuid(uid, uid));
+}
+
 int sys_stime(long * tptr)
 {
-	if (current->euid && current->uid)
-		return -1;
+	if (!suser())
+		return -EPERM;
 	startup_time = get_fs_long((unsigned long *)tptr) - jiffies/HZ;
 	return 0;
 }
 
 int sys_times(struct tms * tbuf)
 {
-	if (!tbuf)
-		return jiffies;
-	verify_area(tbuf,sizeof *tbuf);
-	put_fs_long(current->utime,(unsigned long *)&tbuf->tms_utime);
-	put_fs_long(current->stime,(unsigned long *)&tbuf->tms_stime);
-	put_fs_long(current->cutime,(unsigned long *)&tbuf->tms_cutime);
-	put_fs_long(current->cstime,(unsigned long *)&tbuf->tms_cstime);
+	if (tbuf) {
+		verify_area(tbuf,sizeof *tbuf);
+		put_fs_long(current->utime,(unsigned long *)&tbuf->tms_utime);
+		put_fs_long(current->stime,(unsigned long *)&tbuf->tms_stime);
+		put_fs_long(current->cutime,(unsigned long *)&tbuf->tms_cutime);
+		put_fs_long(current->cstime,(unsigned long *)&tbuf->tms_cstime);
+	}
 	return jiffies;
 }
 
@@ -163,7 +185,7 @@ int sys_setpgid(int pid, int pgid)
 	if (!pid)
 		pid = current->pid;
 	if (!pgid)
-		pgid = pid;
+		pgid = current->pid;
 	for (i=0 ; i<NR_TASKS ; i++)
 		if (task[i] && task[i]->pid==pid) {
 			if (task[i]->leader)
@@ -183,9 +205,7 @@ int sys_getpgrp(void)
 
 int sys_setsid(void)
 {
-	if (current->uid && current->euid)
-		return -EPERM;
-	if (current->leader)
+	if (current->leader && !suser())
 		return -EPERM;
 	current->leader = 1;
 	current->session = current->pgrp = current->pid;
@@ -200,11 +220,11 @@ int sys_uname(struct utsname * name)
 	};
 	int i;
 
-	if (!name) return -1;
+	if (!name) return -ERROR;
 	verify_area(name,sizeof *name);
 	for(i=0;i<sizeof *name;i++)
 		put_fs_byte(((char *) &thisname)[i],i+(char *) name);
-	return (0);
+	return 0;
 }
 
 int sys_umask(int mask)
diff --git a/kernel/system_call.s b/kernel/system_call.s
index 05cf55d..fb53ac8 100644
--- a/kernel/system_call.s
+++ b/kernel/system_call.s
@@ -1,7 +1,13 @@
 /*
+ *  linux/kernel/system_call.s
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  *  system_call.s  contains the system-call low-level handling routines.
  * This also contains the timer-interrupt handler, as some of the code is
- * the same. The hd-interrupt is also here.
+ * the same. The hd- and flopppy-interrupts are also here.
  *
  * NOTE: This code handles signal-recognition, which happens every time
  * after a timer-interrupt and after each system call. Ordinary interrupts
@@ -132,14 +138,50 @@ ret_from_sys_call:
 	pop	%ds
 	iret
 
-default_signal:
-	incl	%ecx
-	cmpl	$SIG_CHLD,%ecx
-	je	2b
+.align 2
+_coprocessor_error:
+	push	%ds
+	push	%es
+	push	%fs
+	pushl	%edx
 	pushl	%ecx
-	call	_do_exit	# remember to set bit 7 when dumping core
-	addl	$4,%esp
-	jmp	3b
+	pushl	%ebx
+	pushl	%eax
+	movl	$0x10,%eax
+	mov	%ax,%ds
+	mov	%ax,%es
+	movl	$0x17,%eax
+	mov	%ax,%fs
+	pushl	$ret_from_sys_call
+	jmp	_math_error
+
+.align 2
+_device_not_available:
+	push	%ds
+	push	%es
+	push	%fs
+	pushl	%edx
+	pushl	%ecx
+	pushl	%ebx
+	pushl	%eax
+	movl	$0x10,%eax
+	mov	%ax,%ds
+	mov	%ax,%es
+	movl	$0x17,%eax
+	mov	%ax,%fs
+	pushl	$ret_from_sys_call
+	clts				# clear TS so that we can use math
+	movl	%cr0,%eax
+	testl	$0x4,%eax		# EM (math emulation bit)
+	je	_math_state_restore
+	pushl	%ebp
+	pushl	%esi
+	pushl	%edi
+	call	_math_emulate
+	popl	%edi
+	popl	%esi
+	popl	%ebp
+	ret
 
 .align 2
 _timer_interrupt:
@@ -200,14 +242,43 @@ _hd_interrupt:
 	movl	$0x17,%eax
 	mov	%ax,%fs
 	movb	$0x20,%al
-	outb	%al,$0x20		# EOI to interrupt controller #1
+	outb	%al,$0xA0		# EOI to interrupt controller #1
 	jmp	1f			# give port chance to breathe
 1:	jmp	1f
-1:	outb	%al,$0xA0		# same to controller #2
-	movl	_do_hd,%eax
+1:	xorl	%edx,%edx
+	xchgl	_do_hd,%edx
+	testl	%edx,%edx
+	jne	1f
+	movl	$_unexpected_hd_interrupt,%edx
+1:	outb	%al,$0x20
+	call	*%edx			# "interesting" way of handling intr.
+	pop	%fs
+	pop	%es
+	pop	%ds
+	popl	%edx
+	popl	%ecx
+	popl	%eax
+	iret
+
+_floppy_interrupt:
+	pushl	%eax
+	pushl	%ecx
+	pushl	%edx
+	push	%ds
+	push	%es
+	push	%fs
+	movl	$0x10,%eax
+	mov	%ax,%ds
+	mov	%ax,%es
+	movl	$0x17,%eax
+	mov	%ax,%fs
+	movb	$0x20,%al
+	outb	%al,$0x20		# EOI to interrupt controller #1
+	xorl	%eax,%eax
+	xchgl	_do_floppy,%eax
 	testl	%eax,%eax
 	jne	1f
-	movl	$_unexpected_hd_interrupt,%eax
+	movl	$_unexpected_floppy_interrupt,%eax
 1:	call	*%eax			# "interesting" way of handling intr.
 	pop	%fs
 	pop	%es
@@ -216,3 +287,10 @@ _hd_interrupt:
 	popl	%ecx
 	popl	%eax
 	iret
+
+_parallel_interrupt:
+	pushl	%eax
+	movb	$0x20,%al
+	outb	%al,$0x20
+	popl	%eax
+	iret
diff --git a/kernel/traps.c b/kernel/traps.c
index 4da3e27..f9bd8f1 100644
--- a/kernel/traps.c
+++ b/kernel/traps.c
@@ -1,4 +1,10 @@
 /*
+ *  linux/kernel/traps.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  * 'Traps.c' handles hardware traps and faults after we have saved some
  * state in 'asm.s'. Currently mostly a debugging-aid, will be extended
  * to mainly kill the offending process (probably by giving it a signal,
@@ -11,17 +17,18 @@
 #include <linux/kernel.h>
 #include <asm/system.h>
 #include <asm/segment.h>
+#include <asm/io.h>
 
 #define get_seg_byte(seg,addr) ({ \
 register char __res; \
 __asm__("push %%fs;mov %%ax,%%fs;movb %%fs:%2,%%al;pop %%fs" \
-	:"=a" (__res):"" (seg),"m" (*(addr))); \
+	:"=a" (__res):"0" (seg),"m" (*(addr))); \
 __res;})
 
 #define get_seg_long(seg,addr) ({ \
 register unsigned long __res; \
 __asm__("push %%fs;mov %%ax,%%fs;movl %%fs:%2,%%eax;pop %%fs" \
-	:"=a" (__res):"" (seg),"m" (*(addr))); \
+	:"=a" (__res):"0" (seg),"m" (*(addr))); \
 __res;})
 
 #define _fs() ({ \
@@ -50,6 +57,8 @@ void general_protection(void);
 void page_fault(void);
 void coprocessor_error(void);
 void reserved(void);
+void parallel_interrupt(void);
+void irq13(void);
 
 static void die(char * str,long esp_ptr,long nr)
 {
@@ -97,7 +106,7 @@ void do_int3(long * esp, long error_code,
 {
 	int tr;
 
-	__asm__("str %%ax":"=a" (tr):"" (0));
+	__asm__("str %%ax":"=a" (tr):"0" (0));
 	printk("eax\t\tebx\t\tecx\t\tedx\n\r%8x\t%8x\t%8x\t%8x\n\r",
 		eax,ebx,ecx,edx);
 	printk("esi\t\tedi\t\tebp\t\tesp\n\r%8x\t%8x\t%8x\t%8x\n\r",
@@ -159,12 +168,14 @@ void do_stack_segment(long esp,long error_code)
 
 void do_coprocessor_error(long esp, long error_code)
 {
+	if (last_task_used_math != current)
+		return;
 	die("coprocessor error",esp,error_code);
 }
 
 void do_reserved(long esp, long error_code)
 {
-	die("reserved (15,17-31) error",esp,error_code);
+	die("reserved (15,17-47) error",esp,error_code);
 }
 
 void trap_init(void)
@@ -188,11 +199,10 @@ void trap_init(void)
 	set_trap_gate(14,&page_fault);
 	set_trap_gate(15,&reserved);
 	set_trap_gate(16,&coprocessor_error);
-	for (i=17;i<32;i++)
+	for (i=17;i<48;i++)
 		set_trap_gate(i,&reserved);
-	/*      __asm__("movl $0x3ff000,%%eax\n\t"
-		"movl %%eax,%%db0\n\t"
-		"movl $0x000d0303,%%eax\n\t"
-		"movl %%eax,%%db7"
-		:::"ax");*/
+	set_trap_gate(45,&irq13);
+	outb_p(inb_p(0x21)&0xfb,0x21);
+	outb(inb_p(0xA1)&0xdf,0xA1);
+	set_trap_gate(39,&parallel_interrupt);
 }
diff --git a/kernel/vsprintf.c b/kernel/vsprintf.c
index 5d59746..4c82ac7 100644
--- a/kernel/vsprintf.c
+++ b/kernel/vsprintf.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/kernel/vsprintf.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 /* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
 /*
  * Wirzenius wrote this portably, Torvalds fucked it up :-)
@@ -7,14 +13,14 @@
 #include <string.h>
 
 /* we use this so that we can do without the ctype library */
-#define is_digit(c)     ((c) >= '' && (c) <= '9')
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
 
 static int skip_atoi(const char **s)
 {
 	int i=0;
 
 	while (is_digit(**s))
-		i = i*10 + *((*s)++) - '';
+		i = i*10 + *((*s)++) - '0';
 	return i;
 }
 
@@ -28,7 +34,7 @@ static int skip_atoi(const char **s)
 
 #define do_div(n,base) ({ \
 int __res; \
-__asm__("divl %4":"=a" (n),"=d" (__res):"" (n),"1" (0),"r" (base)); \
+__asm__("divl %4":"=a" (n),"=d" (__res):"0" (n),"1" (0),"r" (base)); \
 __res; })
 
 static char * number(char * str, int num, int base, int size, int precision
@@ -42,7 +48,7 @@ static char * number(char * str, int num, int base, int size, int precision
 	if (type&LEFT) type &= ~ZEROPAD;
 	if (base<2 || base>36)
 		return 0;
-	c = (type & ZEROPAD) ? '' : ' ' ;
+	c = (type & ZEROPAD) ? '0' : ' ' ;
 	if (type&SIGN && num<0) {
 		sign='-';
 		num = -num;
@@ -54,7 +60,7 @@ static char * number(char * str, int num, int base, int size, int precision
 		else if (base==8) size--;
 	i=0;
 	if (num==0)
-		tmp[i++]='';
+		tmp[i++]='0';
 	else while (num!=0)
 		tmp[i++]=digits[do_div(num,base)];
 	if (i>precision) precision=i;
@@ -66,16 +72,16 @@ static char * number(char * str, int num, int base, int size, int precision
 		*str++ = sign;
 	if (type&SPECIAL)
 		if (base==8)
-			*str++ = '';
+			*str++ = '0';
 		else if (base==16) {
-			*str++ = '';
+			*str++ = '0';
 			*str++ = digits[33];
 		}
 	if (!(type&LEFT))
 		while(size-->0)
 			*str++ = c;
 	while(i<precision--)
-		*str++ = '';
+		*str++ = '0';
 	while(i-->0)
 		*str++ = tmp[i];
 	while(size-->0)
@@ -113,7 +119,7 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 				case '+': flags |= PLUS; goto repeat;
 				case ' ': flags |= SPACE; goto repeat;
 				case '#': flags |= SPECIAL; goto repeat;
-				case '': flags |= ZEROPAD; goto repeat;
+				case '0': flags |= ZEROPAD; goto repeat;
 				}
 
 		/* get field width */
diff --git a/lib/Makefile b/lib/Makefile
index a06698d..26a1e04 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -25,7 +25,7 @@ CPP	=gcc -E -nostdinc -I../include
 	-c -o $*.o $<
 
 OBJS  = ctype.o _exit.o open.o close.o errno.o write.o dup.o setsid.o \
-	execve.o wait.o string.o
+	execve.o wait.o string.o malloc.o
 
 lib.a: $(OBJS)
 	$(AR) rcs lib.a $(OBJS)
@@ -42,3 +42,32 @@ dep:
 	cp tmp_make Makefile
 
 ### Dependencies:
+_exit.s _exit.o : _exit.c ../include/unistd.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
+  ../include/utime.h
+close.s close.o : close.c ../include/unistd.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
+  ../include/utime.h
+ctype.s ctype.o : ctype.c ../include/ctype.h
+dup.s dup.o : dup.c ../include/unistd.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
+  ../include/utime.h
+errno.s errno.o : errno.c
+execve.s execve.o : execve.c ../include/unistd.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
+  ../include/utime.h
+malloc.s malloc.o : malloc.c ../include/linux/kernel.h ../include/linux/mm.h \
+  ../include/asm/system.h
+open.s open.o : open.c ../include/unistd.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
+  ../include/utime.h ../include/stdarg.h
+setsid.s setsid.o : setsid.c ../include/unistd.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
+  ../include/utime.h
+string.s string.o : string.c ../include/string.h
+wait.s wait.o : wait.c ../include/unistd.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
+  ../include/utime.h ../include/sys/wait.h
+write.s write.o : write.c ../include/unistd.h ../include/sys/stat.h \
+  ../include/sys/types.h ../include/sys/times.h ../include/sys/utsname.h \
+  ../include/utime.h
diff --git a/lib/_exit.c b/lib/_exit.c
index 44a74e1..c0c9d69 100644
--- a/lib/_exit.c
+++ b/lib/_exit.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/_exit.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 
diff --git a/lib/close.c b/lib/close.c
index 182d7eb..afd8364 100644
--- a/lib/close.c
+++ b/lib/close.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/close.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 
diff --git a/lib/ctype.c b/lib/ctype.c
index 6e3c07f..3793dca 100644
--- a/lib/ctype.c
+++ b/lib/ctype.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/ctype.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #include <ctype.h>
 
 char _ctmp;
diff --git a/lib/dup.c b/lib/dup.c
index 03bd5d0..dd13414 100644
--- a/lib/dup.c
+++ b/lib/dup.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/dup.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 
diff --git a/lib/errno.c b/lib/errno.c
index 6e7bb62..50aca2e 100644
--- a/lib/errno.c
+++ b/lib/errno.c
@@ -1 +1,7 @@
+/*
+ *  linux/lib/errno.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 int errno;
diff --git a/lib/execve.c b/lib/execve.c
index 03772e3..a89726d 100644
--- a/lib/execve.c
+++ b/lib/execve.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/execve.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 
diff --git a/lib/malloc.c b/lib/malloc.c
new file mode 100644
index 0000000..21552ed
--- /dev/null
+++ b/lib/malloc.c
@@ -0,0 +1,231 @@
+/*
+ * malloc.c --- a general purpose kernel memory allocator for Linux.
+ *
+ * Written by Theodore Ts'o (tytso@mit.edu), 11/29/91
+ *
+ * This routine is written to be as fast as possible, so that it
+ * can be called from the interrupt level.
+ *
+ * Limitations: maximum size of memory we can allocate using this routine
+ *	is 4k, the size of a page in Linux.
+ *
+ * The general game plan is that each page (called a bucket) will only hold
+ * objects of a given size.  When all of the object on a page are released,
+ * the page can be returned to the general free pool.  When malloc() is
+ * called, it looks for the smallest bucket size which will fulfill its
+ * request, and allocate a piece of memory from that bucket pool.
+ *
+ * Each bucket has as its control block a bucket descriptor which keeps
+ * track of how many objects are in use on that page, and the free list
+ * for that page.  Like the buckets themselves, bucket descriptors are
+ * stored on pages requested from get_free_page().  However, unlike buckets,
+ * pages devoted to bucket descriptor pages are never released back to the
+ * system.  Fortunately, a system should probably only need 1 or 2 bucket
+ * descriptor pages, since a page can hold 256 bucket descriptors (which
+ * corresponds to 1 megabyte worth of bucket pages.)  If the kernel is using
+ * that much allocated memory, it's probably doing something wrong.  :-)
+ *
+ * Note: malloc() and free() both call get_free_page() and free_page()
+ *	in sections of code where interrupts are turned off, to allow
+ *	malloc() and free() to be safely called from an interrupt routine.
+ *	(We will probably need this functionality when networking code,
+ *	particularily things like NFS, is added to Linux.)  However, this
+ *	presumes that get_free_page() and free_page() are interrupt-level
+ *	safe, which they may not be once paging is added.  If this is the
+ *	case, we will need to modify malloc() to keep a few unused pages
+ *	"pre-allocated" so that it can safely draw upon those pages if
+ * 	it is called from an interrupt routine.
+ *
+ * 	Another concern is that get_free_page() should not sleep; if it
+ *	does, the code is carefully ordered so as to avoid any race
+ *	conditions.  The catch is that if malloc() is called re-entrantly,
+ *	there is a chance that unecessary pages will be grabbed from the
+ *	system.  Except for the pages for the bucket descriptor page, the
+ *	extra pages will eventually get released back to the system, though,
+ *	so it isn't all that bad.
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <asm/system.h>
+
+struct bucket_desc {	/* 16 bytes */
+	void			*page;
+	struct bucket_desc	*next;
+	void			*freeptr;
+	unsigned short		refcnt;
+	unsigned short		bucket_size;
+};
+
+struct _bucket_dir {	/* 8 bytes */
+	int			size;
+	struct bucket_desc	*chain;
+};
+
+/*
+ * The following is the where we store a pointer to the first bucket
+ * descriptor for a given size.
+ *
+ * If it turns out that the Linux kernel allocates a lot of objects of a
+ * specific size, then we may want to add that specific size to this list,
+ * since that will allow the memory to be allocated more efficiently.
+ * However, since an entire page must be dedicated to each specific size
+ * on this list, some amount of temperance must be exercised here.
+ *
+ * Note that this list *must* be kept in order.
+ */
+struct _bucket_dir bucket_dir[] = {
+	{ 16,	(struct bucket_desc *) 0},
+	{ 32,	(struct bucket_desc *) 0},
+	{ 64,	(struct bucket_desc *) 0},
+	{ 128,	(struct bucket_desc *) 0},
+	{ 256,	(struct bucket_desc *) 0},
+	{ 512,	(struct bucket_desc *) 0},
+	{ 1024,	(struct bucket_desc *) 0},
+	{ 2048,	(struct bucket_desc *) 0},
+	{ 4096,	(struct bucket_desc *) 0},
+	{ 0,	(struct bucket_desc *) 0}};	/* End of list marker */
+
+/*
+ * This contains a linked list of free bucket descriptor blocks
+ */
+struct bucket_desc *free_bucket_desc = (struct bucket_desc *) 0;
+
+/*
+ * This routine initializes a bucket description page.
+ */
+static inline void init_bucket_desc()
+{
+	struct bucket_desc *bdesc, *first;
+	int	i;
+
+	first = bdesc = (struct bucket_desc *) get_free_page();
+	if (!bdesc)
+		panic("Out of memory in init_bucket_desc()");
+	for (i = PAGE_SIZE/sizeof(struct bucket_desc); i > 1; i--) {
+		bdesc->next = bdesc+1;
+		bdesc++;
+	}
+	/*
+	 * This is done last, to avoid race conditions in case
+	 * get_free_page() sleeps and this routine gets called again....
+	 */
+	bdesc->next = free_bucket_desc;
+	free_bucket_desc = first;
+}
+
+void *malloc(unsigned int len)
+{
+	struct _bucket_dir	*bdir;
+	struct bucket_desc	*bdesc;
+	void			*retval;
+
+	/*
+	 * First we search the bucket_dir to find the right bucket change
+	 * for this request.
+	 */
+	for (bdir = bucket_dir; bdir->size; bdir++)
+		if (bdir->size >= len)
+			break;
+	if (!bdir->size) {
+		printk("malloc called with impossibly large argument (%d)\n",
+			len);
+		panic("malloc: bad arg");
+	}
+	/*
+	 * Now we search for a bucket descriptor which has free space
+	 */
+	cli();	/* Avoid race conditions */
+	for (bdesc = bdir->chain; bdesc; bdesc = bdesc->next)
+		if (bdesc->freeptr)
+			break;
+	/*
+	 * If we didn't find a bucket with free space, then we'll
+	 * allocate a new one.
+	 */
+	if (!bdesc) {
+		char		*cp;
+		int		i;
+
+		if (!free_bucket_desc)
+			init_bucket_desc();
+		bdesc = free_bucket_desc;
+		free_bucket_desc = bdesc->next;
+		bdesc->refcnt = 0;
+		bdesc->bucket_size = bdir->size;
+		bdesc->page = bdesc->freeptr = (void *) cp = get_free_page();
+		if (!cp)
+			panic("Out of memory in kernel malloc()");
+		/* Set up the chain of free objects */
+		for (i=PAGE_SIZE/bdir->size; i > 1; i--) {
+			*((char **) cp) = cp + bdir->size;
+			cp += bdir->size;
+		}
+		*((char **) cp) = 0;
+		bdesc->next = bdir->chain; /* OK, link it in! */
+		bdir->chain = bdesc;
+	}
+	retval = (void *) bdesc->freeptr;
+	bdesc->freeptr = *((void **) retval);
+	bdesc->refcnt++;
+	sti();	/* OK, we're safe again */
+	return(retval);
+}
+
+/*
+ * Here is the free routine.  If you know the size of the object that you
+ * are freeing, then free_s() will use that information to speed up the
+ * search for the bucket descriptor.
+ *
+ * We will #define a macro so that "free(x)" is becomes "free_s(x, 0)"
+ */
+void free_s(void *obj, int size)
+{
+	void		*page;
+	struct _bucket_dir	*bdir;
+	struct bucket_desc	*bdesc, *prev;
+
+	/* Calculate what page this object lives in */
+	page = (void *)  ((unsigned long) obj & 0xfffff000);
+	/* Now search the buckets looking for that page */
+	for (bdir = bucket_dir; bdir->size; bdir++) {
+		prev = 0;
+		/* If size is zero then this conditional is always false */
+		if (bdir->size < size)
+			continue;
+		for (bdesc = bdir->chain; bdesc; bdesc = bdesc->next) {
+			if (bdesc->page == page)
+				goto found;
+			prev = bdesc;
+		}
+	}
+	panic("Bad address passed to kernel free_s()");
+found:
+	cli(); /* To avoid race conditions */
+	*((void **)obj) = bdesc->freeptr;
+	bdesc->freeptr = obj;
+	bdesc->refcnt--;
+	if (bdesc->refcnt == 0) {
+		/*
+		 * We need to make sure that prev is still accurate.  It
+		 * may not be, if someone rudely interrupted us....
+		 */
+		if ((prev && (prev->next != bdesc)) ||
+		    (!prev && (bdir->chain != bdesc)))
+			for (prev = bdir->chain; prev; prev = prev->next)
+				if (prev->next == bdesc)
+					break;
+		if (prev)
+			prev->next = bdesc->next;
+		else {
+			if (bdir->chain != bdesc)
+				panic("malloc bucket chains corrupted");
+			bdir->chain = bdesc->next;
+		}
+		free_page((unsigned long) bdesc->page);
+		bdesc->next = free_bucket_desc;
+		free_bucket_desc = bdesc;
+	}
+	sti();
+	return;
+}
diff --git a/lib/open.c b/lib/open.c
index bc50f5f..8c3fc58 100644
--- a/lib/open.c
+++ b/lib/open.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/open.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 #include <stdarg.h>
@@ -10,7 +16,7 @@ int open(const char * filename, int flag, ...)
 	va_start(arg,flag);
 	__asm__("int $0x80"
 		:"=a" (res)
-		:"" (__NR_open),"b" (filename),"c" (flag),
+		:"0" (__NR_open),"b" (filename),"c" (flag),
 		"d" (va_arg(arg,int)));
 	if (res>=0)
 		return res;
diff --git a/lib/setsid.c b/lib/setsid.c
index 730abf0..68516c7 100644
--- a/lib/setsid.c
+++ b/lib/setsid.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/setsid.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 
diff --git a/lib/string.c b/lib/string.c
index f6befd9..1182e63 100644
--- a/lib/string.c
+++ b/lib/string.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/string.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #ifndef __GNUC__
 #error I want gcc!
 #endif
diff --git a/lib/wait.c b/lib/wait.c
index a14555c..2815c16 100644
--- a/lib/wait.c
+++ b/lib/wait.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/wait.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 #include <sys/wait.h>
diff --git a/lib/write.c b/lib/write.c
index 2613f17..df52e74 100644
--- a/lib/write.c
+++ b/lib/write.c
@@ -1,3 +1,9 @@
+/*
+ *  linux/lib/write.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
 #define __LIBRARY__
 #include <unistd.h>
 
diff --git a/mm/Makefile b/mm/Makefile
index 20eb848..1b6c359 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -33,5 +33,5 @@ dep:
 
 ### Dependencies:
 memory.o : memory.c ../include/signal.h ../include/sys/types.h \
-  ../include/linux/config.h ../include/linux/head.h ../include/linux/kernel.h \
-  ../include/asm/system.h
+  ../include/asm/system.h ../include/linux/sched.h ../include/linux/head.h \
+  ../include/linux/fs.h ../include/linux/mm.h ../include/linux/kernel.h
diff --git a/mm/memory.c b/mm/memory.c
index f94600e..2ca92ca 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1,34 +1,60 @@
+/*
+ *  linux/mm/memory.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ * demand-loading started 01.12.91 - seems it is high on the list of
+ * things wanted, and it should be easy to implement. - Linus
+ */
+
+/*
+ * Ok, demand-loading was easy, shared pages a little bit tricker. Shared
+ * pages started 02.12.91, seems to work. - Linus.
+ *
+ * Tested sharing by executing about 30 /bin/sh: under the old kernel it
+ * would have taken more than the 6M I have free, but it worked well as
+ * far as I could see.
+ *
+ * Also corrected some "invalidate()"s - I wasn't doing enough of them.
+ */
+
 #include <signal.h>
 
-#include <linux/config.h>
+#include <asm/system.h>
+
+#include <linux/sched.h>
 #include <linux/head.h>
 #include <linux/kernel.h>
-#include <asm/system.h>
 
-int do_exit(long code);
+volatile void do_exit(long code);
+
+static inline volatile void oom(void)
+{
+	printk("out of memory\n\r");
+	do_exit(SIGSEGV);
+}
 
 #define invalidate() \
 __asm__("movl %%eax,%%cr3"::"a" (0))
 
-#if (BUFFER_END < 0x100000)
+/* these are not to be changed without changing head.s etc */
 #define LOW_MEM 0x100000
-#else
-#define LOW_MEM BUFFER_END
-#endif
-
-/* these are not to be changed - thay are calculated from the above */
-#define PAGING_MEMORY (HIGH_MEMORY - LOW_MEM)
-#define PAGING_PAGES (PAGING_MEMORY/4096)
+#define PAGING_MEMORY (15*1024*1024)
+#define PAGING_PAGES (PAGING_MEMORY>>12)
 #define MAP_NR(addr) (((addr)-LOW_MEM)>>12)
+#define USED 100
 
-#if (PAGING_PAGES < 10)
-#error "Won't work"
-#endif
+#define CODE_SPACE(addr) ((((addr)+4095)&~4095) < \
+current->start_code + current->end_code)
+
+static long HIGH_MEMORY = 0;
 
 #define copy_page(from,to) \
 __asm__("cld ; rep ; movsl"::"S" (from),"D" (to),"c" (1024):"cx","di","si")
 
-static unsigned short mem_map [ PAGING_PAGES ] = {0,};
+static unsigned char mem_map [ PAGING_PAGES ] = {0,};
 
 /*
  * Get physical address of first (actually last :-) free page, and mark it
@@ -38,19 +64,19 @@ unsigned long get_free_page(void)
 {
 register unsigned long __res asm("ax");
 
-__asm__("std ; repne ; scasw\n\t"
+__asm__("std ; repne ; scasb\n\t"
 	"jne 1f\n\t"
-	"movw $1,2(%%edi)\n\t"
+	"movb $1,1(%%edi)\n\t"
 	"sall $12,%%ecx\n\t"
+	"addl %2,%%ecx\n\t"
 	"movl %%ecx,%%edx\n\t"
-	"addl %2,%%edx\n\t"
 	"movl $1024,%%ecx\n\t"
 	"leal 4092(%%edx),%%edi\n\t"
 	"rep ; stosl\n\t"
 	"movl %%edx,%%eax\n"
 	"1:"
 	:"=a" (__res)
-	:"" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
+	:"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
 	"D" (mem_map+PAGING_PAGES-1)
 	:"di","cx","dx");
 return __res;
@@ -174,7 +200,7 @@ unsigned long put_page(unsigned long page,unsigned long address)
 
 /* NOTE !!! This uses the fact that _pg_dir=0 */
 
-	if (page < LOW_MEM || page > HIGH_MEMORY)
+	if (page < LOW_MEM || page >= HIGH_MEMORY)
 		printk("Trying to put page %p at %p\n",page,address);
 	if (mem_map[(page-LOW_MEM)>>12] != 1)
 		printk("mem_map disagrees with %p at %p\n",page,address);
@@ -188,6 +214,7 @@ unsigned long put_page(unsigned long page,unsigned long address)
 		page_table = (unsigned long *) tmp;
 	}
 	page_table[(address>>12) & 0x3ff] = page | 7;
+/* no need for invalidate */
 	return page;
 }
 
@@ -198,13 +225,15 @@ void un_wp_page(unsigned long * table_entry)
 	old_page = 0xfffff000 & *table_entry;
 	if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)]==1) {
 		*table_entry |= 2;
+		invalidate();
 		return;
 	}
 	if (!(new_page=get_free_page()))
-		do_exit(SIGSEGV);
+		oom();
 	if (old_page >= LOW_MEM)
 		mem_map[MAP_NR(old_page)]--;
 	*table_entry = new_page | 7;
+	invalidate();
 	copy_page(old_page,new_page);
 }
 
@@ -212,9 +241,17 @@ void un_wp_page(unsigned long * table_entry)
  * This routine handles present pages, when users try to write
  * to a shared page. It is done by copying the page to a new address
  * and decrementing the shared-page counter for the old page.
+ *
+ * If it's in code space we exit with a segment error.
  */
 void do_wp_page(unsigned long error_code,unsigned long address)
 {
+#if 0
+/* we cannot do this yet: the estdio library writes to code space */
+/* stupid, stupid. I really want the libc.a from GNU */
+	if (CODE_SPACE(address))
+		do_exit(SIGSEGV);
+#endif
 	un_wp_page((unsigned long *)
 		(((address>>10) & 0xffc) + (0xfffff000 &
 		*((unsigned long *) ((address>>20) &0xffc)))));
@@ -234,14 +271,143 @@ void write_verify(unsigned long address)
 	return;
 }
 
+void get_empty_page(unsigned long address)
+{
+	unsigned long tmp;
+
+	if (!(tmp=get_free_page()) || !put_page(tmp,address)) {
+		free_page(tmp);		/* 0 is ok - ignored */
+		oom();
+	}
+}
+
+/*
+ * try_to_share() checks the page at address "address" in the task "p",
+ * to see if it exists, and if it is clean. If so, share it with the current
+ * task.
+ *
+ * NOTE! This assumes we have checked that p != current, and that they
+ * share the same executable.
+ */
+static int try_to_share(unsigned long address, struct task_struct * p)
+{
+	unsigned long from;
+	unsigned long to;
+	unsigned long from_page;
+	unsigned long to_page;
+	unsigned long phys_addr;
+
+	from_page = to_page = ((address>>20) & 0xffc);
+	from_page += ((p->start_code>>20) & 0xffc);
+	to_page += ((current->start_code>>20) & 0xffc);
+/* is there a page-directory at from? */
+	from = *(unsigned long *) from_page;
+	if (!(from & 1))
+		return 0;
+	from &= 0xfffff000;
+	from_page = from + ((address>>10) & 0xffc);
+	phys_addr = *(unsigned long *) from_page;
+/* is the page clean and present? */
+	if ((phys_addr & 0x41) != 0x01)
+		return 0;
+	phys_addr &= 0xfffff000;
+	if (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)
+		return 0;
+	to = *(unsigned long *) to_page;
+	if (!(to & 1))
+		if (to = get_free_page())
+			*(unsigned long *) to_page = to | 7;
+		else
+			oom();
+	to &= 0xfffff000;
+	to_page = to + ((address>>10) & 0xffc);
+	if (1 & *(unsigned long *) to_page)
+		panic("try_to_share: to_page already exists");
+/* share them: write-protect */
+	*(unsigned long *) from_page &= ~2;
+	*(unsigned long *) to_page = *(unsigned long *) from_page;
+	invalidate();
+	phys_addr -= LOW_MEM;
+	phys_addr >>= 12;
+	mem_map[phys_addr]++;
+	return 1;
+}
+
+/*
+ * share_page() tries to find a process that could share a page with
+ * the current one. Address is the address of the wanted page relative
+ * to the current data space.
+ *
+ * We first check if it is at all feasible by checking executable->i_count.
+ * It should be >1 if there are other tasks sharing this inode.
+ */
+static int share_page(unsigned long address)
+{
+	struct task_struct ** p;
+
+	if (!current->executable)
+		return 0;
+	if (current->executable->i_count < 2)
+		return 0;
+	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
+		if (!*p)
+			continue;
+		if (current == *p)
+			continue;
+		if ((*p)->executable != current->executable)
+			continue;
+		if (try_to_share(address,*p))
+			return 1;
+	}
+	return 0;
+}
+
 void do_no_page(unsigned long error_code,unsigned long address)
 {
+	int nr[4];
 	unsigned long tmp;
+	unsigned long page;
+	int block,i;
 
-	if (tmp=get_free_page())
-		if (put_page(tmp,address))
-			return;
-	do_exit(SIGSEGV);
+	address &= 0xfffff000;
+	tmp = address - current->start_code;
+	if (!current->executable || tmp >= current->end_data) {
+		get_empty_page(address);
+		return;
+	}
+	if (share_page(tmp))
+		return;
+	if (!(page = get_free_page()))
+		oom();
+/* remember that 1 block is used for header */
+	block = 1 + tmp/BLOCK_SIZE;
+	for (i=0 ; i<4 ; block++,i++)
+		nr[i] = bmap(current->executable,block);
+	bread_page(page,current->executable->i_dev,nr);
+	i = tmp + 4096 - current->end_data;
+	tmp = page + 4096;
+	while (i-- > 0) {
+		tmp--;
+		*(char *)tmp = 0;
+	}
+	if (put_page(page,address))
+		return;
+	free_page(page);
+	oom();
+}
+
+void mem_init(long start_mem, long end_mem)
+{
+	int i;
+
+	HIGH_MEMORY = end_mem;
+	for (i=0 ; i<PAGING_PAGES ; i++)
+		mem_map[i] = USED;
+	i = MAP_NR(start_mem);
+	end_mem -= start_mem;
+	end_mem >>= 12;
+	while (end_mem-->0)
+		mem_map[i++]=0;
 }
 
 void calc_mem(void)
diff --git a/mm/page.s b/mm/page.s
index 27488c2..bd1c586 100644
--- a/mm/page.s
+++ b/mm/page.s
@@ -1,4 +1,10 @@
 /*
+ *  linux/mm/page.s
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
  * page.s contains the low-level page-exception code.
  * the real work is done in mm.c
  */
diff --git a/tools/build.c b/tools/build.c
index fbdca99..05ba43f 100644
--- a/tools/build.c
+++ b/tools/build.c
@@ -1,12 +1,48 @@
-#include <stdio.h>      /* fprintf */
-#include <stdlib.h>     /* contains exit */
-#include <sys/types.h>  /* unistd.h needs this */
-#include <unistd.h>     /* contains read/write */
+/*
+ *  linux/tools/build.c
+ *
+ *  (C) 1991  Linus Torvalds
+ */
+
+/*
+ * This file builds a disk-image from three different files:
+ *
+ * - bootsect: max 510 bytes of 8086 machine code, loads the rest
+ * - setup: max 4 sectors of 8086 machine code, sets up system parm
+ * - system: 80386 code for actual system
+ *
+ * It does some checking that all files are of the correct type, and
+ * just writes the result to stdout, removing headers and padding to
+ * the right amount. It also writes some system data to stderr.
+ */
+
+/*
+ * Changes by tytso to allow root device specification
+ */
+
+#include <stdio.h>	/* fprintf */
+#include <string.h>
+#include <stdlib.h>	/* contains exit */
+#include <sys/types.h>	/* unistd.h needs this */
+#include <sys/stat.h>
+#include <linux/fs.h>
+#include <unistd.h>	/* contains read/write */
 #include <fcntl.h>
 
 #define MINIX_HEADER 32
 #define GCC_HEADER 1024
 
+#define SYS_SIZE 0x2000
+
+#define DEFAULT_MAJOR_ROOT 3
+#define DEFAULT_MINOR_ROOT 6
+
+/* max nr of sectors of setup: don't change unless you also change
+ * bootsect etc */
+#define SETUP_SECTS 4
+
+#define STRINGIFY(x) #x
+
 void die(char * str)
 {
 	fprintf(stderr,"%s\n",str);
@@ -15,16 +51,41 @@ void die(char * str)
 
 void usage(void)
 {
-	die("Usage: build boot system [> image]");
+	die("Usage: build bootsect setup system [rootdev] [> image]");
 }
 
 int main(int argc, char ** argv)
 {
 	int i,c,id;
 	char buf[1024];
+	char major_root, minor_root;
+	struct stat sb;
 
-	if (argc != 3)
+	if ((argc != 4) && (argc != 5))
 		usage();
+	if (argc == 5) {
+		if (strcmp(argv[4], "FLOPPY")) {
+			if (stat(argv[4], &sb)) {
+				perror(argv[4]);
+				die("Couldn't stat root device.");
+			}
+			major_root = MAJOR(sb.st_rdev);
+			minor_root = MINOR(sb.st_rdev);
+		} else {
+			major_root = 0;
+			minor_root = 0;
+		}
+	} else {
+		major_root = DEFAULT_MAJOR_ROOT;
+		minor_root = DEFAULT_MINOR_ROOT;
+	}
+	fprintf(stderr, "Root device is (%d, %d)\n", major_root, minor_root);
+	if ((major_root != 2) && (major_root != 3) &&
+	    (major_root != 0)) {
+		fprintf(stderr, "Illegal root device (major = %d)\n",
+			major_root);
+		die("Bad root device --- major #");
+	}
 	for (i=0;i<sizeof buf; i++) buf[i]=0;
 	if ((id=open(argv[1],O_RDONLY,0))<0)
 		die("Unable to open 'boot'");
@@ -44,16 +105,53 @@ int main(int argc, char ** argv)
 		die("Illegal symbol table in 'boot'");
 	i=read(id,buf,sizeof buf);
 	fprintf(stderr,"Boot sector %d bytes.\n",i);
-	if (i>510)
-		die("Boot block may not exceed 510 bytes");
-	buf[510]=0x55;
-	buf[511]=0xAA;
+	if (i != 512)
+		die("Boot block must be exactly 512 bytes");
+	if ((*(unsigned short *)(buf+510)) != 0xAA55)
+		die("Boot block hasn't got boot flag (0xAA55)");
+	buf[508] = (char) minor_root;
+	buf[509] = (char) major_root;
 	i=write(1,buf,512);
 	if (i!=512)
 		die("Write call failed");
 	close (id);
 
 	if ((id=open(argv[2],O_RDONLY,0))<0)
+		die("Unable to open 'setup'");
+	if (read(id,buf,MINIX_HEADER) != MINIX_HEADER)
+		die("Unable to read header of 'setup'");
+	if (((long *) buf)[0]!=0x04100301)
+		die("Non-Minix header of 'setup'");
+	if (((long *) buf)[1]!=MINIX_HEADER)
+		die("Non-Minix header of 'setup'");
+	if (((long *) buf)[3]!=0)
+		die("Illegal data segment in 'setup'");
+	if (((long *) buf)[4]!=0)
+		die("Illegal bss in 'setup'");
+	if (((long *) buf)[5] != 0)
+		die("Non-Minix header of 'setup'");
+	if (((long *) buf)[7] != 0)
+		die("Illegal symbol table in 'setup'");
+	for (i=0 ; (c=read(id,buf,sizeof buf))>0 ; i+=c )
+		if (write(1,buf,c)!=c)
+			die("Write call failed");
+	close (id);
+	if (i > SETUP_SECTS*512)
+		die("Setup exceeds " STRINGIFY(SETUP_SECTS)
+			" sectors - rewrite build/boot/setup");
+	fprintf(stderr,"Setup is %d bytes.\n",i);
+	for (c=0 ; c<sizeof(buf) ; c++)
+		buf[c] = '\0';
+	while (i<SETUP_SECTS*512) {
+		c = SETUP_SECTS*512-i;
+		if (c > sizeof(buf))
+			c = sizeof(buf);
+		if (write(1,buf,c) != c)
+			die("Write call failed");
+		i += c;
+	}
+
+	if ((id=open(argv[3],O_RDONLY,0))<0)
 		die("Unable to open 'system'");
 	if (read(id,buf,GCC_HEADER) != GCC_HEADER)
 		die("Unable to read header of 'system'");
@@ -63,6 +161,8 @@ int main(int argc, char ** argv)
 		if (write(1,buf,c)!=c)
 			die("Write call failed");
 	close(id);
-	fprintf(stderr,"System %d bytes.\n",i);
+	fprintf(stderr,"System is %d bytes.\n",i);
+	if (i > SYS_SIZE*16)
+		die("System is too big");
 	return(0);
 }
-- 
2.9.3

